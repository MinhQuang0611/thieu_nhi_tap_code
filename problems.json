[
    {
        "problem_id": "palindrome-number-000",
        "topic": "Chương 1",
        "sub_topic": "Biến và Kiểu dữ liệu",
        "name": "Palindrome Number",
        "description": "## Palindrome Number\n**Xác định xem một số nguyên có đọc xuôi ngược giống nhau hay không.**\n- **Input:** số nguyên x (−2^31 <= x <= 2^31−1)\n- **Output:** true nếu x là palindrome, false nếu không\n- **Example:** 121→true, -121→false, 10→false\n- **Constraints:** x là số nguyên 32-bit signed",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n  def isPalindrome(self, x: int) -> bool:\n  s = str(x)\n  return s == s[::-1]",
        "public_test_path": "/id/public/palindrome-number-000",
        "hidden_test_path": "/id/hidden/palindrome-number-000",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 17
    },
    {
        "problem_id": "reverse-integer-001",
        "topic": "Chương 1",
        "sub_topic": "Biến và Kiểu dữ liệu",
        "name": "Reverse Integer",
        "description": "## Reverse Integer\n**Đảo ngược các chữ số của một số nguyên có dấu 32-bit.**\n- **Input:** số nguyên x (−2^31 <= x <= 2^31−1)\n- **Output:** số đảo ngược chữ số của x, hoặc 0 nếu vượt ngoài phạm vi 32-bit signed\n- **Example:** 123→321, -123→-321, 120→21, 1534236469→0\n- **Constraints:** phải nằm trong phạm vi 32-bit signed",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n  def reverse(self, x: int) -> int:\n  sign=-1 if x<0 else 1\n  rev=0\n  x=abs(x)\n  while(x>0):\n  last=x%10\n  x=x//10\n  rev=(rev*10)+last\n  rev=rev*sign\n  if rev<-2**31 or rev>2**31-1:\n  return 0\n  return rev",
        "public_test_path": "/id/public/reverse-integer-001",
        "hidden_test_path": "/id/hidden/reverse-integer-001",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 26
    },
    {
        "problem_id": "roman-to-integer-002",
        "topic": "Chương 1",
        "sub_topic": "Biến và Kiểu dữ liệu",
        "name": "Roman to Integer",
        "description": "## Roman to Integer\n**Chuyển đổi một chuỗi số La Mã sang số nguyên.**\n- **Input:** chuỗi s chứa ký tự số La Mã (1 <= |s| <= 15)\n- **Output:** số nguyên tương ứng\n- **Example:** \"III\"→3, \"LVIII\"→58, \"MCMXCIV\"→1994\n- **Constraints:** s chỉ chứa I,V,X,L,C,D,M và nằm trong [1,3999]",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution(object):\n  # @return an integer\n  def romanToInt(self, s):\n  numeral_map = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\":100, \"D\": 500, \"M\": 1000}\n  decimal = 0\n  for i in range(len(s)):\n  if i > 0 and numeral_map[s[i]] > numeral_map[s[i - 1]]:\n  decimal += numeral_map[s[i]] - 2 * numeral_map[s[i - 1]]\n  else:\n  decimal += numeral_map[s[i]]\n  return decimal",
        "public_test_path": "/id/public/roman-to-integer-002",
        "hidden_test_path": "/id/hidden/roman-to-integer-002",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "single-number-003",
        "topic": "Chương 1",
        "sub_topic": "Biến và Kiểu dữ liệu",
        "name": "Single Number",
        "description": "## Single Number\n**Tìm số xuất hiện đúng một lần trong mảng khi các số khác xuất hiện đúng 2 lần.**\n- **Input:** mảng nums độ dài n (1 <= n <= 3*10^4, −3*10^4 <= nums[i] <= 3*10^4)\n- **Output:** số xuất hiện một lần\n- **Example:** [2,2,1]→1, [4,1,2,1,2]→4\n- **Constraints:** O(n) time, O(1) extra space",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import operator\n from functools import reduce\n \n \n class Solution(object):\n  \"\"\"\n  :type nums: List[int]\n  :rtype: int\n  \"\"\"\n  def singleNumber(self, A):\n  return reduce(operator.xor, A)",
        "public_test_path": "/id/public/single-number-003",
        "hidden_test_path": "/id/hidden/single-number-003",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "number-of-1-bits-004",
        "topic": "Chương 1",
        "sub_topic": "Biến và Kiểu dữ liệu",
        "name": "Number of 1 Bits",
        "description": "## Number of 1 Bits\n**Đếm số bit '1' trong biểu diễn nhị phân của một số nguyên không âm 32-bit.**\n- **Input:** số nguyên không âm 32-bit\n- **Output:** số lượng bit '1'\n- **Example:** 00000000000000000000000000001011→3, 00000000000000000000000010000000→1\n- **Constraints:** input là unsigned 32-bit",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n  def hammingWeight(self, n: int) -> int:\n  count = 0\n  while n:\n  # Turn off the rightmost 1-bit\n  n &= n - 1\n  # Increment count as a 1-bit is removed\n  count += 1\n  return count",
        "public_test_path": "/id/public/number-of-1-bits-004",
        "hidden_test_path": "/id/hidden/number-of-1-bits-004",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "two-sum-005",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Two Sum",
        "description": "## Two Sum\n**Tìm hai chỉ số trong mảng sao cho tổng bằng target.**\n- **Input:** mảng nums độ dài n (2 <= n <= 10^4, −10^9 <= nums[i] <= 10^9), target (−10^9 <= target <= 10^9)\n- **Output:** chỉ số 2 phần tử có tổng = target\n- **Example:** nums=[2,7,11,15], target=9→[0,1]\n- **Constraints:** luôn có đúng 1 lời giải, không dùng lại 1 phần tử",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution(object):\n  def twoSum(self, nums, target):\n  \"\"\"\n  :type nums: List[int]\n  :type target: int\n  :rtype: List[int]\n  \"\"\"\n  lookup = {}\n  for i, num in enumerate(nums):\n  if target - num in lookup:\n  return [lookup[target - num], i]\n  lookup[num] = i",
        "public_test_path": "/id/public/two-sum-005",
        "hidden_test_path": "/id/hidden/two-sum-005",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "remove-duplicates-from-sorted-array-006",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Remove Duplicates from Sorted Array",
        "description": "## Remove Duplicates from Sorted Array\n**Xóa trùng lặp khỏi mảng đã sắp xếp sao cho mỗi phần tử xuất hiện một lần.**\n- **Input:** mảng nums đã sắp xếp tăng dần (0 <= n <= 3*10^4, −100 <= nums[i] <= 100)\n- **Output:** độ dài mới sau khi loại bỏ trùng, mảng được sửa in-place\n- **Example:** [1,1,2]→k=2, nums=[1,2,_]\n- **Constraints:** O(1) extra space",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(n)\n # Space: O(1)\n \n class Solution(object):\n  # @param a list of integers\n  # @return an integer\n  def removeDuplicates(self, A):\n  if not A:\n  return 0\n \n  last = 0\n  for i in range(len(A)):\n  if A[last] != A[i]:\n  last += 1\n  A[last] = A[i]\n  return last + 1",
        "public_test_path": "/id/public/remove-duplicates-from-sorted-array-006",
        "hidden_test_path": "/id/hidden/remove-duplicates-from-sorted-array-006",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 25
    },
    {
        "problem_id": "remove-element-007",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Remove Element",
        "description": "## Remove Element\n**Xóa tất cả phần tử có giá trị bằng val khỏi mảng.**\n- **Input:** mảng nums và số val (0 <= n <= 100, 0 <= nums[i] <= 50, 0 <= val <= 100)\n- **Output:** độ dài mới sau khi loại bỏ val, in-place\n- **Example:** nums=[3,2,2,3], val=3→k=2, nums=[2,2,_]\n- **Constraints:** O(1) extra space",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(n)\n # Space: O(1)\n \n class Solution(object):\n  # @param A a list of integers\n  # @param elem an integer, value need to be removed\n  # @return an integer\n  def removeElement(self, A, elem):\n  i, last = 0, len(A) - 1\n  while i <= last:\n  if A[i] == elem:\n  A[i], A[last] = A[last], A[i]\n  last -= 1\n  else:\n  i += 1\n  return last + 1",
        "public_test_path": "/id/public/remove-element-007",
        "hidden_test_path": "/id/hidden/remove-element-007",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "merge-sorted-array-008",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Merge Sorted Array",
        "description": "## Merge Sorted Array\n**Hợp nhất hai mảng đã sắp xếp thành một mảng sắp xếp tăng dần.**\n- **Input:** nums1 kích thước m+n (0 <= m,n <= 200, −10^9 <= nums[i], nums2[j] <= 10^9), nums2 kích thước n\n- **Output:** nums1 chứa m+n phần tử đã sắp xếp\n- **Example:** nums1=[1,2,3,0,0,0],m=3, nums2=[2,5,6],n=3→[1,2,2,3,5,6]\n- **Constraints:** nums1.length=m+n",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(n)\n # Space: O(1)\n \n class Solution(object):\n  # @param A a list of integers\n  # @param m an integer, length of A\n  # @param B a list of integers\n  # @param n an integer, length of B\n  # @return nothing\n  def merge(self, A, m, B, n):\n  last, i, j = m + n - 1, m - 1, n - 1\n \n  while i >= 0 and j >= 0:\n  if A[i] > B[j]:\n  A[last] = A[i]\n  last, i = last - 1, i - 1\n  else:\n  A[last] = B[j]\n  last, j = last - 1, j - 1\n \n  while j >= 0:\n  A[last] = B[j]\n  last, j = last - 1, j - 1",
        "public_test_path": "/id/public/merge-sorted-array-008",
        "hidden_test_path": "/id/hidden/merge-sorted-array-008",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "best-time-to-buy-and-sell-stock-009",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Best Time to Buy and Sell Stock",
        "description": "## Best Time to Buy and Sell Stock\n**Tìm lợi nhuận tối đa khi mua một lần và bán một lần cổ phiếu.**\n- **Input:** mảng prices độ dài n (1 <= n <= 10^5, 0 <= prices[i] <= 10^4)\n- **Output:** lợi nhuận tối đa hoặc 0 nếu không có lợi nhuận\n- **Example:** [7,1,5,3,6,4]→5, [7,6,4,3,1]→0\n- **Constraints:** chỉ được mua và bán 1 lần",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(n)\n # Space: O(1)\n \n class Solution(object):\n  # @param prices, a list of integer\n  # @return an integer\n  def maxProfit(self, prices):\n  max_profit, min_price = 0, float(\"inf\")\n  for price in prices:\n  min_price = min(min_price, price)\n  max_profit = max(max_profit, price - min_price)\n  return max_profit",
        "public_test_path": "/id/public/best-time-to-buy-and-sell-stock-009",
        "hidden_test_path": "/id/hidden/best-time-to-buy-and-sell-stock-009",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "contains-duplicate-010",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Contains Duplicate",
        "description": "## Contains Duplicate\n**Kiểm tra xem mảng có phần tử trùng lặp hay không.**\n- **Input:** mảng nums độ dài n (1 <= n <= 10^5, -10^9 <= nums[i] <= 10^9)\n- **Output:** true nếu tồn tại phần tử trùng, false nếu không\n- **Example:** [1,2,3,1]→true, [1,2,3,4]→false\n- **Constraints:** O(n) time trung bình",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(n)\n # Space: O(n)\n \n class Solution(object):\n  # @param {integer[]} nums\n  # @return {boolean}\n  def containsDuplicate(self, nums):\n  return len(nums) > len(set(nums))",
        "public_test_path": "/id/public/contains-duplicate-010",
        "hidden_test_path": "/id/hidden/contains-duplicate-010",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 17
    },
    {
        "problem_id": "move-zeroes-011",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Move Zeroes",
        "description": "## Move Zeroes\n**Di chuyển tất cả số 0 về cuối mảng, giữ nguyên thứ tự phần tử khác.**\n- **Input:** mảng nums độ dài n (1 <= n <= 10^4, -2^31 <= nums[i] <= 2^31−1)\n- **Output:** mảng được chỉnh sửa in-place\n- **Example:** [0,1,0,3,12]→[1,3,12,0,0]\n- **Constraints:** phải in-place, O(n)",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution(object):\n  def moveZeroes(self, nums):\n  \"\"\"\n  :type nums: List[int]\n  :rtype: void Do not return anything, modify nums in-place instead.\n  \"\"\"\n  pos = 0\n  for i in range(len(nums)):\n  if nums[i]:\n  nums[i], nums[pos] = nums[pos], nums[i]\n  pos += 1",
        "public_test_path": "/id/public/move-zeroes-011",
        "hidden_test_path": "/id/hidden/move-zeroes-011",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 17
    },
    {
        "problem_id": "plus-one-012",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Plus One",
        "description": "## Plus One\n**Cộng thêm 1 vào số nguyên không âm biểu diễn bằng mảng chữ số.**\n- **Input:** mảng digits (1 <= |digits| <= 100, 0 <= digits[i] <= 9, không có số 0 đứng đầu trừ số 0)\n- **Output:** mảng digits mới\n- **Example:** [1,2,3]→[1,2,4], [9]→[1,0]\n- **Constraints:** độ dài tối đa 100",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution(object):\n  def plusOne(self, digits):\n  \"\"\"\n  :type digits: List[int]\n  :rtype: List[int]\n  \"\"\"\n  for i in reversed(range(len(digits))):\n  if digits[i] == 9:\n  digits[i] = 0\n  else:\n  digits[i] += 1\n  return digits\n  digits[0] = 1\n  digits.append(0)\n  return digits",
        "public_test_path": "/id/public/plus-one-012",
        "hidden_test_path": "/id/hidden/plus-one-012",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "rotate-array-013",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Rotate Array",
        "description": "## Rotate Array\n**Xoay mảng sang phải k bước.**\n- **Input:** mảng nums độ dài n (1 <= n <= 10^5, -2^31 <= nums[i] <= 2^31−1), số k (0 <= k <= 10^5)\n- **Output:** mảng sau khi xoay, in-place\n- **Example:** nums=[1,2,3,4,5,6,7], k=3→[5,6,7,1,2,3,4]\n- **Constraints:** phải in-place, O(1) extra space",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution(object):\n  \"\"\"\n  :type nums: List[int]\n  :type k: int\n  :rtype: void Do not return anything, modify nums in-place instead.\n  \"\"\"\n  def rotate(self, nums, k):\n  def reverse(nums, start, end):\n  while start < end:\n  nums[start], nums[end - 1] = nums[end - 1], nums[start]\n  start += 1\n  end -= 1\n \n  k %= len(nums)\n  reverse(nums, 0, len(nums))\n  reverse(nums, 0, k)\n  reverse(nums, k, len(nums))",
        "public_test_path": "/id/public/rotate-array-013",
        "hidden_test_path": "/id/hidden/rotate-array-013",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    },
    {
        "problem_id": "maximum-subarray-014",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Maximum Subarray",
        "description": "## Maximum Subarray\n**Tìm tổng lớn nhất của một dãy con liên tiếp.**\n- **Input:** mảng nums độ dài n (1 <= n <= 10^5, -10^4 <= nums[i] <= 10^4)\n- **Output:** tổng lớn nhất\n- **Example:** [-2,1,-3,4,-1,2,1,-5,4]→6 (subarray [4,-1,2,1])\n- **Constraints:** O(n) time",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution(object):\n  def maxSubArray(self, nums):\n  \"\"\"\n  :type nums: List[int]\n  :rtype: int\n  \"\"\"\n  result, curr = float(\"-inf\"), float(\"-inf\")\n  for x in nums:\n  curr = max(curr+x, x)\n  result = max(result, curr)\n  return result",
        "public_test_path": "/id/public/maximum-subarray-014",
        "hidden_test_path": "/id/hidden/maximum-subarray-014",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "longest-common-prefix-015",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Longest Common Prefix",
        "description": "## Longest Common Prefix\n**Tìm tiền tố chung dài nhất trong một mảng chuỗi.**\n- **Input:** mảng strings (1 <= n <= 200, 0 <= |s[i]| <= 200)\n- **Output:** chuỗi tiền tố chung dài nhất hoặc \"\" nếu không có\n- **Example:** [\"flower\",\"flow\",\"flight\"]→\"fl\", [\"dog\",\"racecar\",\"car\"]→\"\"\n- **Constraints:** tổng ký tự <= 200*200",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution(object):\n  def longestCommonPrefix(self, strs):\n  \"\"\"\n  :type strs: List[str]\n  :rtype: str\n  \"\"\"\n  if not strs:\n  return \"\"\n \n  for i in range(len(strs[0])):\n  for string in strs[1:]:\n  if i >= len(string) or string[i] != strs[0][i]:\n  return strs[0][:i]\n  return strs[0]",
        "public_test_path": "/id/public/longest-common-prefix-015",
        "hidden_test_path": "/id/hidden/longest-common-prefix-015",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "valid-parentheses-016",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Valid Parentheses",
        "description": "## Valid Parentheses\n**Kiểm tra chuỗi ngoặc có hợp lệ không.**\n- **Input:** chuỗi s (1 <= |s| <= 10^4), chỉ gồm các ký tự '()', '[]', '{}'\n- **Output:** true nếu chuỗi hợp lệ, false nếu không\n- **Example:** \"()\"→true, \"()[]{}\"→true, \"(]\"→false\n- **Constraints:** độ dài tối đa 10^4",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(n)\n # Space: O(n)\n \n class Solution(object):\n  # @return a boolean\n  def isValid(self, s):\n  stack, lookup = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n  for parenthese in s:\n  if parenthese in lookup:\n  stack.append(parenthese)\n  elif len(stack) == 0 or lookup[stack.pop()] != parenthese:\n  return False\n  return len(stack) == 0",
        "public_test_path": "/id/public/valid-parentheses-016",
        "hidden_test_path": "/id/hidden/valid-parentheses-016",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "find-the-index-of-the-first-occurrence-in-a-string-017",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Find the Index of the First Occurrence in a String",
        "description": "## Find the Index of the First Occurrence in a String\n**Tìm vị trí xuất hiện đầu tiên của chuỗi needle trong haystack.**\n- **Input:** haystack và needle (1 <= |haystack|,|needle| <= 10^4)\n- **Output:** chỉ số bắt đầu, hoặc -1 nếu không tồn tại\n- **Example:** haystack=\"sadbutsad\", needle=\"sad\"→0\n- **Constraints:** O(|haystack|*|needle|)",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n  def strStr(self, haystack: str, needle: str) -> int:\n  return haystack.find(needle)",
        "public_test_path": "/id/public/find-the-index-of-the-first-occurrence-in-a-string-017",
        "hidden_test_path": "/id/hidden/find-the-index-of-the-first-occurrence-in-a-string-017",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "valid-palindrome-018",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Valid Palindrome",
        "description": "## Valid Palindrome\n**Kiểm tra chuỗi có phải palindrome không (bỏ qua ký tự không phải chữ-số, không phân biệt hoa thường).**\n- **Input:** chuỗi s (1 <= |s| <= 2*10^5)\n- **Output:** true nếu s là palindrome, false nếu không\n- **Example:** \"A man, a plan, a canal: Panama\"→true, \"race a car\"→false\n- **Constraints:** độ dài tối đa 2*10^5",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(n)\n # Space: O(1)\n \n class Solution(object):\n  # @param s, a string\n  # @return a boolean\n  def isPalindrome(self, s):\n  i, j = 0, len(s) - 1\n  while i < j:\n  while i < j and not s[i].isalnum():\n  i += 1\n  while i < j and not s[j].isalnum():\n  j -= 1\n  if s[i].lower() != s[j].lower():\n  return False\n  i, j = i + 1, j - 1\n  return True",
        "public_test_path": "/id/public/valid-palindrome-018",
        "hidden_test_path": "/id/hidden/valid-palindrome-018",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 26
    },
    {
        "problem_id": "reverse-string-019",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Reverse String",
        "description": "## Reverse String\n**Đảo ngược mảng ký tự in-place.**\n- **Input:** mảng ký tự s (1 <= |s| <= 10^5)\n- **Output:** mảng ký tự đảo ngược\n- **Example:** [\"h\",\"e\",\"l\",\"l\",\"o\"]→[\"o\",\"l\",\"l\",\"e\",\"h\"]\n- **Constraints:** O(1) extra space",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(n)\n # Space: O(1)\n \n class Solution(object):\n  def reverseString(self, s):\n  \"\"\"\n  :type s: List[str]\n  :rtype: None Do not return anything, modify s in-place instead.\n  \"\"\"\n  i, j = 0, len(s) - 1\n  while i < j:\n  s[i], s[j] = s[j], s[i]\n  i += 1\n  j -= 1",
        "public_test_path": "/id/public/reverse-string-019",
        "hidden_test_path": "/id/hidden/reverse-string-019",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 55
    },
    {
        "problem_id": "valid-anagram-020",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Valid Anagram",
        "description": "## Valid Anagram\n**Kiểm tra hai chuỗi có phải là anagram của nhau không.**\n- **Input:** hai chuỗi s và t (1 <= |s|,|t| <= 5*10^4)\n- **Output:** true nếu t là anagram của s, false nếu không\n- **Example:** s=\"anagram\", t=\"nagaram\"→true; s=\"rat\", t=\"car\"→false\n- **Constraints:** chỉ chứa chữ cái thường",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import collections\n \n \n class Solution(object):\n  def isAnagram(self, s, t):\n  \"\"\"\n  :type s: str\n  :type t: str\n  :rtype: bool\n  \"\"\"\n  if len(s) != len(t):\n  return False\n  count = collections.defaultdict(int)\n  for c in s:\n  count[c] += 1\n  for c in t:\n  count[c] -= 1\n  if count[c] < 0:\n  return False\n  return True",
        "public_test_path": "/id/public/valid-anagram-020",
        "hidden_test_path": "/id/hidden/valid-anagram-020",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 50
    },
    {
        "problem_id": "add-strings-021",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Add Strings",
        "description": "## Add Strings\n**Cộng hai số nguyên không âm được biểu diễn bằng chuỗi.**\n- **Input:** chuỗi num1 và num2 (1 <= |num1|,|num2| <= 10^4, không có số 0 đứng đầu trừ số \"0\")\n- **Output:** chuỗi biểu diễn tổng\n- **Example:** num1=\"11\", num2=\"123\"→\"134\"\n- **Constraints:** không dùng thư viện BigInteger",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution(object):\n  def addStrings(self, num1, num2):\n  \"\"\"\n  :type num1: str\n  :type num2: str\n  :rtype: str\n  \"\"\"\n  result = []\n  i, j, carry = len(num1) - 1, len(num2) - 1, 0\n \n  while i >= 0 or j >= 0 or carry:\n  if i >= 0:\n  carry += ord(num1[i]) - ord('0')\n  i -= 1\n  if j >= 0:\n  carry += ord(num2[j]) - ord('0')\n  j -= 1\n  result.append(str(carry % 10))\n  carry /= 10\n  result.reverse()\n \n  return \"\".join(result)",
        "public_test_path": "/id/public/add-strings-021",
        "hidden_test_path": "/id/hidden/add-strings-021",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 40
    },
    {
        "problem_id": "length-of-last-word-022",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Length of Last Word",
        "description": "## Length of Last Word\n**Tính độ dài của từ cuối cùng trong chuỗi.**\n- **Input:** chuỗi s (1 <= |s| <= 10^4) gồm chữ cái và khoảng trắng, ít nhất một từ\n- **Output:** độ dài từ cuối cùng\n- **Example:** \"Hello World\"→5, \"   fly me   to   the moon  \"→4\n- **Constraints:** độ dài tối đa 10^4",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution(object):\n  # @param s, a string\n  # @return an integer\n  def lengthOfLastWord(self, s):\n  length = 0\n  for i in reversed(s):\n  if i == ' ':\n  if length:\n  break\n  else:\n  length += 1\n  return length",
        "public_test_path": "/id/public/length-of-last-word-022",
        "hidden_test_path": "/id/hidden/length-of-last-word-022",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 19
    },
    {
        "problem_id": "first-unique-character-in-a-string-023",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "First Unique Character in a String",
        "description": "## First Unique Character in a String\n**Trả về chỉ số ký tự đầu tiên không lặp lại trong chuỗi.**\n- **Input:** chuỗi s (1 <= |s| <= 10^5)\n- **Output:** chỉ số (0-based) hoặc -1 nếu không tồn tại\n- **Example:** \"leetcode\"→0, \"loveleetcode\"→2\n- **Constraints:** chỉ chứa chữ cái thường",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(n)\n # Space: O(n)\n \n from collections import defaultdict\n \n class Solution(object):\n  def firstUniqChar(self, s):\n  \"\"\"\n  :type s: str\n  :rtype: int\n  \"\"\"\n  lookup = defaultdict(int)\n  candidtates = set()\n  for i, c in enumerate(s):\n  if lookup[c]:\n  candidtates.discard(lookup[c])\n  else:\n  lookup[c] = i+1\n  candidtates.add(i+1)\n \n  return min(candidtates)-1 if candidtates else -1",
        "public_test_path": "/id/public/first-unique-character-in-a-string-023",
        "hidden_test_path": "/id/hidden/first-unique-character-in-a-string-023",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "ransom-note-024",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Ransom Note",
        "description": "## Ransom Note\n**Xác định có thể tạo ransomNote từ magazine hay không.**\n- **Input:** ransomNote và magazine (1 <= |ransomNote|,|magazine| <= 10^5)\n- **Output:** true nếu có thể, false nếu không\n- **Example:** ransomNote=\"a\", magazine=\"b\"→false; ransomNote=\"aa\", magazine=\"aab\"→true\n- **Constraints:** chỉ chứa chữ cái thường",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution(object):\n  def canConstruct(self, ransomNote, magazine):\n  \"\"\"\n  :type ransomNote: str\n  :type magazine: str\n  :rtype: bool\n  \"\"\"\n  counts = [0] * 26\n  letters = 0\n \n  for c in ransomNote:\n  if counts[ord(c) - ord('a')] == 0:\n  letters += 1\n  counts[ord(c) - ord('a')] += 1\n \n  for c in magazine:\n  counts[ord(c) - ord('a')] -= 1\n  if counts[ord(c) - ord('a')] == 0:\n  letters -= 1\n  if letters == 0:\n  break\n \n  return letters == 0",
        "public_test_path": "/id/public/ransom-note-024",
        "hidden_test_path": "/id/hidden/ransom-note-024",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "group-anagrams-025",
        "topic": "Chương 1",
        "sub_topic": "Dictionary",
        "name": "Group Anagrams",
        "description": "## Group Anagrams\n**Nhóm các chuỗi là anagram với nhau.**\n- **Input:** mảng strs (1 <= |strs| <= 10^4, 0 <= |strs[i]| <= 100)\n- **Output:** danh sách nhóm anagram\n- **Example:** [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]→[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n- **Constraints:** tổng ký tự <= 10^5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(n * glogg), g is the max size of groups.\n # Space: O(n)\n \n import collections\n \n \n class Solution(object):\n  def groupAnagrams(self, strs):\n  \"\"\"\n  :type strs: List[str]\n  :rtype: List[List[str]]\n  \"\"\"\n  anagrams_map, result = collections.defaultdict(list), []\n  for s in strs:\n  sorted_str = (\"\").join(sorted(s))\n  anagrams_map[sorted_str].append(s)\n  for anagram in anagrams_map.values():\n  anagram.sort()\n  result.append(anagram)\n  return result",
        "public_test_path": "/id/public/group-anagrams-025",
        "hidden_test_path": "/id/hidden/group-anagrams-025",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "valid-anagram-026",
        "topic": "Chương 1",
        "sub_topic": "Dictionary",
        "name": "Valid Anagram",
        "description": "## Valid Anagram\n**Kiểm tra hai chuỗi có phải là anagram của nhau không.**\n- **Input:** hai chuỗi s và t (1 <= |s|,|t| <= 5*10^4)\n- **Output:** true nếu t là anagram của s, false nếu không\n- **Example:** s=\"anagram\", t=\"nagaram\"→true; s=\"rat\", t=\"car\"→false\n- **Constraints:** chỉ chứa chữ cái thường",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import collections\n \n \n class Solution(object):\n  def isAnagram(self, s, t):\n  \"\"\"\n  :type s: str\n  :type t: str\n  :rtype: bool\n  \"\"\"\n  if len(s) != len(t):\n  return False\n  count = collections.defaultdict(int)\n  for c in s:\n  count[c] += 1\n  for c in t:\n  count[c] -= 1\n  if count[c] < 0:\n  return False\n  return True",
        "public_test_path": "/id/public/valid-anagram-026",
        "hidden_test_path": "/id/hidden/valid-anagram-026",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 60
    },
    {
        "problem_id": "first-unique-character-in-a-string-027",
        "topic": "Chương 1",
        "sub_topic": "Dictionary",
        "name": "First Unique Character in a String",
        "description": "## First Unique Character in a String\n**Trả về chỉ số ký tự đầu tiên không lặp lại trong chuỗi.**\n- **Input:** chuỗi s (1 <= |s| <= 10^5)\n- **Output:** chỉ số (0-based) hoặc -1 nếu không tồn tại\n- **Example:** \"leetcode\"→0, \"loveleetcode\"→2\n- **Constraints:** chỉ chứa chữ cái thường",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(n)\n # Space: O(n)\n \n from collections import defaultdict\n \n class Solution(object):\n  def firstUniqChar(self, s):\n  \"\"\"\n  :type s: str\n  :rtype: int\n  \"\"\"\n  lookup = defaultdict(int)\n  candidtates = set()\n  for i, c in enumerate(s):\n  if lookup[c]:\n  candidtates.discard(lookup[c])\n  else:\n  lookup[c] = i+1\n  candidtates.add(i+1)\n \n  return min(candidtates)-1 if candidtates else -1",
        "public_test_path": "/id/public/first-unique-character-in-a-string-027",
        "hidden_test_path": "/id/hidden/first-unique-character-in-a-string-027",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "ransom-note-028",
        "topic": "Chương 1",
        "sub_topic": "Dictionary",
        "name": "Ransom Note",
        "description": "## Ransom Note\n**Xác định có thể tạo ransomNote từ magazine hay không.**\n- **Input:** ransomNote và magazine (1 <= |ransomNote|,|magazine| <= 10^5)\n- **Output:** true nếu có thể, false nếu không\n- **Example:** ransomNote=\"a\", magazine=\"b\"→false; ransomNote=\"aa\", magazine=\"aab\"→true\n- **Constraints:** chỉ chứa chữ cái thường",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution(object):\n  def canConstruct(self, ransomNote, magazine):\n  \"\"\"\n  :type ransomNote: str\n  :type magazine: str\n  :rtype: bool\n  \"\"\"\n  counts = [0] * 26\n  letters = 0\n \n  for c in ransomNote:\n  if counts[ord(c) - ord('a')] == 0:\n  letters += 1\n  counts[ord(c) - ord('a')] += 1\n \n  for c in magazine:\n  counts[ord(c) - ord('a')] -= 1\n  if counts[ord(c) - ord('a')] == 0:\n  letters -= 1\n  if letters == 0:\n  break\n \n  return letters == 0",
        "public_test_path": "/id/public/ransom-note-028",
        "hidden_test_path": "/id/hidden/ransom-note-028",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "contains-duplicate-ii-029",
        "topic": "Chương 1",
        "sub_topic": "Dictionary",
        "name": "Contains Duplicate II",
        "description": "## Contains Duplicate II\n**Kiểm tra có hai phần tử giống nhau trong khoảng cách không quá k.**\n- **Input:** mảng nums (1 <= n <= 10^5, -10^9 <= nums[i] <= 10^9), số k (0 <= k <= 10^5)\n- **Output:** true nếu tồn tại nums[i] = nums[j] với |i-j| <= k, false nếu không\n- **Example:** nums=[1,2,3,1], k=3→true; nums=[1,0,1,1], k=1→true; nums=[1,2,3,1,2,3], k=2→false\n- **Constraints:** O(n)",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(n)\n # Space: O(n)\n \n class Solution(object):\n  # @param {integer[]} nums\n  # @param {integer} k\n  # @return {boolean}\n  def containsNearbyDuplicate(self, nums, k):\n  lookup = {}\n  for i, num in enumerate(nums):\n  if num not in lookup:\n  lookup[num] = i\n  else:\n  # If the value occurs before, check the difference.\n  if i - lookup[num] <= k:\n  return True\n  # Update the index of the value.\n  lookup[num] = i\n  return False",
        "public_test_path": "/id/public/contains-duplicate-ii-029",
        "hidden_test_path": "/id/hidden/contains-duplicate-ii-029",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 50
    },
    {
        "problem_id": "climbing-stairs-030",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Climbing Stairs",
        "description": "## Climbing Stairs\n**Mỗi lần có thể leo 1 hoặc 2 bậc, tính số cách leo lên đỉnh n bậc thang.**\n- **Input:** số nguyên n (1 <= n <= 45)\n- **Output:** số cách leo\n- **Example:** n=2→2, n=3→3\n- **Constraints:** Fibonacci tính chất, O(n)",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import itertools\n \n \n class Solution(object):\n  def climbStairs(self, n):\n  \"\"\"\n  :type n: int\n  :rtype: int\n  \"\"\"\n  def matrix_expo(A, K):\n  result = [[int(i==j) for j in range(len(A))] \\\n  for i in range(len(A))]\n  while K:\n  if K % 2:\n  result = matrix_mult(result, A)\n  A = matrix_mult(A, A)\n  K /= 2\n  return result\n \n  def matrix_mult(A, B):\n  ZB = zip(*B)\n  return [[sum(a*b for a, b in itertools.izip(row, col)) \\\n  for col in ZB] for row in A]\n \n  T = [[1, 1],\n  [1, 0]]\n  return matrix_mult([[1, 0]], matrix_expo(T, n))[0][0] # [a0, a(-1)] * T^n",
        "public_test_path": "/id/public/climbing-stairs-030",
        "hidden_test_path": "/id/hidden/climbing-stairs-030",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 51
    },
    {
        "problem_id": "search-insert-position-031",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Search Insert Position",
        "description": "## Search Insert Position\n**Tìm vị trí cần chèn target trong mảng đã sắp xếp tăng dần.**\n- **Input:** mảng nums (1 <= n <= 10^4, -10^4 <= nums[i] <= 10^4, sắp xếp tăng, không trùng), target (−10^4 <= target <= 10^4)\n- **Output:** chỉ số cần chèn hoặc vị trí tồn tại\n- **Example:** [1,3,5,6], target=5→2; target=2→1\n- **Constraints:** O(log n)",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(logn)\n # Space: O(1)\n \n class Solution(object):\n  def searchInsert(self, nums, target):\n  \"\"\"\n  :type nums: List[int]\n  :type target: int\n  :rtype: int\n  \"\"\"\n  left, right = 0, len(nums) - 1\n  while left <= right:\n  mid = left + (right - left) / 2\n  if nums[mid] >= target:\n  right = mid - 1\n  else:\n  left = mid + 1\n \n  return left",
        "public_test_path": "/id/public/search-insert-position-031",
        "hidden_test_path": "/id/hidden/search-insert-position-031",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 17
    },
    {
        "problem_id": "sqrt(x)-032",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Sqrt(x)",
        "description": "## Sqrt(x)\n**Tính căn bậc hai nguyên của x, làm tròn xuống.**\n- **Input:** số nguyên x (0 <= x <= 2^31−1)\n- **Output:** căn bậc hai nguyên\n- **Example:** 4→2, 8→2\n- **Constraints:** O(log x)",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution {\n public:\n  int mySqrt(int x) {\n  if (x < 2) {\n  return x;\n  }\n  \n  int left = 1, right = x / 2;\n  while (left <= right) {\n  const auto mid = left + (right - left) / 2;\n  if (mid > x / mid) {\n  right = mid - 1;\n  } else {\n  left = mid + 1;\n  }\n  }\n \n  return left - 1;\n  }\n };",
        "public_test_path": "/id/public/sqrt(x)-032",
        "hidden_test_path": "/id/hidden/sqrt(x)-032",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 22
    },
    {
        "problem_id": "first-bad-version-033",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "First Bad Version",
        "description": "## First Bad Version\n**Có n phiên bản, từ một phiên bản nào đó trở đi thì lỗi. Tìm phiên bản lỗi đầu tiên bằng API isBadVersion.**\n- **Input:** n (1 <= n <= 2^31−1)\n- **Output:** chỉ số phiên bản lỗi đầu tiên\n- **Example:** n=5, bad=4→output=4\n- **Constraints:** O(log n) gọi API",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution(object):\n  def firstBadVersion(self, n):\n  \"\"\"\n  :type n: int\n  :rtype: int\n  \"\"\"\n  left, right = 1, n\n  while left <= right:\n  mid = left + (right - left) / 2\n  if isBadVersion(mid): # noqa\n  right = mid - 1\n  else:\n  left = mid + 1\n  return left",
        "public_test_path": "/id/public/first-bad-version-033",
        "hidden_test_path": "/id/hidden/first-bad-version-033",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "valid-perfect-square-034",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Valid Perfect Square",
        "description": "## Valid Perfect Square\n**Kiểm tra số nguyên dương num có phải là số chính phương hoàn hảo không.**\n- **Input:** num (1 <= num <= 2^31−1)\n- **Output:** true nếu là chính phương, false nếu không\n- **Example:** 16→true, 14→false\n- **Constraints:** không dùng sqrt()",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(logn)\n # Space: O(1)\n \n class Solution(object):\n  def isPerfectSquare(self, num):\n  \"\"\"\n  :type num: int\n  :rtype: bool\n  \"\"\"\n  left, right = 1, num\n  while left <= right:\n  mid = left + (right - left) // 2\n  if mid >= num / mid:\n  right = mid - 1\n  else:\n  left = mid + 1\n  return left == num / left and num % left == 0",
        "public_test_path": "/id/public/valid-perfect-square-034",
        "hidden_test_path": "/id/hidden/valid-perfect-square-034",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 32
    },
    {
        "problem_id": "reverse-linked-list-035",
        "topic": "Chương 1",
        "sub_topic": "Hàm",
        "name": "Reverse Linked List",
        "description": "## Reverse Linked List\n**Đảo ngược danh sách liên kết đơn.**\n- **Input:** head danh sách liên kết độ dài n (0 <= n <= 5000)\n- **Output:** head danh sách sau khi đảo ngược\n- **Example:** [1,2,3,4,5]→[5,4,3,2,1]\n- **Constraints:** O(n) time, O(1) space",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n  def reverseList(self, head: ListNode) -> ListNode:\n  if not head or not head.next:\n  return head\n  new_head = self.reverseList(head.next)\n  head.next.next = head\n  head.next = None\n  return new_head",
        "public_test_path": "/id/public/reverse-linked-list-035",
        "hidden_test_path": "/id/hidden/reverse-linked-list-035",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "merge-two-sorted-lists-036",
        "topic": "Chương 1",
        "sub_topic": "Hàm",
        "name": "Merge Two Sorted Lists",
        "description": "## Merge Two Sorted Lists\n**Gộp hai danh sách liên kết đã sắp xếp thành một danh sách đã sắp xếp.**\n- **Input:** head l1 và l2 (0 <= |l1|,|l2| <= 50, -100 <= Node.val <= 100)\n- **Output:** danh sách liên kết mới\n- **Example:** l1=[1,2,4], l2=[1,3,4]→[1,1,2,3,4,4]\n- **Constraints:** iterative/recursive",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(n)\n # Space: O(1)\n \n class ListNode(object):\n  def __init__(self, x):\n  self.val = x\n  self.next = None\n \n  def __repr__(self):\n  if self:\n  return \"{} -> {}\".format(self.val, self.next)\n \n \n class Solution(object):\n  def mergeTwoLists(self, l1, l2):\n  \"\"\"\n  :type l1: ListNode\n  :type l2: ListNode\n  :rtype: ListNode\n  \"\"\"\n  curr = dummy = ListNode(0)\n  while l1 and l2:\n  if l1.val < l2.val:\n  curr.next = l1\n  l1 = l1.next\n  else:\n  curr.next = l2\n  l2 = l2.next\n  curr = curr.next\n  curr.next = l1 or l2\n  return dummy.next",
        "public_test_path": "/id/public/merge-two-sorted-lists-036",
        "hidden_test_path": "/id/hidden/merge-two-sorted-lists-036",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 5
    },
    {
        "problem_id": "linked-list-cycle-037",
        "topic": "Chương 1",
        "sub_topic": "Hàm",
        "name": "Linked List Cycle",
        "description": "## Linked List Cycle\n**Kiểm tra danh sách liên kết có chu kỳ không.**\n- **Input:** head danh sách liên kết (0 <= n <= 10^4, -10^5 <= Node.val <= 10^5)\n- **Output:** true nếu có chu kỳ, false nếu không\n- **Example:** head=[3,2,0,-4], pos=1→true\n- **Constraints:** O(1) space",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(n)\n # Space: O(1)\n \n class ListNode(object):\n  def __init__(self, x):\n  self.val = x\n  self.next = None\n \n class Solution(object):\n  # @param head, a ListNode\n  # @return a boolean\n  def hasCycle(self, head):\n  fast, slow = head, head\n  while fast and fast.next:\n  fast, slow = fast.next.next, slow.next\n  if fast is slow:\n  return True\n  return False",
        "public_test_path": "/id/public/linked-list-cycle-037",
        "hidden_test_path": "/id/hidden/linked-list-cycle-037",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "intersection-of-two-linked-lists-038",
        "topic": "Chương 1",
        "sub_topic": "Hàm",
        "name": "Intersection of Two Linked Lists",
        "description": "## Intersection of Two Linked Lists\n**Tìm node giao nhau của 2 danh sách liên kết đơn.**\n- **Input:** headA, headB (0 <= |A|,|B| <= 3*10^4, Node.val <= 10^5)\n- **Output:** node giao hoặc null\n- **Example:** intersectVal=8→output=ListNode với val=8\n- **Constraints:** O(n+m)",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(m + n)\n # Space: O(1)\n \n class ListNode(object):\n  def __init__(self, x):\n  self.val = x\n  self.next = None\n \n class Solution(object):\n  # @param two ListNodes\n  # @return the intersected ListNode\n  def getIntersectionNode(self, headA, headB):\n  curA, curB = headA, headB\n  while curA != curB:\n  curA = curA.next if curA else headB\n  curB = curB.next if curB else headA\n  return curA",
        "public_test_path": "/id/public/intersection-of-two-linked-lists-038",
        "hidden_test_path": "/id/hidden/intersection-of-two-linked-lists-038",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "remove-linked-list-elements-039",
        "topic": "Chương 1",
        "sub_topic": "Hàm",
        "name": "Remove Linked List Elements",
        "description": "## Remove Linked List Elements\n**Xóa tất cả node có giá trị val khỏi danh sách liên kết.**\n- **Input:** head danh sách (0 <= n <= 10^4, -100 <= Node.val <= 100), giá trị val\n- **Output:** head danh sách sau khi xóa\n- **Example:** head=[1,2,6,3,4,5,6], val=6→[1,2,3,4,5]\n- **Constraints:** O(n)",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(n)\n # Space: O(1)\n \n class ListNode(object):\n  def __init__(self, x):\n  self.val = x\n  self.next = None\n \n \n class Solution(object):\n  # @param {ListNode} head\n  # @param {integer} val\n  # @return {ListNode}\n  def removeElements(self, head, val):\n  dummy = ListNode(float(\"-inf\"))\n  dummy.next = head\n  prev, curr = dummy, dummy.next\n \n  while curr:\n  if curr.val == val:\n  prev.next = curr.next\n  else:\n  prev = curr\n \n  curr = curr.next\n \n  return dummy.next",
        "public_test_path": "/id/public/remove-linked-list-elements-039",
        "hidden_test_path": "/id/hidden/remove-linked-list-elements-039",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 9
    },
    {
        "problem_id": "add-binary-040",
        "topic": "Chương 1",
        "sub_topic": "File và Ngoại lệ",
        "name": "Add Binary",
        "description": "## Add Binary\n**Cộng hai số nhị phân biểu diễn bằng chuỗi.**\n- **Input:** chuỗi a và b (1 <= |a|,|b| <= 10^4), chỉ chứa '0' hoặc '1'\n- **Output:** chuỗi nhị phân kết quả\n- **Example:** a=\"11\", b=\"1\"→\"100\"; a=\"1010\", b=\"1011\"→\"10101\"\n- **Constraints:** không dùng built-in chuyển đổi trực tiếp",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution(object):\n  # @param a, a string\n  # @param b, a string\n  # @return a string\n  def addBinary(self, a, b):\n  result, carry, val = \"\", 0, 0\n  for i in range(max(len(a), len(b))):\n  val = carry\n  if i < len(a):\n  val += int(a[-(i + 1)])\n  if i < len(b):\n  val += int(b[-(i + 1)])\n  carry, val = divmod(val, 2)\n  result += str(val)\n  if carry:\n  result += str(carry)\n  return result[::-1]",
        "public_test_path": "/id/public/add-binary-040",
        "hidden_test_path": "/id/hidden/add-binary-040",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "implement-strstr-041",
        "topic": "Chương 1",
        "sub_topic": "File và Ngoại lệ",
        "name": "Implement strStr",
        "description": "## Find the Index of the First Occurrence in a String\n**Tìm vị trí xuất hiện đầu tiên của chuỗi needle trong haystack.**\n- **Input:** haystack và needle (1 <= |haystack|,|needle| <= 10^4)\n- **Output:** chỉ số bắt đầu hoặc -1\n- **Example:** haystack=\"sadbutsad\", needle=\"sad\"→0\n- **Constraints:** O(|haystack|*|needle|)",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n  def strStr(self, haystack: str, needle: str) -> int:\n  return haystack.find(needle)",
        "public_test_path": "/id/public/implement-strstr-041",
        "hidden_test_path": "/id/hidden/implement-strstr-041",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "valid-sudoku-042",
        "topic": "Chương 1",
        "sub_topic": "File và Ngoại lệ",
        "name": "Valid Sudoku",
        "description": "## Valid Sudoku\n**Kiểm tra bảng Sudoku 9x9 có hợp lệ không (chỉ kiểm tra, không cần giải).**\n- **Input:** board 9x9, mỗi phần tử là '.' hoặc '1'-'9'\n- **Output:** true nếu hợp lệ, false nếu không\n- **Example:** bảng hợp lệ với mỗi hàng/cột/3x3 không trùng số\n- **Constraints:** chỉ kiểm tra 9x9, không cần hoàn chỉnh",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution(object):\n  def isValidSudoku(self, board):\n  \"\"\"\n  :type board: List[List[str]]\n  :rtype: bool\n  \"\"\"\n  # kiểm tra từng hàng và cột\n  for i in range(9):\n  if not self.isValidList([board[i][j] for j in range(9)]) or \\\n  not self.isValidList([board[j][i] for j in range(9)]):\n  return False\n \n  # kiểm tra từng ô vuông 3x3\n  for i in range(3):\n  for j in range(3):\n  if not self.isValidList([board[m][n] \n  for m in range(3 * i, 3 * i + 3) \n  for n in range(3 * j, 3 * j + 3)]):\n  return False\n \n  return True\n \n  def isValidList(self, lst):\n  \"\"\"Kiểm tra 1 hàng/cột/ô vuông có hợp lệ không\"\"\"\n  seen = set()\n  for val in lst:\n  if val != '.':\n  if val in seen: # đã có số này rồi → không hợp lệ\n  return False\n  seen.add(val)\n  return True",
        "public_test_path": "/id/public/valid-sudoku-042",
        "hidden_test_path": "/id/hidden/valid-sudoku-042",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "fizz-buzz-043",
        "topic": "Chương 1",
        "sub_topic": "File và Ngoại lệ",
        "name": "Fizz Buzz",
        "description": "## Fizz Buzz\n**Sinh danh sách từ 1 đến n, thay số chia hết cho 3 bằng \"Fizz\", chia hết cho 5 bằng \"Buzz\", chia hết cho cả 3 và 5 bằng \"FizzBuzz\".**\n- **Input:** số nguyên n (1 <= n <= 10^4)\n- **Output:** danh sách chuỗi\n- **Example:** n=3→[\"1\",\"2\",\"Fizz\"]\n- **Constraints:** O(n)",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution(object):\n  def fizzBuzz(self, n):\n  \"\"\"\n  :type n: int\n  :rtype: List[str]\n  \"\"\"\n  result = []\n \n  for i in range(1, n+1):\n  if i % 15 == 0:\n  result.append(\"FizzBuzz\")\n  elif i % 5 == 0:\n  result.append(\"Buzz\")\n  elif i % 3 == 0:\n  result.append(\"Fizz\")\n  else:\n  result.append(str(i))\n \n  return result",
        "public_test_path": "/id/public/fizz-buzz-043",
        "hidden_test_path": "/id/hidden/fizz-buzz-043",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "happy-number-044",
        "topic": "Chương 1",
        "sub_topic": "File và Ngoại lệ",
        "name": "Happy Number",
        "description": "## Happy Number\n**Kiểm tra số có phải là happy number không (lặp bình phương chữ số cho đến khi ra 1 hoặc lặp vô hạn).**\n- **Input:** số nguyên n (1 <= n <= 2^31−1)\n- **Output:** true nếu happy, false nếu không\n- **Example:** 19→true, 2→false\n- **Constraints:** sử dụng phát hiện chu kỳ",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: O(k), where k is the steps to be happy number\n # Space: O(k)\n \n class Solution(object):\n  # @param {integer} n\n  # @return {boolean}\n  def isHappy(self, n):\n  lookup = {}\n  while n != 1 and n not in lookup:\n  lookup[n] = True\n  n = self.nextNumber(n)\n  return n == 1\n \n  def nextNumber(self, n):\n  new = 0\n  for char in str(n):\n  new += int(char)**2\n  return new",
        "public_test_path": "/id/public/happy-number-044",
        "hidden_test_path": "/id/hidden/happy-number-044",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 50
    },
    {
        "problem_id": "min-stack-045",
        "topic": "Chương 1",
        "sub_topic": "OOP",
        "name": "Min Stack",
        "description": "## Min Stack\n**Cài đặt stack hỗ trợ push, pop, top và trả về phần tử nhỏ nhất trong O(1).**\n- **Input:** dãy thao tác (1 <= số thao tác <= 3*10^4)\n- **Output:** theo thao tác\n- **Example:** [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]→[null,null,null,null,-3,null,0,-2]\n- **Constraints:** O(1) cho getMin",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class MinStack(object):\n  def __init__(self):\n  self.min = None\n  self.stack = []\n \n  # @param x, an integer\n  # @return an integer\n  def push(self, x):\n  if not self.stack:\n  self.stack.append(0)\n  self.min = x\n  else:\n  self.stack.append(x - self.min)\n  if x < self.min:\n  self.min = x\n \n  # @return nothing\n  def pop(self):\n  x = self.stack.pop()\n  if x < 0:\n  self.min = self.min - x\n \n  # @return an integer\n  def top(self):\n  x = self.stack[-1]\n  if x > 0:\n  return x + self.min\n  else:\n  return self.min\n \n  # @return an integer\n  def getMin(self):\n  return self.min",
        "public_test_path": "/id/public/min-stack-045",
        "hidden_test_path": "/id/hidden/min-stack-045",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "implement-queue-using-stacks-046",
        "topic": "Chương 1",
        "sub_topic": "OOP",
        "name": "Implement Queue using Stacks",
        "description": "## Implement Queue using Stacks\n**Cài đặt hàng đợi bằng 2 stack.**\n- **Input:** dãy thao tác (1 <= số thao tác <= 100)\n- **Output:** theo thao tác\n- **Example:** [\"MyQueue\",\"push\",\"push\",\"peek\",\"pop\",\"empty\"]→[null,null,null,1,1,false]\n- **Constraints:** chỉ dùng stack",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class MyQueue(object):\n \n  def __init__(self):\n  self.A, self.B = [], []\n \n  def push(self, x):\n  \"\"\"\n  :type x: int\n  :rtype: None\n  \"\"\"\n  self.A.append(x)\n \n  def pop(self):\n  \"\"\"\n  :rtype: int\n  \"\"\"\n  self.peek()\n  return self.B.pop()\n \n  def peek(self):\n  \"\"\"\n  :rtype: int\n  \"\"\"\n  if not self.B:\n  while self.A:\n  self.B.append(self.A.pop())\n  return self.B[-1]\n \n  def empty(self):\n  \"\"\"\n  :rtype: bool\n  \"\"\"\n  return not self.A and not self.B",
        "public_test_path": "/id/public/implement-queue-using-stacks-046",
        "hidden_test_path": "/id/hidden/implement-queue-using-stacks-046",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "implement-stack-using-queues-047",
        "topic": "Chương 1",
        "sub_topic": "OOP",
        "name": "Implement Stack using Queues",
        "description": "## Implement Stack using Queues\n**Cài đặt stack bằng 1 hoặc 2 queue.**\n- **Input:** dãy thao tác (1 <= số thao tác <= 100)\n- **Output:** theo thao tác\n- **Example:** [\"MyStack\",\"push\",\"push\",\"top\",\"pop\",\"empty\"]→[null,null,null,2,2,false]\n- **Constraints:** chỉ dùng queue",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import deque\n \n class MyStack:\n  def __init__(self):\n  self.q1 = deque()\n  self.q2 = deque()\n \n  def push(self, x: int) -> None:\n  self.q1.append(x)\n \n  def pop(self) -> int:\n  # chuyển n-1 phần tử sang q2\n  while len(self.q1) > 1:\n  self.q2.append(self.q1.popleft())\n  res = self.q1.popleft()\n  # hoán đổi q1, q2\n  self.q1, self.q2 = self.q2, self.q1\n  return res\n \n  def top(self) -> int:\n  return self.q1[-1]\n \n  def empty(self) -> bool:\n  return not self.q1",
        "public_test_path": "/id/public/implement-stack-using-queues-047",
        "hidden_test_path": "/id/hidden/implement-stack-using-queues-047",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "range-sum-query---immutable-048",
        "topic": "Chương 1",
        "sub_topic": "OOP",
        "name": "Range Sum Query - Immutable",
        "description": "## Range Sum Query – Immutable\n**Thiết kế cấu trúc dữ liệu tính tổng dãy con.**\n- **Input:** mảng nums (1 <= n <= 10^4, -10^5 <= nums[i] <= 10^5), nhiều truy vấn sumRange(i,j)\n- **Output:** tổng nums[i..j]\n- **Example:** nums=[-2,0,3,-5,2,-1], sumRange(0,2)→1, sumRange(2,5)→-1, sumRange(0,5)→-3\n- **Constraints:** nhiều truy vấn, tối ưu bằng prefix sum",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "# Time: ctor: O(n),\n # lookup: O(1)\n # Space: O(n)\n \n class NumArray(object):\n  def __init__(self, nums):\n  \"\"\"\n  initialize your data structure here.\n  :type nums: List[int]\n  \"\"\"\n  self.accu = [0]\n  for num in nums:\n  self.accu.append(self.accu[-1] + num),\n \n  def sumRange(self, i, j):\n  \"\"\"\n  sum of elements nums[i..j], inclusive.\n  :type i: int\n  :type j: int\n  :rtype: int\n  \"\"\"\n  return self.accu[j + 1] - self.accu[i]",
        "public_test_path": "/id/public/range-sum-query---immutable-048",
        "hidden_test_path": "/id/hidden/range-sum-query---immutable-048",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "palindrome-linked-list-000",
        "topic": "Chương 1",
        "sub_topic": "Biến & Kiểu dữ liệu",
        "name": "Palindrome Linked List",
        "description": "### Bài toán\n\nXác định xem một linked list có palindrome hay không.\n\n- **Input**: head của singly linked list\n- **Output**: true nếu palindrome, false nếu không\n- **Ví dụ**: 1→2→2→1 → true\n- **Ràng buộc**: số node ≤ 10^5",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def isPalindrome(head):\n    vals = []\n    while head:\n        vals.append(head.val)\n        head = head.next\n    return vals == vals[::-1]",
        "public_test_path": "/id/public/palindrome-linked-list-000",
        "hidden_test_path": "/id/hidden/palindrome-linked-list-000",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 2
    },
    {
        "problem_id": "a-number-after-a-double-reversal-001",
        "topic": "Chương 1",
        "sub_topic": "Biến & Kiểu dữ liệu",
        "name": "A Number After a Double Reversal",
        "description": "### Bài toán\n\nKiểm tra xem số nguyên sau khi đảo ngược 2 lần có giữ nguyên giá trị không.\n\n- **Input**: số nguyên num\n- **Output**: true nếu giữ nguyên\n- **Ví dụ**: 526 → true, 120 → false\n- **Ràng buộc**: 0 <= num <= 10^6",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def isSameAfterReversals(num):\n    if num == 0: return True\n    if num % 10 == 0: return False\n    return True",
        "public_test_path": "/id/public/a-number-after-a-double-reversal-001",
        "hidden_test_path": "/id/hidden/a-number-after-a-double-reversal-001",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 22
    },
    {
        "problem_id": "next-special-palindrome-number-002",
        "topic": "Chương 1",
        "sub_topic": "Biến & Kiểu dữ liệu",
        "name": "Next Special Palindrome Number",
        "description": "### Bài toán\n\nTìm số palindrome đặc biệt tiếp theo sau số nguyên n.\n\n- **Input**: số nguyên n\n- **Output**: số palindrome tiếp theo\n- **Ví dụ**: 123 → 131\n- **Ràng buộc**: 1 <= n <= 10^6",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def nextPalindrome(n):\n    while True:\n        n += 1\n        if str(n) == str(n)[::-1]:\n            return n",
        "public_test_path": "/id/public/next-special-palindrome-number-002",
        "hidden_test_path": "/id/hidden/next-special-palindrome-number-002",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 30
    },
    {
        "problem_id": "strictly-palindromic-number-003",
        "topic": "Chương 1",
        "sub_topic": "Biến & Kiểu dữ liệu",
        "name": "Strictly Palindromic Number",
        "description": "### Bài toán\n\nKiểm tra xem một số có phải strictly palindromic trong tất cả hệ cơ số từ 2 đến n-2 không.\n\n- **Input**: số nguyên n\n- **Output**: true/false\n- **Ràng buộc**: 4 <= n <= 10^5",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def isStrictlyPalindromic(n):\n    return False  # theo Äá»nh nghÄ©a, má»i sá» > 4 khÃ´ng thá»a",
        "public_test_path": "/id/public/strictly-palindromic-number-003",
        "hidden_test_path": "/id/hidden/strictly-palindromic-number-003",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 19
    },
    {
        "problem_id": "largest-palindromic-number-004",
        "topic": "Chương 1",
        "sub_topic": "Biến & Kiểu dữ liệu",
        "name": "Largest Palindromic Number",
        "description": "### Bài toán\n\nTìm số palindrome lớn nhất tạo được từ các chữ số của một số.\n\n- **Input**: string num\n- **Output**: số palindrome lớn nhất\n- **Ví dụ**: '39878' → '9889'\n- **Ràng buộc**: 1 <= num",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import Counter\n def largestPalindrome(num):\n    count = Counter(num)\n    half = ''\n    mid = ''\n    for c in sorted(count.keys(), reverse=True):\n        if count[c] % 2 == 1 and not mid:\n            mid = c\n        half += c * (count[c] // 2)\n    if not half and mid:\n        return mid\n    return half.lstrip('0') + mid + half[::-1]",
        "public_test_path": "/id/public/largest-palindromic-number-004",
        "hidden_test_path": "/id/hidden/largest-palindromic-number-004",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 18
    },
    {
        "problem_id": "reverse-bits-005",
        "topic": "Chương 1",
        "sub_topic": "Biến & Kiểu dữ liệu",
        "name": "Reverse Bits",
        "description": "### Bài toán\n\nĐảo ngược các bit của số nguyên 32-bit.\n\n- **Input**: số nguyên n\n- **Output**: số nguyên với bit đảo ngược\n- **Ví dụ**: 43261596 → 964176192\n- **Ràng buộc**: n là 32-bit unsigned integer",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def reverseBits(n):\n    res = 0\n    for i in range(32):\n        res = (res << 1) | (n & 1)\n        n >>= 1\n    return res",
        "public_test_path": "/id/public/reverse-bits-005",
        "hidden_test_path": "/id/hidden/reverse-bits-005",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 19
    },
    {
        "problem_id": "counting-bits-006",
        "topic": "Chương 1",
        "sub_topic": "Biến & Kiểu dữ liệu",
        "name": "Counting Bits",
        "description": "### Bài toán\n\nĐếm số lượng bit 1 trong từng số từ 0 đến n.\n\n- **Input**: n\n- **Output**: mảng counts\n- **Ví dụ**: 2 → [0,1,1]\n- **Ràng buộc**: 0 <= n <= 10^5",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def countBits(n):\n    res = [0] * (n + 1)\n    for i in range(1, n+1):\n        res[i] = res[i >> 1] + (i & 1)\n    return res",
        "public_test_path": "/id/public/counting-bits-006",
        "hidden_test_path": "/id/hidden/counting-bits-006",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 18
    },
    {
        "problem_id": "number-of-digit-one-007",
        "topic": "Chương 1",
        "sub_topic": "Biến & Kiểu dữ liệu",
        "name": "Number of Digit One",
        "description": "### Bài toán\n\nĐếm số chữ số '1' xuất hiện từ 1 đến n.\n\n- **Input**: n\n- **Output**: số lượng chữ số 1\n- **Ví dụ**: 13 → 6\n- **Ràng buộc**: 1 <= n <= 2*10^9",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def countDigitOne(n):\n    count = 0\n    i = 1\n    while i <= n:\n        divider = i * 10\n        count += (n // divider) * i + min(max(n % divider - i + 1, 0), i)\n        i *= 10\n    return count",
        "public_test_path": "/id/public/number-of-digit-one-007",
        "hidden_test_path": "/id/hidden/number-of-digit-one-007",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 25
    },
    {
        "problem_id": "prime-number-of-set-bits-in-binary-representation-008",
        "topic": "Chương 1",
        "sub_topic": "Biến & Kiểu dữ liệu",
        "name": "Prime Number of Set Bits in Binary Representation",
        "description": "### Bài toán\n\nĐếm số số từ l đến r có số bit 1 là số nguyên tố.\n\n- **Input**: l, r\n- **Output**: số lượng\n- **Ví dụ**: l=6, r=10 → 4\n- **Ràng buộc**: 1 <= l <= r <= 10^6",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def countPrimeSetBits(L, R):\n    def isPrime(x):\n        if x < 2: return False\n        for i in range(2, int(x**0.5)+1):\n            if x % i == 0: return False\n        return True\n    return sum(isPrime(bin(x).count('1')) for x in range(L, R+1))",
        "public_test_path": "/id/public/prime-number-of-set-bits-in-binary-representation-008",
        "hidden_test_path": "/id/hidden/prime-number-of-set-bits-in-binary-representation-008",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "add-digits-009",
        "topic": "Chương 1",
        "sub_topic": "Biến & Kiểu dữ liệu",
        "name": "Add Digits",
        "description": "### Bài toán\n\nGiảm số nguyên thành một chữ số bằng cách cộng các chữ số liên tục.\n\n- **Input**: num\n- **Output**: số còn lại\n- **Ví dụ**: 38 → 2\n- **Ràng buộc**: 0 <= num <= 2^31 -1",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def addDigits(num):\n    if num == 0: return 0\n    return 1 + (num - 1) % 9",
        "public_test_path": "/id/public/add-digits-009",
        "hidden_test_path": "/id/hidden/add-digits-009",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 18
    },
    {
        "problem_id": "remove-duplicates-from-sorted-list-010",
        "topic": "Chương 1",
        "sub_topic": "Mảng (List)",
        "name": "Remove Duplicates from Sorted List",
        "description": "### Bài toán\n\nXóa các node trùng nhau trong linked list đã sắp xếp.\n\n- **Input**: head của linked list\n- **Output**: head mới\n- **Ví dụ**: 1→1→2 → 1→2\n- **Ràng buộc**: số node ≤ 10^4",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def deleteDuplicates(head):\n    curr = head\n    while curr and curr.next:\n        if curr.next.val == curr.val:\n            curr.next = curr.next.next\n        else:\n            curr = curr.next\n    return head",
        "public_test_path": "/id/public/remove-duplicates-from-sorted-list-010",
        "hidden_test_path": "/id/hidden/remove-duplicates-from-sorted-list-010",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "remove-duplicates-from-sorted-list-ii-011",
        "topic": "Chương 1",
        "sub_topic": "Mảng (List)",
        "name": "Remove Duplicates from Sorted List II",
        "description": "### Bài toán\n\nXóa tất cả node trùng nhau, giữ lại các node duy nhất.\n\n- **Input**: head\n- **Output**: head mới\n- **Ví dụ**: 1→2→3→3→4 → 1→2→4\n- **Ràng buộc**: số node ≤ 10^4",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def deleteDuplicatesII(head):\n    dummy = ListNode(0, head)\n    prev = dummy\n    while head:\n        if head.next and head.val == head.next.val:\n            while head.next and head.val == head.next.val:\n                head = head.next\n            prev.next = head.next\n        else:\n            prev = prev.next\n        head = head.next\n    return dummy.next",
        "public_test_path": "/id/public/remove-duplicates-from-sorted-list-ii-011",
        "hidden_test_path": "/id/hidden/remove-duplicates-from-sorted-list-ii-011",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "remove-one-element-to-make-the-array-strictly-increasing-012",
        "topic": "Chương 1",
        "sub_topic": "Mảng (List)",
        "name": "Remove One Element to Make the Array Strictly Increasing",
        "description": "### Bài toán\n\nXóa tối đa một phần tử để mảng tăng dần.\n\n- **Input**: nums\n- **Output**: true/false\n- **Ví dụ**: [1,2,10,5,7] → true\n- **Ràng buộc**: 1 <= nums",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def canBeIncreasing(nums):\n    removed = 0\n    prev = float('-inf')\n    for i in range(len(nums)):\n        if nums[i] <= prev:\n            removed += 1\n            if removed > 1:\n                return False\n            if i == 1 or nums[i] > nums[i-2]:\n                prev = nums[i]\n        else:\n            prev = nums[i]\n    return True",
        "public_test_path": "/id/public/remove-one-element-to-make-the-array-strictly-increasing-012",
        "hidden_test_path": "/id/hidden/remove-one-element-to-make-the-array-strictly-increasing-012",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 18
    },
    {
        "problem_id": "find-all-duplicates-in-an-array-013",
        "topic": "Chương 1",
        "sub_topic": "Mảng (List)",
        "name": "Find All Duplicates in an Array",
        "description": "### Bài toán\n\nTìm tất cả các số xuất hiện 2 lần.\n\n- **Input**: nums\n- **Output**: mảng các số\n- **Ví dụ**: [4,3,2,7,8,2,3,1] → [2,3]\n- **Ràng buộc**: 1 <= nums[i] <= n",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def findDuplicates(nums):\n    res = []\n    for num in nums:\n        if nums[abs(num)-1] < 0:\n            res.append(abs(num))\n        else:\n            nums[abs(num)-1] *= -1\n    return res",
        "public_test_path": "/id/public/find-all-duplicates-in-an-array-013",
        "hidden_test_path": "/id/hidden/find-all-duplicates-in-an-array-013",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 9
    },
    {
        "problem_id": "find-minimum-cost-to-remove-array-elements-014",
        "topic": "Chương 1",
        "sub_topic": "Mảng (List)",
        "name": "Find Minimum Cost to Remove Array Elements",
        "description": "### Bài toán\n\nTìm chi phí nhỏ nhất để xóa tất cả phần tử mảng.\n\n- **Input**: arr\n- **Output**: chi phí nhỏ nhất\n- **Ràng buộc**: 1 <= arr",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def minCost(nums):\n    n = len(nums)\n    nums.sort(reverse=True)\n    cost = 0\n    for i, num in enumerate(nums):\n        cost += (i+1) * num\n    return cost",
        "public_test_path": "/id/public/find-minimum-cost-to-remove-array-elements-014",
        "hidden_test_path": "/id/hidden/find-minimum-cost-to-remove-array-elements-014",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "find-the-duplicate-number-015",
        "topic": "Chương 1",
        "sub_topic": "Mảng (List)",
        "name": "Find the Duplicate Number",
        "description": "### Bài toán\n\nTìm số xuất hiện hơn 1 lần trong mảng 1..n.\n\n- **Input**: nums\n- **Output**: số bị lặp\n- **Ví dụ**: [1,3,4,2,2] → 2\n- **Ràng buộc**: nums",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def findDuplicate(nums):\n    slow = fast = nums[0]\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n    slow2 = nums[0]\n    while slow != slow2:\n        slow = nums[slow]\n        slow2 = nums[slow2]\n    return slow",
        "public_test_path": "/id/public/find-the-duplicate-number-015",
        "hidden_test_path": "/id/hidden/find-the-duplicate-number-015",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 50
    },
    {
        "problem_id": "remove-k-digits-016",
        "topic": "Chương 1",
        "sub_topic": "Mảng (List)",
        "name": "Remove K Digits",
        "description": "### Bài toán\n\nXóa k chữ số để có số nhỏ nhất.\n\n- **Input**: num, k\n- **Output**: string số nhỏ nhất\n- **Ví dụ**: '1432219', k=3 → '1219'\n- **Ràng buộc**: 1 <= num",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def removeKdigits(num, k):\n    stack = []\n    for digit in num:\n        while k and stack and stack[-1] > digit:\n            stack.pop()\n            k -= 1\n        stack.append(digit)\n    stack = stack[:-k] if k else stack\n    return ''.join(stack).lstrip('0') or '0'",
        "public_test_path": "/id/public/remove-k-digits-016",
        "hidden_test_path": "/id/hidden/remove-k-digits-016",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 30
    },
    {
        "problem_id": "sum-of-two-integers-017",
        "topic": "Chương 1",
        "sub_topic": "Mảng (List)",
        "name": "Sum of Two Integers",
        "description": "### Bài toán\n\nCộng hai số nguyên mà không dùng toán tử + hoặc -.\n\n- **Input**: a, b\n- **Output**: a+b\n- **Ràng buộc**: -1000 <= a, b <= 1000",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def getSum(a, b):\n    mask = 0xFFFFFFFF\n    while b != 0:\n        a, b = (a ^ b) & mask, ((a & b) << 1) & mask\n    return a if a <= 0x7FFFFFFF else ~(a ^ mask)",
        "public_test_path": "/id/public/sum-of-two-integers-017",
        "hidden_test_path": "/id/hidden/sum-of-two-integers-017",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "reverse-subarray-to-maximize-array-value-018",
        "topic": "Chương 1",
        "sub_topic": "Mảng (List)",
        "name": "Reverse Subarray To Maximize Array Value",
        "description": "### Bài toán\n\nĐảo 1 subarray để tối đa hóa giá trị mảng.\n\n- **Input**: nums\n- **Output**: giá trị tối đa\n- **Ràng buộc**: 1 <= nums",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def maxValueAfterReverse(nums):\n    res = sum(abs(nums[i] - nums[i-1]) for i in range(1, len(nums)))\n    min_delta = 0\n    for i in range(1, len(nums)):\n        min_delta = min(min_delta, max(nums[i], nums[i-1]) - min(nums[i], nums[i-1]))\n    return res + abs(min(nums[0], nums[-1]) - max(nums[0], nums[-1])) - min_delta",
        "public_test_path": "/id/public/reverse-subarray-to-maximize-array-value-018",
        "hidden_test_path": "/id/hidden/reverse-subarray-to-maximize-array-value-018",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "two-sum-iii---data-structure-design-019",
        "topic": "Chương 1",
        "sub_topic": "Mảng (List)",
        "name": "Two Sum III - Data structure design",
        "description": "### Bài toán\n\nThiết kế structure để thêm số và tìm sum = target.\n\n- **Input**: add/ find\n- **Output**: true/false cho find\n- **Ràng buộc**: số lượng thao tác <= 10^4",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class TwoSum:\n    def __init__(self):\n        self.nums = {}\n    def add(self, number):\n        self.nums[number] = self.nums.get(number, 0) + 1\n    def find(self, value):\n        for num in self.nums:\n            if value - num in self.nums and (value - num != num or self.nums[num] > 1):\n                return True\n        return False",
        "public_test_path": "/id/public/two-sum-iii---data-structure-design-019",
        "hidden_test_path": "/id/hidden/two-sum-iii---data-structure-design-019",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "find-palindrome-with-fixed-length-020",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi (String)",
        "name": "Find Palindrome With Fixed Length",
        "description": "### Bài toán\n\nTìm các palindrome có độ dài cố định.\n\n- **Input**: string, k\n- **Output**: mảng các palindrome\n- **Ràng buộc**: 1 <= string",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def findPalindromeFixedLength(s, k):\n    res = []\n    for i in range(len(s) - k + 1):\n        sub = s[i:i+k]\n        if sub == sub[::-1]:\n            res.append(sub)\n    return res",
        "public_test_path": "/id/public/find-palindrome-with-fixed-length-020",
        "hidden_test_path": "/id/hidden/find-palindrome-with-fixed-length-020",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 19
    },
    {
        "problem_id": "count-binary-palindromic-numbers-021",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi (String)",
        "name": "Count Binary Palindromic Numbers",
        "description": "### Bài toán\n\nĐếm số số nhị phân palindrome trong 1..n.\n\n- **Input**: n\n- **Output**: count\n- **Ràng buộc**: 1 <= n <= 10^5",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def countBinaryPalindromes(n):\n    count = 0\n    for i in range(1, n+1):\n        b = bin(i)[2:]\n        if b == b[::-1]:\n            count += 1\n    return count",
        "public_test_path": "/id/public/count-binary-palindromic-numbers-021",
        "hidden_test_path": "/id/hidden/count-binary-palindromic-numbers-021",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 21
    },
    {
        "problem_id": "reverse-words-in-a-string-022",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi (String)",
        "name": "Reverse Words in a String",
        "description": "### Bài toán\n\nĐảo ngược thứ tự từ trong chuỗi.\n\n- **Input**: s\n- **Output**: reversed string\n- **Ví dụ**: 'the sky is blue' → 'blue is sky the'\n- **Ràng buộc**: 1 <= s",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def reverseWords(s):\n    return ' '.join(s.split()[::-1])",
        "public_test_path": "/id/public/reverse-words-in-a-string-022",
        "hidden_test_path": "/id/hidden/reverse-words-in-a-string-022",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "remove-duplicate-letters-023",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi (String)",
        "name": "Remove Duplicate Letters",
        "description": "### Bài toán\n\nXóa các chữ cái trùng để có chuỗi nhỏ nhất.\n\n- **Input**: s\n- **Output**: string\n- **Ràng buộc**: 1 <= s",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def removeDuplicateLetters(s):\n    stack = []\n    seen = set()\n    last_occ = {c:i for i,c in enumerate(s)}\n    for i,c in enumerate(s):\n        if c not in seen:\n            while stack and c < stack[-1] and i < last_occ[stack[-1]]:\n                seen.discard(stack.pop())\n            stack.append(c)\n            seen.add(c)\n    return ''.join(stack)",
        "public_test_path": "/id/public/remove-duplicate-letters-023",
        "hidden_test_path": "/id/hidden/remove-duplicate-letters-023",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "add-strings-024",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi (String)",
        "name": "Add Strings",
        "description": "### Bài toán\n\nCộng 2 chuỗi số.\n\n- **Input**: num1, num2\n- **Output**: sum string\n- **Ví dụ**: '11','123' → '134'\n- **Ràng buộc**: 1 <= num1",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def addStrings(num1, num2):\n    res = []\n    i,j,carry = len(num1)-1,len(num2)-1,0\n    while i>=0 or j>=0 or carry:\n        x = int(num1[i]) if i>=0 else 0\n        y = int(num2[j]) if j>=0 else 0\n        carry,res = divmod(x+y+carry,10), [str((x+y+carry)%10)]+res\n        i-=1;j-=1\n    return ''.join(res)",
        "public_test_path": "/id/public/add-strings-024",
        "hidden_test_path": "/id/hidden/add-strings-024",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "length-of-last-word-025",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi (String)",
        "name": "Length of Last Word",
        "description": "### Bài toán\n\nTìm độ dài từ cuối cùng trong string.\n\n- **Input**: s\n- **Output**: độ dài\n- **Ví dụ**: 'Hello World' → 5\n- **Ràng buộc**: 1 <= s",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def lengthOfLastWord(s):\n    return len(s.rstrip().split(' ')[-1])",
        "public_test_path": "/id/public/length-of-last-word-025",
        "hidden_test_path": "/id/hidden/length-of-last-word-025",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "first-unique-character-in-a-string-026",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi (String)",
        "name": "First Unique Character in a String",
        "description": "### Bài toán\n\nTìm vị trí đầu tiên của ký tự duy nhất.\n\n- **Input**: s\n- **Output**: index hoặc -1\n- **Ví dụ**: 'leetcode' → 0\n- **Ràng buộc**: 1 <= s",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def firstUniqChar(s):\n    from collections import Counter\n    count = Counter(s)\n    for i,c in enumerate(s):\n        if count[c]==1:\n            return i\n    return -1",
        "public_test_path": "/id/public/first-unique-character-in-a-string-026",
        "hidden_test_path": "/id/hidden/first-unique-character-in-a-string-026",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "ransom-note-027",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi (String)",
        "name": "Ransom Note",
        "description": "### Bài toán\n\nKiểm tra xem ransom note có thể dựng từ magazine không.\n\n- **Input**: ransomNote, magazine\n- **Output**: true/false\n- **Ràng buộc**: 1 <= length <= 10^5",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def canConstruct(ransomNote, magazine):\n    from collections import Counter\n    return not (Counter(ransomNote)-Counter(magazine))",
        "public_test_path": "/id/public/ransom-note-027",
        "hidden_test_path": "/id/hidden/ransom-note-027",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "group-anagrams-028",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi (String)",
        "name": "Group Anagrams",
        "description": "### Bài toán\n\nNhóm các anagram lại với nhau.\n\n- **Input**: strs\n- **Output**: list of list\n- **Ràng buộc**: 1 <= strs",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def groupAnagrams(strs):\n    from collections import defaultdict\n    d = defaultdict(list)\n    for s in strs:\n        d[tuple(sorted(s))].append(s)\n    return list(d.values())",
        "public_test_path": "/id/public/group-anagrams-028",
        "hidden_test_path": "/id/hidden/group-anagrams-028",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "contains-duplicate-ii-029",
        "topic": "Chương 1",
        "sub_topic": "Từ điển (Dictionary / Hash Table)",
        "name": "Contains Duplicate II",
        "description": "### Bài toán\n\nKiểm tra xem mảng có duplicate trong khoảng k index hay không.\n\n- **Input**: nums, k\n- **Output**: true/false\n- **Ví dụ**: [1,2,3,1], k=3 → true\n- **Ràng buộc**: 1 <= nums",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def containsNearbyDuplicate(nums, k):\n    d = {}\n    for i,num in enumerate(nums):\n        if num in d and i - d[num] <= k:\n            return True\n        d[num] = i\n    return False",
        "public_test_path": "/id/public/contains-duplicate-ii-029",
        "hidden_test_path": "/id/hidden/contains-duplicate-ii-029",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 50
    },
    {
        "problem_id": "single-number-ii-030",
        "topic": "Chương 1",
        "sub_topic": "Từ điển (Dictionary / Hash Table)",
        "name": "Single Number II",
        "description": "### Bài toán\n\nTìm số xuất hiện đúng 1 lần trong mảng, các số khác xuất hiện 3 lần.\n\n- **Input**: nums\n- **Output**: số duy nhất\n- **Ví dụ**: [2,2,3,2] → 3\n- **Ràng buộc**: 1 <= nums",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def singleNumberII(nums):\n    ones = twos = 0\n    for num in nums:\n        ones = (ones ^ num) & ~twos\n        twos = (twos ^ num) & ~ones\n    return ones",
        "public_test_path": "/id/public/single-number-ii-030",
        "hidden_test_path": "/id/hidden/single-number-ii-030",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "single-number-iii-031",
        "topic": "Chương 1",
        "sub_topic": "Từ điển (Dictionary / Hash Table)",
        "name": "Single Number III",
        "description": "### Bài toán\n\nTìm 2 số xuất hiện 1 lần trong mảng, các số khác xuất hiện 2 lần.\n\n- **Input**: nums\n- **Output**: [x,y]\n- **Ví dụ**: [1,2,1,3,2,5] → [3,5]\n- **Ràng buộc**: 2 <= nums",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def singleNumberIII(nums):\n    diff = 0\n    for num in nums:\n        diff ^= num\n    diff &= -diff\n    res = [0,0]\n    for num in nums:\n        if num & diff:\n            res[0] ^= num\n        else:\n            res[1] ^= num\n    return res",
        "public_test_path": "/id/public/single-number-iii-031",
        "hidden_test_path": "/id/hidden/single-number-iii-031",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 9
    },
    {
        "problem_id": "binary-number-with-alternating-bits-032",
        "topic": "Chương 1",
        "sub_topic": "Từ điển (Dictionary / Hash Table)",
        "name": "Binary Number with Alternating Bits",
        "description": "### Bài toán\n\nKiểm tra số nhị phân có bit xen kẽ 0-1 không.\n\n- **Input**: n\n- **Output**: true/false\n- **Ví dụ**: 5 → true (101)\n- **Ràng buộc**: 1 <= n <= 2^31-1",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def hasAlternatingBits(n):\n    prev = n&1\n    n >>= 1\n    while n:\n        curr = n&1\n        if curr == prev: return False\n        prev = curr\n        n >>= 1\n    return True",
        "public_test_path": "/id/public/binary-number-with-alternating-bits-032",
        "hidden_test_path": "/id/hidden/binary-number-with-alternating-bits-032",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 31
    },
    {
        "problem_id": "reverse-linked-list-033",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Reverse Linked List",
        "description": "### Bài toán\n\nĐảo ngược linked list.\n\n- **Input**: head\n- **Output**: head mới\n- **Ví dụ**: 1→2→3 → 3→2→1\n- **Ràng buộc**: số node ≤ 5000",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def reverseList(head):\n    prev = None\n    curr = head\n    while curr:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n    return prev",
        "public_test_path": "/id/public/reverse-linked-list-033",
        "hidden_test_path": "/id/hidden/reverse-linked-list-033",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "merge-two-sorted-lists-034",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Merge Two Sorted Lists",
        "description": "### Bài toán\n\nGộp 2 linked list đã sắp xếp thành 1 list mới sắp xếp.\n\n- **Input**: l1,l2\n- **Output**: head mới\n- **Ràng buộc**: số node ≤ 50",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def mergeTwoLists(l1,l2):\n    dummy = curr = ListNode(0)\n    while l1 and l2:\n        if l1.val < l2.val:\n            curr.next = l1\n            l1 = l1.next\n        else:\n            curr.next = l2\n            l2 = l2.next\n        curr = curr.next\n    curr.next = l1 or l2\n    return dummy.next",
        "public_test_path": "/id/public/merge-two-sorted-lists-034",
        "hidden_test_path": "/id/hidden/merge-two-sorted-lists-034",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "linked-list-cycle-035",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Linked List Cycle",
        "description": "### Bài toán\n\nKiểm tra linked list có cycle hay không.\n\n- **Input**: head\n- **Output**: true/false\n- **Ràng buộc**: số node ≤ 10^4",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def hasCycle(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow==fast: return True\n    return False",
        "public_test_path": "/id/public/linked-list-cycle-035",
        "hidden_test_path": "/id/hidden/linked-list-cycle-035",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "intersection-of-two-linked-lists-036",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Intersection of Two Linked Lists",
        "description": "### Bài toán\n\nTìm node giao nhau của 2 linked list.\n\n- **Input**: headA, headB\n- **Output**: node giao nhau hoặc null\n- **Ràng buộc**: số node ≤ 10^5",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def getIntersectionNode(headA, headB):\n    a,b = headA, headB\n    while a!=b:\n        a = a.next if a else headB\n        b = b.next if b else headA\n    return a",
        "public_test_path": "/id/public/intersection-of-two-linked-lists-036",
        "hidden_test_path": "/id/hidden/intersection-of-two-linked-lists-036",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "remove-linked-list-elements-037",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Remove Linked List Elements",
        "description": "### Bài toán\n\nXóa tất cả node có giá trị val.\n\n- **Input**: head, val\n- **Output**: head mới\n- **Ràng buộc**: số node ≤ 10^4",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def removeElements(head,val):\n    dummy = ListNode(0, head)\n    curr = dummy\n    while curr.next:\n        if curr.next.val==val:\n            curr.next = curr.next.next\n        else:\n            curr = curr.next\n    return dummy.next",
        "public_test_path": "/id/public/remove-linked-list-elements-037",
        "hidden_test_path": "/id/hidden/remove-linked-list-elements-037",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "add-binary-038",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Add Binary",
        "description": "### Bài toán\n\nCộng 2 chuỗi nhị phân.\n\n- **Input**: a,b\n- **Output**: sum string\n- **Ví dụ**: '11','1' → '100'\n- **Ràng buộc**: 1 <= a",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def addBinary(a,b):\n    res = ''\n    i,j,carry = len(a)-1,len(b)-1,0\n    while i>=0 or j>=0 or carry:\n        x = int(a[i]) if i>=0 else 0\n        y = int(b[j]) if j>=0 else 0\n        carry,res = divmod(x+y+carry,2), str((x+y+carry)%2)+res\n        i-=1;j-=1\n    return res",
        "public_test_path": "/id/public/add-binary-038",
        "hidden_test_path": "/id/hidden/add-binary-038",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "implement-strstr-039",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Implement strStr",
        "description": "### Bài toán\n\nTìm index đầu tiên xuất hiện của needle trong haystack.\n\n- **Input**: haystack, needle\n- **Output**: index hoặc -1\n- **Ràng buộc**: 0 <= haystack",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def strStr(haystack,needle):\n    if not needle: return 0\n    for i in range(len(haystack)-len(needle)+1):\n        if haystack[i:i+len(needle)]==needle:\n            return i\n    return -1",
        "public_test_path": "/id/public/implement-strstr-039",
        "hidden_test_path": "/id/hidden/implement-strstr-039",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "valid-sudoku-040",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Valid Sudoku",
        "description": "### Bài toán\n\nKiểm tra Sudoku hợp lệ 9x9.\n\n- **Input**: board\n- **Output**: true/false\n- **Ràng buộc**: board",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def isValidSudoku(board):\n    rows,cols,boxes = [{} for _ in range(9)], [{} for _ in range(9)], [{} for _ in range(9)]\n    for i in range(9):\n        for j in range(9):\n            num = board[i][j]\n            if num == '.': continue\n            if num in rows[i] or num in cols[j] or num in boxes[(i//3)*3+j//3]: return False\n            rows[i][j] = cols[j][num] = boxes[(i//3)*3+j//3][num] = True\n    return True",
        "public_test_path": "/id/public/valid-sudoku-040",
        "hidden_test_path": "/id/hidden/valid-sudoku-040",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "fizz-buzz-041",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Fizz Buzz",
        "description": "### Bài toán\n\nIn 1..n với multiples of 3 → 'Fizz', multiples of 5 → 'Buzz', multiples cả 3&5 → 'FizzBuzz'.\n\n- **Input**: n\n- **Output**: list\n- **Ràng buộc**: 1 <= n <= 10^4",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def fizzBuzz(n):\n    res = []\n    for i in range(1,n+1):\n        if i%3==0 and i%5==0: res.append('FizzBuzz')\n        elif i%3==0: res.append('Fizz')\n        elif i%5==0: res.append('Buzz')\n        else: res.append(str(i))\n    return res",
        "public_test_path": "/id/public/fizz-buzz-041",
        "hidden_test_path": "/id/hidden/fizz-buzz-041",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "happy-number-042",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Happy Number",
        "description": "### Bài toán\n\nKiểm tra số là Happy Number hay không.\n\n- **Input**: n\n- **Output**: true/false\n- **Ràng buộc**: 1 <= n <= 2^31-1",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def isHappy(n):\n    seen = set()\n    while n!=1 and n not in seen:\n        seen.add(n)\n        n = sum(int(x)**2 for x in str(n))\n    return n==1",
        "public_test_path": "/id/public/happy-number-042",
        "hidden_test_path": "/id/hidden/happy-number-042",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 25
    },
    {
        "problem_id": "valid-parentheses-043",
        "topic": "Chương 1",
        "sub_topic": "File & Ngoại lệ",
        "name": "Valid Parentheses",
        "description": "### Bài toán\n\nKiểm tra chuỗi chứa (),{},[] có hợp lệ không.\n\n- **Input**: s\n- **Output**: true/false\n- **Ràng buộc**: 1 <= s",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def isValid(s):\n    stack=[]\n    mapping={')':'(','}':'{',']':'['}\n    for c in s:\n        if c in mapping:\n            if not stack or stack.pop()!=mapping[c]: return False\n        else:\n            stack.append(c)\n    return not stack",
        "public_test_path": "/id/public/valid-parentheses-043",
        "hidden_test_path": "/id/hidden/valid-parentheses-043",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 30
    },
    {
        "problem_id": "find-the-index-of-the-first-occurrence-in-a-string-044",
        "topic": "Chương 1",
        "sub_topic": "File & Ngoại lệ",
        "name": "Find the Index of the First Occurrence in a String",
        "description": "### Bài toán\n\nTìm index đầu tiên xuất hiện của needle trong haystack.\n\n- **Input**: haystack, needle\n- **Output**: index hoặc -1\n- **Ràng buộc**: 0 <= haystack",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def strStr(haystack,needle):\n    if not needle: return 0\n    for i in range(len(haystack)-len(needle)+1):\n        if haystack[i:i+len(needle)]==needle:\n            return i\n    return -1",
        "public_test_path": "/id/public/find-the-index-of-the-first-occurrence-in-a-string-044",
        "hidden_test_path": "/id/hidden/find-the-index-of-the-first-occurrence-in-a-string-044",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 24
    },
    {
        "problem_id": "valid-palindrome-045",
        "topic": "Chương 1",
        "sub_topic": "File & Ngoại lệ",
        "name": "Valid Palindrome",
        "description": "### Bài toán\n\nKiểm tra chuỗi có phải palindrome không.\n\n- **Input**: s\n- **Output**: true/false\n- **Ràng buộc**: 1 <= s",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def isPalindrome(s):\n    s = ''.join(c.lower() for c in s if c.isalnum())\n    return s==s[::-1]",
        "public_test_path": "/id/public/valid-palindrome-045",
        "hidden_test_path": "/id/hidden/valid-palindrome-045",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "reverse-string-046",
        "topic": "Chương 1",
        "sub_topic": "File & Ngoại lệ",
        "name": "Reverse String",
        "description": "### Bài toán\n\nĐảo ngược chuỗi in-place.\n\n- **Input**: s\n- **Output**: s đảo ngược\n- **Ràng buộc**: 1 <= s",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def reverseString(s):\n    i,j=0,len(s)-1\n    while i<j:\n        s[i],s[j]=s[j],s[i]\n        i+=1;j-=1\n    return s",
        "public_test_path": "/id/public/reverse-string-046",
        "hidden_test_path": "/id/hidden/reverse-string-046",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "valid-anagram-047",
        "topic": "Chương 1",
        "sub_topic": "File & Ngoại lệ",
        "name": "Valid Anagram",
        "description": "### Bài toán\n\nKiểm tra 2 chuỗi có phải anagram không.\n\n- **Input**: s,t\n- **Output**: true/false\n- **Ràng buộc**: 1 <= s",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def isAnagram(s,t):\n    from collections import Counter\n    return Counter(s)==Counter(t)",
        "public_test_path": "/id/public/valid-anagram-047",
        "hidden_test_path": "/id/hidden/valid-anagram-047",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "min-stack-048",
        "topic": "Chương 1",
        "sub_topic": "Hướng đối tượng (OOP – Design)",
        "name": "Min Stack",
        "description": "### Bài toán\n\nThiết kế stack hỗ trợ push/pop/top và getMin. Constraints: số thao tác <= 3*10^4.\n\n- **Ràng buộc**: số thao tác <= 3*10^4",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n    def push(self,val):\n        self.stack.append(val)\n        self.min_stack.append(val if not self.min_stack else min(val,self.min_stack[-1]))\n    def pop(self):\n        self.stack.pop(); self.min_stack.pop()\n    def top(self):\n        return self.stack[-1]\n    def getMin(self):\n        return self.min_stack[-1]",
        "public_test_path": "/id/public/min-stack-048",
        "hidden_test_path": "/id/hidden/min-stack-048",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "implement-queue-using-stacks-049",
        "topic": "Chương 1",
        "sub_topic": "Hướng đối tượng (OOP – Design)",
        "name": "Implement Queue using Stacks",
        "description": "### Bài toán\n\nThiết kế queue sử dụng 2 stack. Constraints: số thao tác <= 1000.\n\n- **Ràng buộc**: số thao tác <= 1000",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class MyQueue:\n    def __init__(self):\n        self.instack = []\n        self.outstack = []\n    def push(self,x):\n        self.instack.append(x)\n    def pop(self):\n        self.peek(); return self.outstack.pop()\n    def peek(self):\n        if not self.outstack:\n            while self.instack: self.outstack.append(self.instack.pop())\n        return self.outstack[-1]\n    def empty(self):\n        return not self.instack and not self.outstack",
        "public_test_path": "/id/public/implement-queue-using-stacks-049",
        "hidden_test_path": "/id/hidden/implement-queue-using-stacks-049",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "implement-stack-using-queues-050",
        "topic": "Chương 1",
        "sub_topic": "Hướng đối tượng (OOP – Design)",
        "name": "Implement Stack using Queues",
        "description": "### Bài toán\n\nThiết kế stack sử dụng 2 queue. Constraints: số thao tác <= 1000.\n\n- **Ràng buộc**: số thao tác <= 1000",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class MyStack:\n    def __init__(self):\n        self.q1 = []\n        self.q2 = []\n    def push(self,x):\n        self.q1.append(x)\n    def pop(self):\n        while len(self.q1)>1: self.q2.append(self.q1.pop(0))\n        res=self.q1.pop()\n        self.q1,self.q2=self.q2,self.q1\n        return res\n    def top(self):\n        res=self.pop(); self.q1.append(res); return res\n    def empty(self):\n        return not self.q1",
        "public_test_path": "/id/public/implement-stack-using-queues-050",
        "hidden_test_path": "/id/hidden/implement-stack-using-queues-050",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "range-sum-query---immutable-051",
        "topic": "Chương 1",
        "sub_topic": "Hướng đối tượng (OOP – Design)",
        "name": "Range Sum Query - Immutable",
        "description": "### Bài toán\n\nThiết kế cấu trúc hỗ trợ truy vấn sum trong mảng immutable.\n\n- **Input**: nums\n- **Ràng buộc**: 1 <= nums",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class NumArray:\n    def __init__(self,nums):\n        self.sums=[0]*(len(nums)+1)\n        for i,num in enumerate(nums):\n            self.sums[i+1]=self.sums[i]+num\n    def sumRange(self,i,j):\n        return self.sums[j+1]-self.sums[i]",
        "public_test_path": "/id/public/range-sum-query---immutable-051",
        "hidden_test_path": "/id/hidden/range-sum-query---immutable-051",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    },
    {
        "problem_id": "lru-cache-052",
        "topic": "Chương 1",
        "sub_topic": "Hướng đối tượng (OOP – Design)",
        "name": "LRU Cache",
        "description": "### Bài toán\n\nThiết kế LRU cache hỗ trợ get và put. Constraints: 1 <= capacity <= 3000.\n\n- **Ràng buộc**: 1 <= capacity <= 3000",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import OrderedDict\nclass LRUCache:\n    def __init__(self,capacity):\n        self.cap=capacity\n        self.cache=OrderedDict()\n    def get(self,key):\n        if key not in self.cache: return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    def put(self,key,value):\n        if key in self.cache: self.cache.move_to_end(key)\n        self.cache[key]=value\n        if len(self.cache)>self.cap: self.cache.popitem(last=False)",
        "public_test_path": "/id/public/lru-cache-052",
        "hidden_test_path": "/id/hidden/lru-cache-052",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "design-hashset-053",
        "topic": "Chương 1",
        "sub_topic": "Hướng đối tượng (OOP – Design)",
        "name": "Design HashSet",
        "description": "### Bài toán\n\nThiết kế HashSet hỗ trợ add, remove, contains. Constraints: 0 <= key <= 10^6.\n\n- **Ràng buộc**: 0 <= key <= 10^6",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class MyHashSet:\n    def __init__(self):\n        self.s=set()\n    def add(self,key): self.s.add(key)\n    def remove(self,key): self.s.discard(key)\n    def contains(self,key): return key in self.s",
        "public_test_path": "/id/public/design-hashset-053",
        "hidden_test_path": "/id/hidden/design-hashset-053",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "design-hashmap-054",
        "topic": "Chương 1",
        "sub_topic": "Hướng đối tượng (OOP – Design)",
        "name": "Design HashMap",
        "description": "### Bài toán\n\nThiết kế HashMap hỗ trợ put, get, remove. Constraints: 0 <= key <= 10^6.\n\n- **Ràng buộc**: 0 <= key <= 10^6",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class MyHashMap:\n    def __init__(self):\n        self.d={}\n    def put(self,key,value): self.d[key]=value\n    def get(self,key): return self.d.get(key,-1)\n    def remove(self,key): self.d.pop(key,None)",
        "public_test_path": "/id/public/design-hashmap-054",
        "hidden_test_path": "/id/hidden/design-hashmap-054",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "design-linked-list-055",
        "topic": "Chương 1",
        "sub_topic": "Hướng đối tượng (OOP – Design)",
        "name": "Design Linked List",
        "description": "### Bài toán\n\nThiết kế singly linked list hỗ trợ add/get/delete. Constraints: số thao tác <= 1000.\n\n- **Ràng buộc**: số thao tác <= 1000",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class MyLinkedList:\n    def __init__(self):\n        self.head = None\n    class Node:\n        def __init__(self,val): self.val=val; self.next=None\n    def get(self,index):\n        curr=self.head\n        for _ in range(index):\n            if not curr: return -1\n            curr=curr.next\n        return curr.val if curr else -1\n    def addAtHead(self,val):\n        node=self.Node(val)\n        node.next=self.head\n        self.head=node\n    def addAtTail(self,val):\n        node=self.Node(val)\n        if not self.head: self.head=node; return\n        curr=self.head\n        while curr.next: curr=curr.next\n        curr.next=node\n    def addAtIndex(self,index,val):\n        if index==0: self.addAtHead(val); return\n        curr=self.head\n        for _ in range(index-1):\n            if not curr: return\n            curr=curr.next\n        if curr:\n            node=self.Node(val)\n            node.next=curr.next\n            curr.next=node\n    def deleteAtIndex(self,index):\n        if index==0 and self.head: self.head=self.head.next; return\n        curr=self.head\n        for _ in range(index-1):\n            if not curr: return\n            curr=curr.next\n        if curr and curr.next: curr.next=curr.next.next",
        "public_test_path": "/id/public/design-linked-list-055",
        "hidden_test_path": "/id/hidden/design-linked-list-055",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "design-circular-queue-056",
        "topic": "Chương 1",
        "sub_topic": "Hướng đối tượng (OOP – Design)",
        "name": "Design Circular Queue",
        "description": "### Bài toán\n\nThiết kế circular queue hỗ trợ enqueue/dequeue. Constraints: số thao tác <= 1000.\n\n- **Ràng buộc**: số thao tác <= 1000",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class MyCircularQueue:\n    def __init__(self,k):\n        self.queue=[0]*k\n        self.head=self.tail=self.count=0\n        self.size=k\n    def enQueue(self,value):\n        if self.count==self.size: return False\n        self.queue[self.tail]=value\n        self.tail=(self.tail+1)%self.size\n        self.count+=1\n        return True\n    def deQueue(self):\n        if self.count==0: return False\n        self.head=(self.head+1)%self.size\n        self.count-=1\n        return True\n    def Front(self): return self.queue[self.head] if self.count else -1\n    def Rear(self): return self.queue[self.tail-1] if self.count else -1\n    def isEmpty(self): return self.count==0\n    def isFull(self): return self.count==self.size",
        "public_test_path": "/id/public/design-circular-queue-056",
        "hidden_test_path": "/id/hidden/design-circular-queue-056",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "design-browser-history-057",
        "topic": "Chương 1",
        "sub_topic": "Hướng đối tượng (OOP – Design)",
        "name": "Design Browser History",
        "description": "### Bài toán\n\nThiết kế lịch sử trình duyệt hỗ trợ visit/back/forward. Constraints: số thao tác <= 1000.\n\n- **Ràng buộc**: số thao tác <= 1000",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class BrowserHistory:\n    def __init__(self,homepage):\n        self.history=[homepage]; self.curr=0\n    def visit(self,url):\n        self.history=self.history[:self.curr+1]\n        self.history.append(url)\n        self.curr+=1\n    def back(self,steps):\n        self.curr=max(0,self.curr-steps)\n        return self.history[self.curr]\n    def forward(self,steps):\n        self.curr=min(len(self.history)-1,self.curr+steps)\n        return self.history[self.curr]",
        "public_test_path": "/id/public/design-browser-history-057",
        "hidden_test_path": "/id/hidden/design-browser-history-057",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "middle-linked-list-104",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Find Middle of Linked List",
        "description": "### Bài toán\n\nTìm node ở giữa linked list. Nếu số lượng node chẵn, trả về node thứ hai trong hai node giữa.\n\n- **Input**: head\n- **Output**: node giữa\n- **Ví dụ**: \n  - [1, 2, 3, 4, 5] -> 3\n  - [1, 2, 3, 4] -> 3\n- **Ràng buộc**: số node ≤ 5000",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def middleNode(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    return slow",
        "public_test_path": "/id/public/middle-linked-list-104",
        "hidden_test_path": "/id/hidden/middle-linked-list-104",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "remove-duplicates-linked-list-105",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Remove Duplicates from Sorted Linked List",
        "description": "### Bài toán\n\nLoại bỏ các node trùng nhau trong một linked list đã được sắp xếp sao cho mỗi giá trị chỉ xuất hiện một lần.\n\n- **Input**: head (linked list đã sắp xếp)\n- **Output**: head mới sau khi loại bỏ các node trùng\n- **Ví dụ**: \n  - [1, 1, 2] -> [1, 2]\n  - [1, 1, 2, 3, 3] -> [1, 2, 3]\n- **Ràng buộc**: số node ≤ 5000",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def deleteDuplicates(head):\n    curr = head\n    while curr and curr.next:\n        if curr.val == curr.next.val:\n            curr.next = curr.next.next\n        else:\n            curr = curr.next\n    return head",
        "public_test_path": "/id/public/remove-duplicates-linked-list-105",
        "hidden_test_path": "/id/hidden/remove-duplicates-linked-list-105",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "unique-elements-list-109",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Return Unique Elements in List",
        "description": "### Bài toán\n\nCho một danh sách các số nguyên, viết hàm trả về một danh sách mới chứa các phần tử duy nhất, giữ nguyên thứ tự xuất hiện lần đầu.\n\n- **Input**: list các số nguyên\n- **Output**: list các số nguyên không trùng, giữ thứ tự\n- **Ví dụ**: \n  - [1, 2, 2, 3, 4, 4] -> [1, 2, 3, 4]\n  - [4, 5, 4, 6] -> [4, 5, 6]\n- **Ràng buộc**: độ dài list ≤ 10^5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def uniqueElements(lst):\n    seen = set()\n    result = []\n    for num in lst:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    return result",
        "public_test_path": "/id/public/unique-elements-list-109",
        "hidden_test_path": "/id/hidden/unique-elements-list-109",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "count-prime-numbers-110",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Count Prime Numbers in Range",
        "description": "### Bài toán\n\nCho một số nguyên n, đếm số lượng số nguyên tố nhỏ hơn n.\n\n- **Input**: một số nguyên n\n- **Output**: số lượng số nguyên tố nhỏ hơn n\n- **Ví dụ**: \n  - n = 10 -> 4 (2,3,5,7)\n  - n = 0 -> 0\n- **Ràng buộc**: 0 ≤ n ≤ 10^6",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def countPrimes(n):\n    if n <= 2:\n        return 0\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i]:\n            for j in range(i*i, n, i):\n                sieve[j] = False\n    return sum(sieve)",
        "public_test_path": "/id/public/count-prime-numbers-110",
        "hidden_test_path": "/id/hidden/count-prime-numbers-110",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 19
    },
    {
        "problem_id": "square-elements-list-111",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Square Elements in List",
        "description": "### Bài toán\n\nCho một danh sách các số nguyên, viết hàm trả về danh sách các bình phương của từng phần tử.\n\n- **Input**: list các số nguyên\n- **Output**: list các số nguyên là bình phương của từng phần tử cơ bản\n- **Ví dụ**:\n  - [1, 2, 3] -> [1, 4, 9]\n  - [0, -1, 5] -> [0, 1, 25]\n- **Ràng buộc**: độ dài list ≤ 10^5",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def squareElements(lst):\n    return [x*x for x in lst]",
        "public_test_path": "/id/public/square-elements-list-111",
        "hidden_test_path": "/id/hidden/square-elements-list-111",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "longest-palindromic-subsequence-112",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Longest Palindromic Subsequence",
        "description": "### Bài toán\n\nCho một chuỗi, tìm độ dài của chuỗi con palindrome dài nhất trong chuỗi đó.\n\n- **Input**: một chuỗi ký tự\n- **Output**: độ dài của chuỗi con palindrome dài nhất\n- **Ví dụ**: \n  - \"bbbab\" -> 4 (subsequence: \"bbbb\")\n  - \"cbbd\" -> 2 (subsequence: \"bb\")\n- **Ràng buộc**: độ dài chuỗi ≤ 1000",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def longestPalindromeSubseq(s):\n    memo = {}\n    def dp(i, j):\n        if i > j:\n            return 0\n        if i == j:\n            return 1\n        if (i, j) in memo:\n            return memo[(i, j)]\n        if s[i] == s[j]:\n            memo[(i, j)] = 2 + dp(i+1, j-1)\n        else:\n            memo[(i, j)] = max(dp(i+1, j), dp(i, j-1))\n        return memo[(i, j)]\n    return dp(0, len(s)-1)",
        "public_test_path": "/id/public/longest-palindromic-subsequence-112",
        "hidden_test_path": "/id/hidden/longest-palindromic-subsequence-112",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "custom-sort-113",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Custom Sort by Frequency and Value",
        "description": "### Bài toán\n\nCho một danh sách các số nguyên, sắp xếp lại sao cho các phần tử được sắp xếp theo tần suất xuất hiện giảm dần, nếu hai phần tử có tần suất bằng nhau thì sắp xếp theo giá trị tăng dần.\n\n- **Input**: list các số nguyên\n- **Output**: list đã sắp xếp theo quy tắc trên\n- **Ví dụ**: \n  - [1,1,2,2,2,3] -> [2,2,2,1,1,3]\n  - [2,3,1,3,2] -> [2,2,3,3,1]\n- **Ràng buộc**: độ dài list ≤ 10^5",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def customSort(lst):\n    from collections import Counter\n    freq = Counter(lst)\n    return sorted(lst, key=lambda x: (-freq[x], x))",
        "public_test_path": "/id/public/custom-sort-113",
        "hidden_test_path": "/id/hidden/custom-sort-113",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "apply-function-list-114",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Apply Function to List Elements",
        "description": "### Bài toán\n\nCho một danh sách số nguyên và một hàm f, viết hàm trả về danh sách mới với các phần tử là kết quả f áp dụng lên từng phần tử.\n\n- **Input**: danh sách số nguyên và hàm f\n- **Output**: danh sách số nguyên sau khi áp dụng hàm\n- **Ví dụ**:\n  - lst = [1,2,3], f = lambda x: x * x -> [1,4,9]\n  - lst = [0, -1, 2], f = lambda x: x + 1 -> [1, 0, 3]\n- **Ràng buộc**: độ dài list ≤ 10^5",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def applyFunction(lst, f):\n    return list(map(f, lst))",
        "public_test_path": "/id/public/apply-function-list-114",
        "hidden_test_path": "/id/hidden/apply-function-list-114",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 60
    },
    {
        "problem_id": "recursive-sum-digits-115",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Sum of Digits Recursively",
        "description": "### Bài toán\n\nViết hàm tính tổng các chữ số của một số nguyên dương theo cách đệ quy.\n\n- **Input**: một số nguyên dương n\n- **Output**: tổng các chữ số của n\n- **Ví dụ**: \n  - n = 1234 -> 10\n  - n = 0 -> 0\n- **Ràng buộc**: 0 ≤ n ≤ 10^9",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def sumDigits(n):\n    if n == 0:\n        return 0\n    return n % 10 + sumDigits(n // 10)",
        "public_test_path": "/id/public/recursive-sum-digits-115",
        "hidden_test_path": "/id/hidden/recursive-sum-digits-115",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "string-compression-recursive-119",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Recursive String Compression",
        "description": "### Bài toán\n\nViết hàm đệ quy nén chuỗi theo thuật toán kiểu Run-Length Encoding (RLE) đơn giản: nén các ký tự liên tiếp giống nhau thành ký tự và số lượng.\n\n- **Input**: một chuỗi gồm các ký tự chữ cái thường\n- **Output**: chuỗi đã được nén theo RLE\n- **Ví dụ**:\n  - \"aaabbc\" -> \"a3b2c1\"\n  - \"abcd\" -> \"a1b1c1d1\"\n- **Ràng buộc**: độ dài chuỗi ≤ 10^4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def recursiveCompress(s):\n    if not s:\n        return \"\"\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] != s[0]:\n            return s[0] + str(count) + recursiveCompress(s[i:])\n        count += 1\n    return s[0] + str(count)",
        "public_test_path": "/id/public/string-compression-recursive-119",
        "hidden_test_path": "/id/hidden/string-compression-recursive-119",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "matrix-transpose-120",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Matrix Transpose",
        "description": "### Bài toán\n\nViết hàm nhận một ma trận 2D (danh sách các danh sách số nguyên) và trả về ma trận chuyển vị của nó.\n\n- **Input**: ma trận 2D kích thước m x n\n- **Output**: ma trận chuyển vị n x m\n- **Ví dụ**:\n  - [[1,2,3],[4,5,6]] -> [[1,4],[2,5],[3,6]]\n  - [[1]] -> [[1]]\n- **Ràng buộc**: 1 ≤ m,n ≤ 1000",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def transposeMatrix(matrix):\n    return [list(row) for row in zip(*matrix)]",
        "public_test_path": "/id/public/matrix-transpose-120",
        "hidden_test_path": "/id/hidden/matrix-transpose-120",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "prefix-check-051",
        "topic": "Chương 1",
        "sub_topic": "File & Ngoại lệ",
        "name": "Prefix Check",
        "description": "### Bài toán\n\nKiểm tra chuỗi s có phải là tiền tố của chuỗi t hay không.\n\n- Input: s,t\n- Output: true/false\n- Ràng buộc: 1 <= len(s), len(t) <= 10^4",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def isPrefix(s,t):\n return t.startswith(s)",
        "public_test_path": "/id/public/prefix-check-051",
        "hidden_test_path": "/id/hidden/prefix-check-051",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "suffix-check-052",
        "topic": "Chương 1",
        "sub_topic": "File & Ngoại lệ",
        "name": "Suffix Check",
        "description": "### Bài toán\n\nKiểm tra chuỗi s có phải là hậu tố của chuỗi t hay không.\n\n- Input: s,t\n- Output: true/false\n- Ràng buộc: 1 <= len(s), len(t) <= 10^4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def isSuffix(s,t):\n return t.endswith(s)",
        "public_test_path": "/id/public/suffix-check-052",
        "hidden_test_path": "/id/hidden/suffix-check-052",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 26
    },
    {
        "problem_id": "suffix-check-052",
        "topic": "Chương 1",
        "sub_topic": "File & Ngoại lệ",
        "name": "Suffix Check",
        "description": "### Bài toán\n\nKiểm tra chuỗi s có phải là hậu tố của chuỗi t hay không.\n\n- Input: s,t\n- Output: true/false\n- Ràng buộc: 1 <= len(s), len(t) <= 10^4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def isSuffix(s,t):\n return t.endswith(s)",
        "public_test_path": "/id/public/suffix-check-052",
        "hidden_test_path": "/id/hidden/suffix-check-052",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 26
    },
    {
        "problem_id": "file-exception-content-check-055",
        "topic": "Chương 1",
        "sub_topic": "File & Ngoại lệ",
        "name": "File Content Exception Check",
        "description": "### Bài toán\n\nKiểm tra trong chuỗi đầu vào s có chứa ký tự đặc biệt không (ngoại trừ chữ cái và số). Nếu có, ném ra ngoại lệ.\n\n- Input: s\n- Output: true nếu không có ký tự đặc biệt, nếu có ký tự đặc biệt ném ngoại lệ\n- Ràng buộc: s chỉ gồm ký tự ASCII",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def checkContent(s):\n if any(not c.isalnum() for c in s):\n raise ValueError('Invalid character found')\n return True",
        "public_test_path": "/id/public/file-exception-content-check-055",
        "hidden_test_path": "/id/hidden/file-exception-content-check-055",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "file-exception-parse-int-056",
        "topic": "Chương 1",
        "sub_topic": "File & Ngoại lệ",
        "name": "File Integer Parse Exception Check",
        "description": "### Bài toán\n\nKiểm tra xem một chuỗi đầu vào có thể chuyển sang số nguyên hay không. Nếu không thể, ném ngoại lệ.\n\n- Input: s\n- Output: true nếu chuyển thành số nguyên được, nếu không ném ngoại lệ\n- Ràng buộc: s là chuỗi ASCII",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def checkIntParse(s):\n try:\n int(s)\n return True\n except ValueError:\n raise ValueError('Cannot parse int')",
        "public_test_path": "/id/public/file-exception-parse-int-056",
        "hidden_test_path": "/id/hidden/file-exception-parse-int-056",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "file-exception-duplicate-check-057",
        "topic": "Chương 1",
        "sub_topic": "File & Ngoại lệ",
        "name": "File Duplicate Character Check",
        "description": "### Bài toán\n\nKiểm tra xem chuỗi s có chứa ký tự bị lặp lại hay không. Nếu có ký tự lặp lại, ném ngoại lệ.\n\n- Input: s\n- Output: true nếu không có ký tự lặp, nếu có ký tự lặp ném ngoại lệ\n- Ràng buộc: s chỉ gồm ký tự ASCII",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def checkDuplicates(s):\n seen = set()\n for c in s:\n if c in seen:\n raise ValueError('Duplicate character found')\n seen.add(c)\n return True",
        "public_test_path": "/id/public/file-exception-duplicate-check-057",
        "hidden_test_path": "/id/hidden/file-exception-duplicate-check-057",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "file-exception-palindrome-anagram-058",
        "topic": "Chương 1",
        "sub_topic": "File & Ngoại lệ",
        "name": "Palindrome Anagram Exception Check",
        "description": "### Bài toán\n\nKiểm tra xem chuỗi s có phải là anagram của một palindrome không. Nếu không, ném ngoại lệ.\n\n- Input: s\n- Output: true nếu có thể sắp xếp thành palindrome, nếu không ném ngoại lệ\n- Ràng buộc: s chỉ gồm ký tự ASCII",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def checkPalindromeAnagram(s):\n from collections import Counter\n count = Counter(s)\n odd_count = sum(1 for v in count.values() if v % 2 != 0)\n if odd_count > 1:\n raise ValueError('Not a palindrome anagram')\n return True",
        "public_test_path": "/id/public/file-exception-palindrome-anagram-058",
        "hidden_test_path": "/id/hidden/file-exception-palindrome-anagram-058",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 19
    },
    {
        "problem_id": "file-exception-balanced-parentheses-059",
        "topic": "Chương 1",
        "sub_topic": "File & Ngoại lệ",
        "name": "Balanced Parentheses Exception Check",
        "description": "### Bài toán\n\nKiểm tra xem chuỗi s có dấu ngoặc đơn cân bằng không. Nếu không cân bằng, ném ngoại lệ.\n\n- Input: s\n- Output: true nếu cân bằng, nếu không ném ngoại lệ\n- Ràng buộc: s chỉ gồm ký tự '(' và ')'",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def checkBalancedParentheses(s):\n stack = []\n for char in s:\n if char == '(': \n stack.append(char)\n elif char == ')':\n if not stack:\n raise ValueError('Parentheses not balanced')\n stack.pop()\n if stack:\n raise ValueError('Parentheses not balanced')\n return True",
        "public_test_path": "/id/public/file-exception-balanced-parentheses-059",
        "hidden_test_path": "/id/hidden/file-exception-balanced-parentheses-059",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 30
    },
    {
        "problem_id": "file-exception-unique-words-061",
        "topic": "Chương 1",
        "sub_topic": "File & Ngoại lệ",
        "name": "Unique Words Exception Check",
        "description": "### Bài toán\n\nKiểm tra xem tất cả các từ trong chuỗi s (cách nhau bằng dấu cách) có duy nhất không. Nếu có từ bị lặp lại ném ngoại lệ.\n\n- Input: s\n- Output: true nếu tất cả từ là duy nhất, nếu không ném ngoại lệ\n- Ràng buộc: s chỉ gồm các từ chữ và số, phân cách bởi dấu cách",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def checkUniqueWords(s):\n words = s.split()\n seen = set()\n for word in words:\n if word in seen:\n raise ValueError('Duplicate word found')\n seen.add(word)\n return True",
        "public_test_path": "/id/public/file-exception-unique-words-061",
        "hidden_test_path": "/id/hidden/file-exception-unique-words-061",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 23
    },
    {
        "problem_id": "file-exception-duplicate-lines-063",
        "topic": "Chương 1",
        "sub_topic": "File & Ngoại lệ",
        "name": "Duplicate Lines Exception Check",
        "description": "### Bài toán\n\nKiểm tra trong danh sách các dòng (mỗi dòng là một chuỗi) có dòng nào bị trùng lặp không. Nếu có dòng trùng, ném ngoại lệ.\n\n- Input: lines (danh sách chuỗi)\n- Output: true nếu không có dòng trùng lặp, nếu có ném ngoại lệ\n- Ràng buộc: số lượng dòng tối đa 10^5, mỗi dòng độ dài tối đa 10^4 ký tự",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def checkDuplicateLines(lines):\n seen = set()\n for line in lines:\n if line in seen:\n raise ValueError('Duplicate line found')\n seen.add(line)\n return True",
        "public_test_path": "/id/public/file-exception-duplicate-lines-063",
        "hidden_test_path": "/id/hidden/file-exception-duplicate-lines-063",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "palindrome-number-102",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Palindrome Number",
        "description": "## Palindrome Number\n**Kiểm tra xem một số nguyên có phải là số palindrome không (đọc xuôi và đọc ngược giống nhau).**\n- **Input:** một số nguyên x\n- **Output:** boolean (true nếu là palindrome, false nếu không)\n- **Example:** 121 → true, 123 → false\n- **Constraints:** Không dùng chuỗi, chỉ dùng toán tử số học và vòng lặp.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0) return false;\n        int original = x;\n        int reversed = 0;\n        while (x > 0) {\n            int digit = x % 10;\n            reversed = reversed * 10 + digit;\n            x /= 10;\n        }\n        return original == reversed;\n    }\n};",
        "public_test_path": "/id/public/palindrome-number-102",
        "hidden_test_path": "/id/hidden/palindrome-number-102",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "largest-divisible-by-3-103",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Largest Number Divisible by 3",
        "description": "## Largest Number Divisible by 3\n**Tìm số lớn nhất có thể tạo thành từ các chữ số của một số nguyên dương sao cho chia hết cho 3.**\n- **Input:** một số nguyên dương n\n- **Output:** số nguyên lớn nhất chia hết cho 3, hoặc -1 nếu không có số thỏa mãn\n- **Example:** n=312 → 312, n=10 → -1\n- **Constraints:** Sử dụng vòng lặp, rẽ nhánh và thao tác trên list các chữ số.",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def largestDivisibleBy3(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        digits.sort(reverse=True)\n        total = sum(digits)\n        remainder = total % 3\n        if remainder == 0:\n            return int(''.join(map(str, digits))) if digits else -1\n        # Xóa một chữ số nhỏ nhất có remainder == remainder\n        for i in range(len(digits)-1, -1, -1):\n            if digits[i] % 3 == remainder:\n                digits.pop(i)\n                break\n        else:\n            # Nếu không xóa được, xóa hai chữ số nhỏ nhất có remainder == 3 - remainder\n            count = 0\n            for i in range(len(digits)-1, -1, -1):\n                if digits[i] % 3 == 3 - remainder:\n                    digits.pop(i)\n                    count += 1\n                    if count == 2:\n                        break\n            if count < 2:\n                return -1\n        if not digits:\n            return -1\n        return int(''.join(map(str, digits)))\n",
        "public_test_path": "/id/public/largest-divisible-by-3-103",
        "hidden_test_path": "/id/hidden/largest-divisible-by-3-103",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 22
    },
    {
        "problem_id": "count-even-odd-104",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Count Even and Odd Digits",
        "description": "## Count Even and Odd Digits\n**Đếm số lượng chữ số chẵn và chữ số lẻ trong một số nguyên dương.**\n- **Input:** một số nguyên dương n\n- **Output:** một danh sách gồm 2 số: số chữ số chẵn và số chữ số lẻ\n- **Example:** n=12345 → [2, 3]\n- **Constraints:** Sử dụng vòng lặp và rẽ nhánh.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def countEvenOdd(self, n: int) -> [int, int]:\n        even_count = 0\n        odd_count = 0\n        if n == 0:\n            return [1, 0]\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n            n //= 10\n        return [even_count, odd_count]",
        "public_test_path": "/id/public/count-even-odd-104",
        "hidden_test_path": "/id/hidden/count-even-odd-104",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 36
    },
    {
        "problem_id": "sum-of-digits-equal-105",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Sum of Digits Equal to Target",
        "description": "## Sum of Digits Equal to Target\n**Kiểm tra xem tổng các chữ số của một số nguyên dương có bằng một số mục tiêu hay không.**\n- **Input:** hai số nguyên dương n và target\n- **Output:** boolean (true nếu tổng chữ số của n bằng target, false nếu không)\n- **Example:** n=123, target=6 → true, n=123, target=5 → false\n- **Constraints:** Sử dụng vòng lặp và rẽ nhánh.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def isSumEqualTarget(self, n: int, target: int) -> bool:\n        total = 0\n        while n > 0:\n            total += n % 10\n            n //= 10\n        return total == target",
        "public_test_path": "/id/public/sum-of-digits-equal-105",
        "hidden_test_path": "/id/hidden/sum-of-digits-equal-105",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 50
    },
    {
        "problem_id": "next-greater-element-106",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Next Greater Element",
        "description": "## Next Greater Element\n**Tìm chữ số lớn hơn ngay sau chữ số hiện tại trong số nguyên n (từ trái sang phải) và trả về một số mới bằng cách thay thế mỗi chữ số bằng chữ số lớn hơn gần nhất đó, nếu không có thì giữ nguyên.**\n- **Input:** một số nguyên dương n\n- **Output:** số mới sau khi thay thế\n- **Example:** n=1234 → 2344, n=987 → 987\n- **Constraints:** Sử dụng vòng lặp và rẽ nhánh.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        length = len(digits)\n        result = []\n        for i in range(length):\n            next_greater = digits[i]\n            for j in range(i+1, length):\n                if digits[j] > digits[i]:\n                    next_greater = digits[j]\n                    break\n            result.append(str(next_greater))\n        return int(''.join(result))",
        "public_test_path": "/id/public/next-greater-element-106",
        "hidden_test_path": "/id/hidden/next-greater-element-106",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 26
    },
    {
        "problem_id": "max-digit-product-107",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Max Digit Product",
        "description": "## Max Digit Product\n**Tính tích lớn nhất của hai chữ số liên tiếp trong số nguyên dương n.**\n- **Input:** một số nguyên dương n\n- **Output:** tích lớn nhất của hai chữ số liên tiếp\n- **Example:** n=12345 → 20 (4*5), n=1111 → 1\n- **Constraints:** Sử dụng vòng lặp và rẽ nhánh.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def maxDigitProduct(self, n: int) -> int:\n        digits = list(map(int, str(n)))\n        max_product = 0\n        for i in range(len(digits) - 1):\n            product = digits[i] * digits[i+1]\n            if product > max_product:\n                max_product = product\n        return max_product",
        "public_test_path": "/id/public/max-digit-product-107",
        "hidden_test_path": "/id/hidden/max-digit-product-107",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 27
    },
    {
        "problem_id": "armstrong-number-108",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Armstrong Number",
        "description": "## Armstrong Number\n**Kiểm tra xem một số nguyên dương n có phải là số Armstrong hay không. Số Armstrong là số có tổng các chữ số mũ số chữ số bằng chính số đó.**\n- **Input:** một số nguyên dương n\n- **Output:** boolean (true nếu n là số Armstrong, false nếu không)\n- **Example:** n=153 → true, n=123 → false\n- **Constraints:** Sử dụng vòng lặp và rẽ nhánh.",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def isArmstrong(self, n: int) -> bool:\n        digits = list(map(int, str(n)))\n        power = len(digits)\n        total = 0\n        for d in digits:\n            total += d ** power\n        return total == n",
        "public_test_path": "/id/public/armstrong-number-108",
        "hidden_test_path": "/id/hidden/armstrong-number-108",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 46
    },
    {
        "problem_id": "perfect-number-109",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Perfect Number",
        "description": "## Perfect Number\n**Kiểm tra một số nguyên dương n có phải là số hoàn hảo hay không. Số hoàn hảo là số có tổng các ước đúng bằng chính nó.**\n- **Input:** một số nguyên dương n\n- **Output:** boolean (true nếu n là số hoàn hảo, false nếu không)\n- **Example:** n=28 → true, n=12 → false\n- **Constraints:** Sử dụng vòng lặp và rẽ nhánh.",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def isPerfect(self, n: int) -> bool:\n        if n <= 1:\n            return False\n        divisor_sum = 1\n        for i in range(2, n // 2 + 1):\n            if n % i == 0:\n                divisor_sum += i\n        return divisor_sum == n",
        "public_test_path": "/id/public/perfect-number-109",
        "hidden_test_path": "/id/hidden/perfect-number-109",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 26
    },
    {
        "problem_id": "generalized-armstrong-number-110",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Generalized Armstrong Number",
        "description": "## Generalized Armstrong Number\n**Kiểm tra một số nguyên dương n có phải là số Armstrong tổng quát với số mũ p cho trước không.**\n- **Input:** hai số nguyên dương n, p\n- **Output:** boolean (true nếu tổng các chữ số mũ p bằng n, false nếu không)\n- **Example:** n=153, p=3 → true, n=9474, p=4 → true, n=9475, p=4 → false\n- **Constraints:** Sử dụng vòng lặp và rẽ nhánh.",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def isGeneralizedArmstrong(self, n: int, p: int) -> bool:\n        digits = list(map(int, str(n)))\n        total = 0\n        for d in digits:\n            total += d ** p\n        return total == n",
        "public_test_path": "/id/public/generalized-armstrong-number-110",
        "hidden_test_path": "/id/hidden/generalized-armstrong-number-110",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 37
    },
    {
        "problem_id": "special-number-count-113",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Count Special Numbers",
        "description": "## Count Special Numbers\n**Tính số lượng các số nguyên dương có ít nhất một chữ số 7 và tổng chữ số chia hết cho 5 trong phạm vi từ 1 đến n.**\n- **Input:** một số nguyên dương n\n- **Output:** số lượng các số thỏa mãn điều kiện\n- **Example:** n=100 → số lượng phù hợp\n- **Constraints:** Sử dụng vòng lặp, rẽ nhánh, kết hợp thuật toán tổ hợp để tối ưu.\n",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def countSpecialNumbers(self, n: int) -> int:\n        count = 0\n        for num in range(1, n + 1):\n            s = str(num)\n            sum_digits = sum(int(d) for d in s)\n            if '7' in s and sum_digits % 5 == 0:\n                count += 1\n        return count",
        "public_test_path": "/id/public/special-number-count-113",
        "hidden_test_path": "/id/hidden/special-number-count-113",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "symmetric-digit-check-115",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Symmetric Digit Check",
        "description": "## Symmetric Digit Check\n**Kiểm tra một số nguyên dương n có phải là số đối xứng (palindrome) và tất cả các chữ số của nó đều thuộc một tập hợp chữ số cho trước không.**\n- **Input:** một số nguyên dương n, một danh sách các chữ số hợp lệ\n- **Output:** boolean (true nếu thỏa mãn, false nếu không)\n- **Example:** n=1221, digits=[1,2] → true; n=12321, digits=[1,2,3] → true; n=1231, digits=[1,2,3] → false\n- **Constraints:** Sử dụng vòng lặp, rẽ nhánh và thao tác danh sách.",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def isSymmetricDigitsInSet(self, n: int, digits: list[int]) -> bool:\n        s = str(n)\n        if s != s[::-1]:\n            return False\n        allowed = set(digits)\n        for ch in s:\n            if int(ch) not in allowed:\n                return False\n        return True",
        "public_test_path": "/id/public/symmetric-digit-check-115",
        "hidden_test_path": "/id/hidden/symmetric-digit-check-115",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 24
    },
    {
        "problem_id": "valid-pin-check-116",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Valid PIN Check",
        "description": "## Valid PIN Check\n**Kiểm tra xem một mã PIN gồm 4 chữ số có hợp lệ không theo các quy tắc:\n- Không có chữ số nào lặp lại liên tiếp\n- Tổng các chữ số phải chẵn\n- Mã PIN phải bắt đầu bằng số lẻ**\n- **Input:** một số nguyên n có 4 chữ số\n- **Output:** boolean (true nếu hợp lệ, false nếu không)\n- **Example:** n=1352 → true, n=1332 → false\n- **Constraints:** Sử dụng vòng lặp và rẽ nhánh để kiểm tra từng quy tắc.",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def isValidPIN(self, n: int) -> bool:\n        s = str(n)\n        if len(s) != 4:\n            return False\n        if int(s[0]) % 2 == 0:\n            return False\n        total = 0\n        for i in range(4):\n            total += int(s[i])\n            if i > 0 and s[i] == s[i-1]:\n                return False\n        if total % 2 != 0:\n            return False\n        return True",
        "public_test_path": "/id/public/valid-pin-check-116",
        "hidden_test_path": "/id/hidden/valid-pin-check-116",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 30
    },
    {
        "problem_id": "secure-password-check-117",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Secure Password Check",
        "description": "## Secure Password Check\n**Kiểm tra một chuỗi password có hợp lệ để sử dụng hay không theo các quy tắc:\n- Độ dài từ 8 đến 20 ký tự\n- Có ít nhất một chữ cái in hoa\n- Có ít nhất một chữ cái in thường\n- Có ít nhất một chữ số\n- Có ít nhất một ký tự đặc biệt trong {'!', '@', '#', '$', '%', '^', '&', '*'}\n- Không có khoảng trắng**\n- **Input:** một chuỗi password\n- **Output:** boolean (true nếu hợp lệ, false nếu không)\n- **Constraints:** Sử dụng vòng lặp và rẽ nhánh.",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def isSecurePassword(self, password: str) -> bool:\n        if len(password) < 8 or len(password) > 20:\n            return False\n        has_upper = has_lower = has_digit = has_special = False\n        special_chars = {'!', '@', '#', '$', '%', '^', '&', '*'}\n        for ch in password:\n            if ch.isspace():\n                return False\n            if ch.isupper():\n                has_upper = True\n            elif ch.islower():\n                has_lower = True\n            elif ch.isdigit():\n                has_digit = True\n            elif ch in special_chars:\n                has_special = True\n        return has_upper and has_lower and has_digit and has_special",
        "public_test_path": "/id/public/secure-password-check-117",
        "hidden_test_path": "/id/hidden/secure-password-check-117",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "digital-root-118",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Digital Root",
        "description": "## Digital Root\n**Tính digital root của một số nguyên dương n. Digital root là tổng các chữ số của n, sau đó nếu kết quả có nhiều hơn 1 chữ số thì tiếp tục tính tổng các chữ số đó cho đến khi được số có một chữ số.**\n- **Input:** một số nguyên dương n\n- **Output:** số nguyên một chữ số là digital root\n- **Example:** n=38 → 3+8=11 → 1+1=2 → output=2\n- **Constraints:** Sử dụng vòng lặp và rẽ nhánh.",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def digitalRoot(self, n: int) -> int:\n        while n >= 10:\n            total = 0\n            while n > 0:\n                total += n % 10\n                n //= 10\n            n = total\n        return n",
        "public_test_path": "/id/public/digital-root-118",
        "hidden_test_path": "/id/hidden/digital-root-118",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "monotonic-array-119",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Monotonic Array",
        "description": "## Monotonic Array\n**Kiểm tra xem một mảng số nguyên có phải là mảng đơn điệu (tăng dần hoặc giảm dần) hay không.**\n- **Input:** mảng số nguyên nums\n- **Output:** boolean (true nếu đơn điệu, false nếu không)\n- **Example:** [1,2,2,3] → true, [6,5,4] → true, [1,3,2] → false\n- **Constraints:** Sử dụng vòng lặp và rẽ nhánh.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def isMonotonic(self, nums: list[int]) -> bool:\n        increasing = decreasing = True\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i-1]:\n                increasing = False\n            if nums[i] > nums[i-1]:\n                decreasing = False\n        return increasing or decreasing",
        "public_test_path": "/id/public/monotonic-array-119",
        "hidden_test_path": "/id/hidden/monotonic-array-119",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 23
    },
    {
        "problem_id": "count-even-odd-range-120",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Count Even and Odd Digits in Range",
        "description": "## Count Even and Odd Digits in Range\n**Tính tổng số chữ số chẵn và số chữ số lẻ xuất hiện trong tất cả các số nguyên liên tiếp từ start đến end (bao gồm).**\n- **Input:** hai số nguyên dương start, end (start <= end)\n- **Output:** một danh sách chứa hai số: tổng chữ số chẵn và tổng chữ số lẻ trong khoảng\n- **Example:** start=10, end=12 →  chữ số chẵn = 3, chữ số lẻ = 3\n- **Constraints:** Sử dụng vòng lặp và rẽ nhánh, xử lý từng số và từng chữ số.",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def countEvenOddRange(self, start: int, end: int) -> [int, int]:\n        even_count = 0\n        odd_count = 0\n        for num in range(start, end + 1):\n            if num == 0:\n                even_count += 1\n                continue\n            while num > 0:\n                digit = num % 10\n                if digit % 2 == 0:\n                    even_count += 1\n                else:\n                    odd_count += 1\n                num //= 10\n        return [even_count, odd_count]",
        "public_test_path": "/id/public/count-even-odd-range-120",
        "hidden_test_path": "/id/hidden/count-even-odd-range-120",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 25
    },
    {
        "problem_id": "design-file-system-111",
        "topic": "Chương 1",
        "sub_topic": "Hướng đối tượng (OOP – Design)",
        "name": "Design In-Memory File System",
        "description": "### Bài toán\n\nThiết kế hệ thống File System in-memory hỗ trợ các thao tác:\n- ls(path): Liệt kê thư mục hoặc tệp trong đường dẫn.\n- mkdir(path): Tạo thư mục mới.\n- addContentToFile(filePath, content): Thêm nội dung vào tệp.\n- readContentFromFile(filePath): Đọc nội dung tệp.\n\n- **Ràng buộc**: Path hợp lệ và không gian bộ nhớ đủ để lưu dữ liệu.",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class FileSystem:\n    def __init__(self):\n        self.fs = {'/': {\"type\": \"dir\", \"content\": {}}}\n\n    def ls(self, path: str) -> list[str]:\n        node = self._traverse(path)\n        if node[\"type\"] == \"file\":\n            return [path.split('/')[-1]]\n        return sorted(node[\"content\"].keys())\n\n    def mkdir(self, path: str) -> None:\n        self._traverse(path, create=True)\n\n    def addContentToFile(self, filePath: str, content: str) -> None:\n        dir_path = '/'.join(filePath.split('/')[:-1]) or '/'\n        file_name = filePath.split('/')[-1]\n        dir_node = self._traverse(dir_path, create=True)\n        if file_name not in dir_node[\"content\"]:\n            dir_node[\"content\"][file_name] = {\"type\": \"file\", \"content\": \"\"}\n        dir_node[\"content\"][file_name][\"content\"] += content\n\n    def readContentFromFile(self, filePath: str) -> str:\n        node = self._traverse(filePath)\n        if node[\"type\"] == \"file\":\n            return node[\"content\"]\n        return \"\"\n\n    def _traverse(self, path: str, create=False):\n        parts = [p for p in path.split('/') if p]\n        node = self.fs['/']\n        for i, part in enumerate(parts):\n            if part not in node[\"content\"]:\n                if create:\n                    node[\"content\"][part] = {\"type\": \"dir\", \"content\": {}}\n                else:\n                    return None\n            node = node[\"content\"][part]\n        return node",
        "public_test_path": "/id/public/design-file-system-111",
        "hidden_test_path": "/id/hidden/design-file-system-111",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "simple-string-hash-122",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Simple String Hash",
        "description": "### Bài toán\n\nViết hàm tính giá trị băm đơn giản cho một chuỗi ký tự: mã băm được tính bằng tổng mã ASCII của các ký tự modulo 10^9+7.\n\n- **Input**: một chuỗi ký tự\n- **Output**: số nguyên là giá trị băm của chuỗi\n- **Ví dụ**:\n  - \"abc\" -> (97 + 98 + 99) % 1000000007 = 294\n  - \"\" -> 0\n- **Ràng buộc**: độ dài chuỗi ≤ 10^6",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def simpleStringHash(s):\n    MOD = 10**9 + 7\n    total = 0\n    for ch in s:\n        total = (total + ord(ch)) % MOD\n    return total",
        "public_test_path": "/id/public/simple-string-hash-122",
        "hidden_test_path": "/id/hidden/simple-string-hash-122",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 60
    },
    {
        "problem_id": "convert-to-binary-124",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Convert Integer to Binary String",
        "description": "### Bài toán\n\nViết hàm nhận vào một số nguyên không âm n, trả về chuỗi nhị phân của n (không có tiền tố '0b').\n\n- **Input**: số nguyên không âm n\n- **Output**: chuỗi nhị phân tương ứng\n- **Ví dụ**:\n  - 6 -> \"110\"\n  - 0 -> \"0\"\n- **Ràng buộc**: 0 ≤ n ≤ 10^9",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def intToBinary(n):\n    return bin(n)[2:]",
        "public_test_path": "/id/public/convert-to-binary-124",
        "hidden_test_path": "/id/hidden/convert-to-binary-124",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 17
    },
    {
        "problem_id": "find-common-elements-125",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Find Common Elements in Two Lists",
        "description": "### Bài toán\n\nViết hàm nhận vào hai danh sách số nguyên, trả về một danh sách chứa các phần tử xuất hiện trong cả hai danh sách (không trùng lặp, thứ tự bất kỳ).\n\n- **Input**: hai danh sách số nguyên\n- **Output**: danh sách các phần tử chung\n- **Ví dụ**:\n  - [1, 2, 3], [3, 4, 5] -> [3]\n  - [4, 4, 4, 5], [4, 5, 6] -> [4, 5]\n- **Ràng buộc**: độ dài mỗi danh sách ≤ 10^5",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def findCommonElements(lst1, lst2):\n    return list(set(lst1) & set(lst2))",
        "public_test_path": "/id/public/find-common-elements-125",
        "hidden_test_path": "/id/hidden/find-common-elements-125",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 18
    },
    {
        "problem_id": "min-digit-prime-sum-121",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Minimum Number with Prime Digit Sum",
        "description": "## Minimum Number with Prime Digit Sum\n**Tìm số nhỏ nhất trong đoạn [start, end] mà tổng các chữ số là số nguyên tố. Nếu không tồn tại, trả về -1.**\n- **Input:** hai số nguyên dương start và end (start <= end)\n- **Output:** số nhỏ nhất thỏa mãn hoặc -1 nếu không có\n- **Example:** start=10, end=15 → 11 (do 1+1=2 là số nguyên tố)\n- **Constraints:** Sử dụng vòng lặp và rẽ nhánh.",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def minNumberWithPrimeDigitSum(self, start: int, end: int) -> int:\n        def is_prime(x):\n            if x < 2:\n                return False\n            for i in range(2, int(x**0.5)+1):\n                if x % i == 0:\n                    return False\n            return True\n        for num in range(start, end+1):\n            total = sum(int(d) for d in str(num))\n            if is_prime(total):\n                return num\n        return -1",
        "public_test_path": "/id/public/min-digit-prime-sum-121",
        "hidden_test_path": "/id/hidden/min-digit-prime-sum-121",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 25
    },
    {
        "problem_id": "sum-even-fibonacci-range-122",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Sum Even Fibonacci in Range",
        "description": "## Sum Even Fibonacci in Range\n**Tính tổng các số Fibonacci chẵn nằm trong khoảng [start, end].**\n- **Input:** hai số nguyên dương start và end (start <= end)\n- **Output:** tổng các số Fibonacci chẵn trong khoảng\n- **Example:** start=1, end=10 → 10 (2+8)\n- **Constraints:** Sử dụng vòng lặp và rẽ nhánh.",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def sumEvenFibonacci(self, start: int, end: int) -> int:\n        a, b = 0, 1\n        total = 0\n        while b <= end:\n            if b >= start and b % 2 == 0:\n                total += b\n            a, b = b, a + b\n        return total",
        "public_test_path": "/id/public/sum-even-fibonacci-range-122",
        "hidden_test_path": "/id/hidden/sum-even-fibonacci-range-122",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "consecutive-digit-repeat-123",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Consecutive Digit Repeat",
        "description": "## Consecutive Digit Repeat\n**Kiểm tra xem một số nguyên dương n có chứa ít nhất một chữ số lặp lại liên tiếp không.**\n- **Input:** một số nguyên dương n\n- **Output:** boolean (true nếu có chữ số lặp liên tiếp, false nếu không)\n- **Example:** n=1223 → true, n=1234 → false\n- **Constraints:** Sử dụng vòng lặp và rẽ nhánh.",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def hasConsecutiveRepeat(self, n: int) -> bool:\n        s = str(n)\n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                return True\n        return False",
        "public_test_path": "/id/public/consecutive-digit-repeat-123",
        "hidden_test_path": "/id/hidden/consecutive-digit-repeat-123",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "consecutive-digit-repeat-123",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Consecutive Digit Repeat",
        "description": "## Consecutive Digit Repeat\n**Kiểm tra xem một số nguyên dương n có chứa ít nhất một chữ số lặp lại liên tiếp không.**\n- **Input:** một số nguyên dương n\n- **Output:** boolean (true nếu có chữ số lặp liên tiếp, false nếu không)\n- **Example:** n=1223 → true, n=1234 → false\n- **Constraints:** Sử dụng vòng lặp và rẽ nhánh.",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def hasConsecutiveRepeat(self, n: int) -> bool:\n        s = str(n)\n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                return True\n        return False",
        "public_test_path": "/id/public/consecutive-digit-repeat-123",
        "hidden_test_path": "/id/hidden/consecutive-digit-repeat-123",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "divisible-by-2-3-5-124",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Divisible by 2, 3 and 5",
        "description": "## Divisible by 2, 3 and 5\n**Kiểm tra xem số nguyên dương n có chia hết đồng thời cho 2, 3 và 5 hay không.**\n- **Input:** một số nguyên dương n\n- **Output:** boolean (true nếu chia hết cho cả 3 số, false nếu không)\n- **Example:** n=30 → true, n=20 → false\n- **Constraints:** Sử dụng rẽ nhánh và vòng lặp nếu cần.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def isDivisibleBy235(self, n: int) -> bool:\n        if n % 2 != 0:\n            return False\n        if n % 3 != 0:\n            return False\n        if n % 5 != 0:\n            return False\n        return True",
        "public_test_path": "/id/public/divisible-by-2-3-5-124",
        "hidden_test_path": "/id/hidden/divisible-by-2-3-5-124",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 40
    },
    {
        "problem_id": "count-unique-chars-126",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Count Unique Characters in String",
        "description": "### Bài toán\n\nViết hàm đếm số lượng ký tự duy nhất trong một chuỗi.\n\n- **Input**: một chuỗi\n- **Output**: số nguyên đại diện số ký tự khác nhau\n- **Ví dụ**:\n  - \"hello\" -> 4 (h, e, l, o)\n  - \"aaaa\" -> 1\n- **Ràng buộc**: độ dài chuỗi ≤ 10^5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def countUniqueChars(s):\n    return len(set(s))",
        "public_test_path": "/id/public/count-unique-chars-126",
        "hidden_test_path": "/id/hidden/count-unique-chars-126",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "reverse-words-sentence-127",
        "topic": "Chương 1",
        "sub_topic": "Hàm trong Python",
        "name": "Reverse Words in a Sentence",
        "description": "### Bài toán\n\nViết hàm đảo ngược thứ tự các từ trong một câu (chuỗi).\n\n- **Input**: chuỗi câu chứa các từ cách nhau bởi khoảng trắng\n- **Output**: chuỗi với thứ tự các từ đảo ngược\n- **Ví dụ**:\n  - \"hello world\" -> \"world hello\"\n  - \"the quick brown fox\" -> \"fox brown quick the\"\n- **Ràng buộc**: độ dài chuỗi ≤ 10^5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def reverseWords(s):\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)",
        "public_test_path": "/id/public/reverse-words-sentence-127",
        "hidden_test_path": "/id/hidden/reverse-words-sentence-127",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "valid-binary-and-count-ones-125",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Valid Binary and Count Ones",
        "description": "## Valid Binary and Count Ones\n**Kiểm tra chuỗi có phải là chuỗi nhị phân hợp lệ (chỉ chứa '0' và '1') không, và đếm số lượng bit 1 trong chuỗi đó.**\n- **Input:** một chuỗi ký tự\n- **Output:** số lượng ký tự '1' nếu chuỗi hợp lệ, còn không thì trả về -1\n- **Example:** \"10101\" → 3, \"10201\" → -1\n- **Constraints:** Sử dụng vòng lặp và rẽ nhánh.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def validBinaryAndCountOnes(self, s: str) -> int:\n        count_ones = 0\n        for ch in s:\n            if ch not in {'0', '1'}:\n                return -1\n            if ch == '1':\n                count_ones += 1\n        return count_ones",
        "public_test_path": "/id/public/valid-binary-and-count-ones-125",
        "hidden_test_path": "/id/hidden/valid-binary-and-count-ones-125",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "digit-sum-divisible-number-126",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh và Vòng lặp",
        "name": "Digit Sum Divisible Number",
        "description": "## Digit Sum Divisible Number\n**Kiểm tra một số nguyên dương n có tính chất số hoàn hảo về chữ số: tổng các chữ số của nó chia hết cho chính nó.**\n- **Input:** một số nguyên dương n\n- **Output:** boolean (true nếu thỏa mãn, false nếu không)\n- **Example:** n=12 (1+2=3, 12 không chia hết cho 3 → false), n=21 (2+1=3, 21 chia hết cho 3 → true)\n- **Constraints:** Sử dụng vòng lặp và rẽ nhánh.",
        "difficulty": 3,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Solution:\n    def isDigitSumDivisible(self, n: int) -> bool:\n        total = 0\n        temp = n\n        while temp > 0:\n            total += temp % 10\n            temp //= 10\n        return n % total == 0",
        "public_test_path": "/id/public/digit-sum-divisible-number-126",
        "hidden_test_path": "/id/hidden/digit-sum-divisible-number-126",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 40
    },
    {
        "problem_id": "excel-sheet-column-title",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Excel Sheet Column Title",
        "description": "### Tiêu Đề Cột Trong Excel\n\nCho một số nguyên columnNumber, trả về tiêu đề cột tương ứng như trong bảng tính Excel.\n\nVí dụ:\n\n- A -> 1\n- B -> 2\n- C -> 3\n- ...\n- Z -> 26\n- AA -> 27\n- AB -> 28\n- ...",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def convertToTitle(self, columnNumber: int) -> str:\n        ans = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            ans += chr(columnNumber % 26 + ord(\"A\"))\n            columnNumber //= 26\n\n        return ans[::-1]",
        "public_test_path": "/id/public/excel-sheet-column-title",
        "hidden_test_path": "/id/hidden/excel-sheet-column-title",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "excel-sheet-column-number",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Excel Sheet Column Number",
        "description": "Cho một chuỗi `columnTitle` biểu diễn tiêu đề cột trong Excel, hãy trả về số thứ tự tương ứng của cột đó. Ví dụ: A -> 1 \n B -> 2 \n C -> 3 \n ... \n Z -> 26 \n AA -> 27 \n AB -> 28 \n ...",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def titleToNumber(self, columnTitle):\n    result = 0\n    for char in columnTitle:\n        result = result * 26 + (ord(char) - 64)\n    return result",
        "public_test_path": "/id/public/excel-sheet-column-number",
        "hidden_test_path": "/id/hidden/excel-sheet-column-number",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "first-letter-to-appear-twice",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "First Letter to Appear Twice",
        "description": "**First Letter to Appear Twice** Cho một chuỗi `s` gồm các chữ cái tiếng Anh viết thường, hãy trả về chữ cái đầu tiên xuất hiện hai lần. Lưu ý: Một chữ cái `a` được coi là xuất hiện hai lần trước một chữ cái `b` nếu lần xuất hiện thứ hai của `a` xảy ra trước lần xuất hiện thứ hai của `b`. Chuỗi `s` sẽ luôn chứa ít nhất một chữ cái xuất hiện hai lần.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def repeatedCharacter(self, s: str) -> str:\n    sett = set()\n    for i in s:\n        if i not in sett:\n            sett.add(i)\n        else:\n            return i",
        "public_test_path": "/id/public/first-letter-to-appear-twice",
        "hidden_test_path": "/id/hidden/first-letter-to-appear-twice",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "reverse-only-letters",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Reverse Only Letters",
        "description": "**Reverse Only Letters**: Cho một chuỗi `s`, hãy đảo ngược chuỗi theo các quy tắc sau: \n Các ký tự không phải chữ cái tiếng Anh giữ nguyên vị trí. \n Tất cả chữ cái tiếng Anh (viết thường hoặc viết hoa) sẽ được đảo ngược. \n Trả về chuỗi `s` sau khi đảo ngược.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def reverseOnlyLetters(self, S):\n    ans = []\n    j = len(ans) - 1\n    for i, x in enumerate(S):\n        if x.isalpha():\n            while not S[j].isalpha():\n                j -= 1\n            ans.append(S[j])\n            j -= 1\n        else:\n            ans.append(x)\n    \n    return \"\".join(ans)",
        "public_test_path": "/id/public/reverse-only-letters",
        "hidden_test_path": "/id/hidden/reverse-only-letters",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "rotate-string",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Rotate String",
        "description": "**Rotate String** Cho hai chuỗi `s` và `goal`, trả về `true` nếu và chỉ nếu `s` có thể trở thành `goal` sau một số lần dịch chuyển ký tự của `s`. Một lần dịch chuyển trên `s` được định nghĩa là đưa ký tự bên trái nhất của `s` sang cuối cùng. Ví dụ: nếu `s = \"abcde\", sau một lần dịch chuyển nó sẽ trở thành \"bcdea\". ",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def rotateString(self, s: str, goal: str) -> bool:\n    if len(s) != len(goal):\n        return False\n\n    doubled_string = s + s\n\n    return doubled_string.find(goal) != -1",
        "public_test_path": "/id/public/rotate-string",
        "hidden_test_path": "/id/hidden/rotate-string",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "consecutive-characters",
        "topic": "Chương 1",
        "sub_topic": "",
        "name": "Consecutive Characters",
        "description": "**Consecutive Characters**: Sức mạnh của chuỗi được định nghĩa là độ dài lớn nhất của một chuỗi con không rỗng chỉ chứa duy nhất một ký tự. Cho một chuỗi `s`, hãy trả về sức mạnh của `s`.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def titleToNumber(self, columnTitle):\n    result = 0\n    for char in columnTitle:\n        result = result * 26 + (ord(char) - 64)\n    return result",
        "public_test_path": "/id/public/consecutive-characters",
        "hidden_test_path": "/id/hidden/consecutive-characters",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 50
    },
    {
        "problem_id": "remove-all-adjacent-duplicates-in-string",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Remove All Adjacent Duplicates In String",
        "description": "**Remove All Adjacent Duplicates In String**: Cho một chuỗi `s` gồm các chữ cái thường trong tiếng Anh. Một lần loại bỏ trùng lặp là chọn hai ký tự liền kề và giống nhau rồi xóa chúng. Ta lặp lại việc loại bỏ cho đến khi không thể tiếp tục. Trả về chuỗi cuối cùng sau khi tất cả các lần loại bỏ hoàn tất. Có thể chứng minh rằng kết quả là duy nhất.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def removeDuplicates(self, S):\n    res = []\n    for c in S:\n        if res and res[-1] == c:\n            res.pop()\n        else:\n            res.append(c)\n    return \"\".join(res)",
        "public_test_path": "/id/public/remove-all-adjacent-duplicates-in-string",
        "hidden_test_path": "/id/hidden/remove-all-adjacent-duplicates-in-string",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 17
    },
    {
        "problem_id": "remove-all-adjacent-duplicates-in-string-ii",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Remove All Adjacent Duplicates in String II",
        "description": "**Remove All Adjacent Duplicates in String II**\nCho một chuỗi `s` và một số nguyên `k`, một phép loại bỏ trùng lặp k bao gồm việc chọn `k` ký tự liên tiếp và giống nhau trong `s` rồi xóa chúng, khiến phần bên trái và bên phải của đoạn bị xóa nối lại với nhau.\nLặp lại quá trình loại bỏ trùng lặp k cho đến khi không thể thực hiện thêm.\nTrả về chuỗi cuối cùng sau tất cả các lần loại bỏ. Đáp án được đảm bảo là duy nhất.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def removeDuplicates(self, s, k):\n    stack = [['#', 0]]\n    for c in s:\n        if stack[-1][0] == c:\n            stack[-1][1] += 1\n            if stack[-1][1] == k:\n                stack.pop()\n        else:\n            stack.append([c, 1])\n    return ''.join(c * k for c, k in stack)",
        "public_test_path": "/id/public/remove-all-adjacent-duplicates-in-string-ii",
        "hidden_test_path": "/id/hidden/remove-all-adjacent-duplicates-in-string-ii",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "reverse-vowels-of-a-string",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Reverse Vowels of a String",
        "description": "**Reverse Vowels of a String**: Cho một chuỗi `s`, chỉ đảo ngược các nguyên âm trong chuỗi và trả về kết quả. Nguyên âm là 'a', 'e', 'i', 'o', 'u', có thể xuất hiện cả chữ thường và chữ hoa, và có thể xuất hiện nhiều lần.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def reverseVowels(self, s):\n    word = list(s)\n    start = 0\n    end = len(s) - 1\n    vowels = \"aeiouAEIOU\"\n    \n    while start < end:\n        while start < end and vowels.find(word[start]) == -1:\n            start += 1\n        \n        while start < end and vowels.find(word[end]) == -1:\n            end -= 1\n        \n        word[start], word[end] = word[end], word[start]\n        \n        start += 1\n        end -= 1\n    \n    return \"\".join(word)",
        "public_test_path": "/id/public/reverse-vowels-of-a-string",
        "hidden_test_path": "/id/hidden/reverse-vowels-of-a-string",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "most-common-word",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Most Common Word",
        "description": "**Most Common Word**\n Cho một chuỗi `paragraph` và một mảng chuỗi `banned` chứa các từ bị cấm, hãy trả về từ xuất hiện nhiều nhất mà không bị cấm. Đảm bảo rằng ít nhất có một từ không bị cấm và kết quả là duy nhất. Các từ trong `paragraph` không phân biệt hoa thường và kết quả trả về phải viết thường. Lưu ý rằng các từ không được chứa ký tự dấu câu.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\n        normalized_str = ''.join([c.lower() if c.isalnum() else ' ' for c in paragraph])\n\n        words = normalized_str.split()\n\n        word_count = defaultdict(int)\n        banned_words = set(banned)\n\n        for word in words:\n            if word not in banned_words:\n                word_count[word] += 1\n\n        return max(word_count.items(), key=operator.itemgetter(1))[0]",
        "public_test_path": "/id/public/most-common-word",
        "hidden_test_path": "/id/hidden/most-common-word",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "final-value-of-variable-after-performing-operations",
        "topic": "Chương 1",
        "sub_topic": "Biến và Kiểu dữ liệu",
        "name": "Final Value of Variable After Performing Operations",
        "description": "**Final Value of Variable After Performing Operations**\nCó một ngôn ngữ lập trình chỉ có bốn phép toán và một biến X:\n++X và X++ tăng giá trị của biến X lên 1.\n--X và X-- giảm giá trị của biến X đi 1.\nBan đầu, giá trị của X là 0.\nCho một mảng các chuỗi `operations` chứa danh sách các phép toán, hãy trả về giá trị cuối cùng của X sau khi thực hiện tất cả các phép toán.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def finalValueAfterOperations(self, operations: List[str]) -> int:\n        op_dict = {\"--X\" : -1, \"X--\" : -1, \"++X\" : 1, \"X++\" : 1}\n        return sum(op_dict[op] for op in operations)",
        "public_test_path": "/id/public/final-value-of-variable-after-performing-operations",
        "hidden_test_path": "/id/hidden/final-value-of-variable-after-performing-operations",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "change-data-type",
        "topic": "Chương 1",
        "sub_topic": "Biến và Kiểu dữ liệu",
        "name": "Change Data Type",
        "description": "**Change Data Type**\n**DataFrame students**\n+-------------+--------+\n| Column Name | Type   |\n+-------------+--------+\n| student_id  | int    |\n| name        | object |\n| age         | int    |\n| grade       | float  |\n+-------------+--------+\nViết một giải pháp để sửa lỗi:\nCột grade hiện đang là float, hãy chuyển nó sang int.\nĐịnh dạng kết quả giống ví dụ sau.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import pandas as pd\n\ndef changeDatatype(students: pd.DataFrame) -> pd.DataFrame:\n    students = students.astype({'grade': int})\n    return students",
        "public_test_path": "/id/public/change-data-type",
        "hidden_test_path": "/id/hidden/change-data-type",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 19
    },
    {
        "problem_id": "top-k-frequent-elements",
        "topic": "Chương 1",
        "sub_topic": "Biến và Kiểu dữ liệu",
        "name": "Top K Frequent Elements",
        "description": "**Top K Frequent Elements**\n Cho một mảng số nguyên `nums` và một số nguyên `k`, hãy trả về `k` phần tử xuất hiện nhiều nhất. Bạn có thể trả lời theo bất kỳ thứ tự nào.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def topKFrequent(self, nums, k):\n    from collections import Counter\n    count = Counter(nums)\n    bucket = [[] for _ in range(len(nums) + 1)]\n    for num, freq in count.items():\n        bucket[freq].append(num)\n    res = []\n    for i in range(len(nums), 0, -1):\n        for num in bucket[i]:\n            res.append(num)\n            if len(res) == k:\n                return res",
        "public_test_path": "/id/public/top-k-frequent-elements",
        "hidden_test_path": "/id/hidden/top-k-frequent-elements",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "decode-string",
        "topic": "Chương 1",
        "sub_topic": "Biến và Kiểu dữ liệu",
        "name": "Decode String",
        "description": "**Decode String**\nCho một chuỗi được mã hóa, hãy trả về chuỗi đã giải mã.\nQuy tắc mã hóa: k[encoded_string], trong đó encoded_string bên trong dấu ngoặc vuông sẽ được lặp đúng k lần. Lưu ý rằng k luôn là số nguyên dương.\nBạn có thể giả sử rằng chuỗi đầu vào luôn hợp lệ; không có khoảng trắng thừa, dấu ngoặc vuông được viết đúng, v.v. Hơn nữa, bạn có thể giả sử dữ liệu gốc không chứa chữ số và các chữ số chỉ dùng cho số lần lặp k. Ví dụ, sẽ không có đầu vào như 3a hoặc 2[4].\nCác test case được tạo sao cho độ dài kết quả đầu ra không bao giờ vượt quá 10^5.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def decodeString(self, s: str) -> str:\n        stack = []\n\n        for char in s:\n            if char != \"]\":\n                stack.append(char)\n                \n            else: \n                curr_str = \"\"\n                while stack[-1] != \"[\":\n                    curr_str = stack.pop() + curr_str\n                stack.pop()\n\n                curr_num = \"\"\n                while stack and stack[-1].isdigit():\n                    curr_num = stack.pop() + curr_num\n                \n                curr_str = int(curr_num) * curr_str\n                stack.append(curr_str)\n\n        return \"\".join(stack)",
        "public_test_path": "/id/public/decode-string",
        "hidden_test_path": "/id/hidden/decode-string",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "isomorphic-strings",
        "topic": "Chương 1",
        "sub_topic": "Biến và Kiểu dữ liệu",
        "name": "Isomorphic Strings",
        "description": "**Isomorphic Strings**\nCho hai chuỗi `s` và `t`, xác định xem chúng có phải là các chuỗi đồng cấu hay không.\nHai chuỗi `s` và `t` được gọi là đồng cấu nếu các ký tự trong `s` có thể được thay thế để tạo ra `t`.\nMọi ký tự trong `s` phải được thay thế bởi một ký tự khác trong `t` mà vẫn giữ nguyên thứ tự các ký tự.\nKhông có hai ký tự nào được ánh xạ tới cùng một ký tự, nhưng một ký tự có thể ánh xạ chính nó.\n",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def isIsomorphic(self, s: str, t: str) -> bool:\n        char_index_s = {}\n        char_index_t = {}\n\n        for i in range(len(s)):\n            if s[i] not in char_index_s:\n                char_index_s[s[i]] = i\n\n            if t[i] not in char_index_t:\n                char_index_t[t[i]] = i\n            \n            if char_index_s[s[i]] != char_index_t[t[i]]:\n                return False\n\n        return True",
        "public_test_path": "/id/public/isomorphic-strings",
        "hidden_test_path": "/id/hidden/isomorphic-strings",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "evaluate-reverse-polish-notation",
        "topic": "Chương 1",
        "sub_topic": "Biến và Kiểu dữ liệu",
        "name": "Evaluate Reverse Polish Notation",
        "description": "**Evaluate Reverse Polish Notation**\nBạn được cho một mảng các chuỗi `tokens` biểu diễn một biểu thức số học theo **Reverse Polish Notation**.\nHãy đánh giá biểu thức và trả về một số nguyên đại diện cho giá trị của biểu thức.\nLưu ý:\n- Các toán tử hợp lệ là '+', '-', '*', và '/'.\n- Mỗi toán hạng có thể là một số nguyên hoặc một biểu thức khác.\n- Phép chia giữa hai số nguyên luôn làm tròn về 0.\n- Không có phép chia nào cho 0.\n- Đầu vào đại diện cho một biểu thức số học hợp lệ theo Reverse Polish Notation.\n- Kết quả và tất cả các phép tính trung gian có thể được biểu diễn bằng số nguyên 32-bit.\n",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def resolves(self, a, b, Operator):\n    if Operator == '+':\n        return a + b\n    elif Operator == '-':\n        return a - b\n    elif Operator == '*':\n        return a * b\n    return int(a / b)\n\n\ndef evalRPN(self, tokens):\n    stack = []\n    for token in tokens:\n        if len(token) == 1 and ord(token) < 48:\n            integer2 = stack.pop()\n            integer1 = stack.pop()\n            operator = token\n            resolved_ans = self.resolves(integer1, integer2, operator)\n            stack.append(resolved_ans)\n        else:\n            stack.append(int(token))\n    return stack.pop()",
        "public_test_path": "/id/public/evaluate-reverse-polish-notation",
        "hidden_test_path": "/id/hidden/evaluate-reverse-polish-notation",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 23
    },
    {
        "problem_id": "reverse-words-in-a-string-iii",
        "topic": "Chương 1",
        "sub_topic": "Biến và Kiểu dữ liệu",
        "name": "Reverse Words in a String III",
        "description": "**Đảo Ngược Từng Từ Trong Chuỗi III**\n Cho một chuỗi `s`, đảo ngược thứ tự ký tự trong từng từ của câu trong khi vẫn giữ nguyên khoảng trắng và thứ tự từ ban đầu.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def reverseWords(self, s: str) -> str:\n        result = []\n        last_space_index = -1\n\n        for str_index in range(len(s)):\n            if str_index == len(s) - 1 or s[str_index] == ' ':\n                reverse_str_index = str_index if str_index == len(s) - 1 else str_index - 1\n                while reverse_str_index > last_space_index:\n                    result.append(s[reverse_str_index])\n                    reverse_str_index -= 1\n                if str_index != len(s) - 1:\n                    result.append(' ')\n                last_space_index = str_index\n\n        return ''.join(result)",
        "public_test_path": "/id/public/reverse-words-in-a-string-iii",
        "hidden_test_path": "/id/hidden/reverse-words-in-a-string-iii",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "max-consecutive-ones",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Max Consecutive Ones",
        "description": "**Max Consecutive Ones**\nCho một mảng nhị phân `nums`, hãy trả về số lượng lớn nhất các số 1 liên tiếp trong mảng.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def findMaxConsecutiveOnes(self, nums):\n    maxi = result = 0\n    \n    for num in nums:\n        if num == 1:\n            result += 1\n            maxi = max(maxi, result)\n        else:\n            result = 0\n    return maxi",
        "public_test_path": "/id/public/max-consecutive-ones",
        "hidden_test_path": "/id/hidden/max-consecutive-ones",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "majority-element",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Majority Element",
        "description": "**Majority Element**\nCho một mảng `nums` có kích thước `n`, hãy trả về phần tử chiếm đa số.\nPhần tử chiếm đa số là phần tử xuất hiện nhiều hơn ⌊n / 2⌋ lần. Bạn có thể giả sử rằng phần tử chiếm đa số luôn tồn tại trong mảng.\n",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def majorityElement(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        return nums[n//2]",
        "public_test_path": "/id/public/majority-element",
        "hidden_test_path": "/id/hidden/majority-element",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "summary-ranges",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Summary Ranges",
        "description": "**Summary Ranges**\nBạn được cho một mảng số nguyên `nums` đã được sắp xếp và các phần tử là duy nhất.\nMột phạm vi [a,b] là tập hợp tất cả các số nguyên từ a đến b (bao gồm cả a và b).\nHãy trả về danh sách các phạm vi nhỏ nhất đã được sắp xếp mà bao phủ tất cả các số trong mảng chính xác. Tức là, mỗi phần tử trong `nums` được bao phủ bởi đúng một phạm vi, và không tồn tại số nguyên x nào nằm trong một phạm vi nhưng không có trong `nums`.\nMỗi phạm vi [a,b] trong danh sách nên được xuất ra dưới dạng:\n\"a->b\" nếu a != b\n\"a\" nếu a == b",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from typing import List\n\ndef summaryRanges(self, nums: List[int]) -> List[str]:\n        if not nums:\n            return []\n            \n        result = []\n        i = 0\n        while i < len(nums):\n            start = nums[i]\n            j = i\n            while j + 1 < len(nums) and nums[j + 1] == nums[j] + 1:\n                j += 1\n            \n            if nums[j] == start:\n                result.append(str(start))\n            else:\n                result.append(f\"{start}->{nums[j]}\")\n            \n            i = j + 1\n        return result",
        "public_test_path": "/id/public/summary-ranges",
        "hidden_test_path": "/id/hidden/summary-ranges",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "missing-number",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Missing Number",
        "description": "**Missing Number**\nCho một mảng `nums` chứa n số khác nhau trong khoảng [0, n], hãy trả về số duy nhất trong khoảng này mà bị thiếu trong mảng.\nVí dụ: nums = [3,0,1] -> 2 \n nums = [0,1] -> 2 \n nums = [9,6,4,2,3,5,7,0,1] -> 8 \n ...",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def missingNumber(self, nums: List[int]) -> int:\n        n = len(nums)\n        v = [-1] * (n + 1)\n        for num in nums:\n            v[num] = num\n        for i in range(len(v)):\n            if v[i] == -1:\n                return i\n        return 0",
        "public_test_path": "/id/public/missing-number",
        "hidden_test_path": "/id/hidden/missing-number",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "intersection-of-two-arrays",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Intersection of Two Arrays",
        "description": "**Intersection of Two Arrays**\nCho hai mảng số nguyên `nums1` và `nums2`, hãy trả về một mảng chứa các phần tử giao nhau của chúng. Mỗi phần tử trong kết quả phải duy nhất và bạn có thể trả kết quả theo bất kỳ thứ tự nào.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def set_intersection(self, set1, set2):\n        return [x for x in set1 if x in set2]\n        \ndef intersection(self, nums1, nums2):\n        set1 = set(nums1)\n        set2 = set(nums2)\n        \n        if len(set1) < len(set2):\n            return self.set_intersection(set1, set2)\n        else:\n            return self.set_intersection(set2, set1)",
        "public_test_path": "/id/public/intersection-of-two-arrays",
        "hidden_test_path": "/id/hidden/intersection-of-two-arrays",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "intersection-of-two-arrays-ii",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Intersection of Two Arrays II",
        "description": "**Giao của Hai Mảng**\n Cho hai mảng số nguyên `nums1` và `nums2`, hãy trả về một mảng chứa các phần tử xuất hiện trong cả hai mảng. Mỗi phần tử trong kết quả phải xuất hiện đúng số lần nó xuất hiện trong cả hai mảng và bạn có thể trả về kết quả theo bất kỳ thứ tự nào.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n    sortedArr1 = sorted(nums1)\n    sortedArr2 = sorted(nums2)\n    i = 0\n    j = 0\n    output = []\n    while i < len(sortedArr1) and j < len(sortedArr2):\n        if sortedArr1[i] < sortedArr2[j]:\n            i += 1\n        elif sortedArr2[j] < sortedArr1[i]:\n            j += 1\n        else:\n            output.append(sortedArr1[i])\n            i += 1\n            j += 1\n    return output",
        "public_test_path": "/id/public/intersection-of-two-arrays-ii",
        "hidden_test_path": "/id/hidden/intersection-of-two-arrays-ii",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "third-maximum-number",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Third Maximum Number",
        "description": "**Third Maximum Number**\n Cho một mảng số nguyên `nums`, hãy trả về số lớn thứ ba khác biệt trong mảng này. Nếu không tồn tại số lớn thứ ba, hãy trả về số lớn nhất.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def thirdMax(self, nums: List[int]) -> int:\n        min_heap = []\n        taken = set()\n        \n        for index in range(len(nums)):\n            if nums[index] in taken:\n                continue\n            \n            if len(min_heap) == 3:\n                if min_heap[0] < nums[index]:\n                    taken.remove(min_heap[0])\n                    heappop(min_heap)\n                    \n                    heappush(min_heap, nums[index])\n                    taken.add(nums[index])\n                    \n            else:\n                heappush(min_heap, nums[index])\n                taken.add(nums[index])\n        \n        if len(min_heap) == 1:\n            return min_heap[0]\n        \n        elif len(min_heap) == 2:\n            first_num = min_heap[0]\n            heappop(min_heap)\n            return max(first_num, min_heap[0])\n        \n        return min_heap[0]",
        "public_test_path": "/id/public/third-maximum-number",
        "hidden_test_path": "/id/hidden/third-maximum-number",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 25
    },
    {
        "problem_id": "find-all-numbers-disappeared-in-an-array",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Find All Numbers Disappeared in an Array",
        "description": "**Tìm tất cả các số bị mất trong mảng**\nCho một mảng `nums` gồm `n` số nguyên, trong đó `nums[i]` nằm trong khoảng `[1, n]`, hãy trả về một mảng gồm tất cả các số trong khoảng `[1, n]` mà không xuất hiện trong `nums`.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\n        set_nums = set(nums)\n        missing = []\n\n        for i in range(1,len(nums)+1):\n            if i not in set_nums:\n                missing.append(i)\n\n        return missing",
        "public_test_path": "/id/public/find-all-numbers-disappeared-in-an-array",
        "hidden_test_path": "/id/hidden/find-all-numbers-disappeared-in-an-array",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "assign-cookies",
        "topic": "Chương 1",
        "sub_topic": "Mảng",
        "name": "Assign Cookies",
        "description": "**Assign Cookies**\nGiả sử bạn là một phụ huynh tuyệt vời và muốn cho con cái của bạn một số bánh quy. Nhưng, bạn chỉ nên cho mỗi đứa trẻ tối đa một chiếc bánh quy.\nMỗi đứa trẻ i có một hệ số tham lam g[i], là kích thước tối thiểu của bánh quy mà đứa trẻ sẽ hài lòng; và mỗi bánh quy j có kích thước s[j]. Nếu s[j] >= g[i], chúng ta có thể gán bánh quy j cho đứa trẻ i, và đứa trẻ i sẽ hài lòng. Mục tiêu của bạn là tối đa hóa số lượng trẻ hài lòng và xuất ra số tối đa đó.\n",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        content_children = 0\n        cookie_index = 0\n        while cookie_index < len(s) and content_children < len(g):\n            if s[cookie_index] >= g[content_children]:\n                content_children += 1\n            cookie_index += 1\n        return content_children",
        "public_test_path": "/id/public/assign-cookies",
        "hidden_test_path": "/id/hidden/assign-cookies",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 30
    },
    {
        "problem_id": "hello-world-001",
        "topic": "Chương 1",
        "sub_topic": "Biến & Kiểu dữ liệu",
        "name": "Hello World",
        "description": "In ra **'Hello World'** lên console.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "print('Hello World')",
        "public_test_path": "/id/public/hello-world-001",
        "hidden_test_path": "/id/hidden/hello-world-001",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 3
    },
    {
        "problem_id": "hello-world-001",
        "topic": "Chương 1",
        "sub_topic": "Biến & Kiểu dữ liệu",
        "name": "Hello World",
        "description": "In ra **'Hello World'** lên console.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def hello_world():\n    return 'Hello World'",
        "public_test_path": "/id/public/hello-world-001",
        "hidden_test_path": "/id/hidden/hello-world-001",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 3
    },
    {
        "problem_id": "print-name-002",
        "topic": "Chương 1",
        "sub_topic": "Biến & Kiểu dữ liệu",
        "name": "In tên của bạn",
        "description": "Yêu cầu người dùng nhập **tên** và in ra console.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def print_name(name):\n    return name",
        "public_test_path": "/id/public/print-name-002",
        "hidden_test_path": "/id/hidden/print-name-002",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "add-two-numbers-003",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh & Vòng lặp",
        "name": "Cộng hai số",
        "description": "Nhập hai số nguyên `a` và `b` và in ra **tổng** của chúng.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def add_two_numbers(a, b):\n    return a + b",
        "public_test_path": "/id/public/add-two-numbers-003",
        "hidden_test_path": "/id/hidden/add-two-numbers-003",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "subtract-two-numbers-004",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh & Vòng lặp",
        "name": "Trừ hai số",
        "description": "Nhập hai số nguyên `a` và `b` và in ra **kết quả trừ** (`a - b`).",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def subtract_two_numbers(a, b):\n    return a - b",
        "public_test_path": "/id/public/subtract-two-numbers-004",
        "hidden_test_path": "/id/hidden/subtract-two-numbers-004",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "multiply-two-numbers-005",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh & Vòng lặp",
        "name": "Nhân hai số",
        "description": "Nhập hai số nguyên `a` và `b` và in ra **tích** của chúng.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def multiply_two_numbers(a, b):\n    return a * b",
        "public_test_path": "/id/public/multiply-two-numbers-005",
        "hidden_test_path": "/id/hidden/multiply-two-numbers-005",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "divide-two-numbers-006",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh & Vòng lặp",
        "name": "Chia hai số",
        "description": "Nhập hai số nguyên `a` và `b` và in ra **kết quả chia** (`a / b`).",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def divide_two_numbers(a, b):\n    return a / b if b != 0 else 'Không thể chia cho 0'",
        "public_test_path": "/id/public/divide-two-numbers-006",
        "hidden_test_path": "/id/hidden/divide-two-numbers-006",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "even-odd-007",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh & Vòng lặp",
        "name": "Kiểm tra chẵn lẻ",
        "description": "Nhập một số và xác định xem nó là **chẵn** hay **lẻ**.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def is_even(n):\n    return 'Chẵn' if n % 2 == 0 else 'Lẻ'",
        "public_test_path": "/id/public/even-odd-007",
        "hidden_test_path": "/id/hidden/even-odd-007",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "prime-check-008",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh & Vòng lặp",
        "name": "Kiểm tra số nguyên tố",
        "description": "Nhập một số và kiểm tra xem nó có phải là **số nguyên tố** hay không.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def is_prime(n):\n    if n <= 1:\n        return 'Không phải nguyên tố'\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return 'Không phải nguyên tố'\n    return 'Nguyên tố'",
        "public_test_path": "/id/public/prime-check-008",
        "hidden_test_path": "/id/hidden/prime-check-008",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 23
    },
    {
        "problem_id": "max-of-three-009",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh & Vòng lặp",
        "name": "Tìm số lớn nhất trong ba số",
        "description": "Nhập ba số `a`, `b` và `c`, và tìm số **lớn nhất** trong ba số đó.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def max_of_three(a, b, c):\n    return max(a, b, c)",
        "public_test_path": "/id/public/max-of-three-009",
        "hidden_test_path": "/id/hidden/max-of-three-009",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "min-of-three-010",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh & Vòng lặp",
        "name": "Tìm số nhỏ nhất trong ba số",
        "description": "Nhập ba số `a`, `b` và `c`, và tìm số **nhỏ nhất** trong ba số đó.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def min_of_three(a, b, c):\n    return min(a, b, c)",
        "public_test_path": "/id/public/min-of-three-010",
        "hidden_test_path": "/id/hidden/min-of-three-010",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "factorial-011",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh & Vòng lặp",
        "name": "Giai thừa",
        "description": "Nhập một số `n` và tính **giai thừa** của nó (`n!`).",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result",
        "public_test_path": "/id/public/factorial-011",
        "hidden_test_path": "/id/hidden/factorial-011",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "multiplication-table-012",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh & Vòng lặp",
        "name": "Bảng cửu chương",
        "description": "Nhập một số `n` và in ra **bảng cửu chương** từ 1 đến 10.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def multiplication_table(n):\n    return [f'{n} x {i} = {n*i}' for i in range(1, 11)]",
        "public_test_path": "/id/public/multiplication-table-012",
        "hidden_test_path": "/id/hidden/multiplication-table-012",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 9
    },
    {
        "problem_id": "sum-of-n-013",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh & Vòng lặp",
        "name": "Tổng n số đầu tiên",
        "description": "Nhập số `n` và tính **tổng** của `n` số tự nhiên đầu tiên.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def sum_of_n(n):\n    return sum(range(1, n+1))",
        "public_test_path": "/id/public/sum-of-n-013",
        "hidden_test_path": "/id/hidden/sum-of-n-013",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "average-of-n-014",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh & Vòng lặp",
        "name": "Trung bình cộng của n số",
        "description": "Nhập `n` số và tính **trung bình cộng** của chúng.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def average(numbers):\n    return sum(numbers)/len(numbers) if numbers else 0.0",
        "public_test_path": "/id/public/average-of-n-014",
        "hidden_test_path": "/id/hidden/average-of-n-014",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 60
    },
    {
        "problem_id": "fibonacci-015",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh & Vòng lặp",
        "name": "Dãy Fibonacci",
        "description": "Nhập số `n` và in ra **n số đầu tiên của dãy Fibonacci**.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def fibonacci(n):\n    a, b = 0, 1\n    res = []\n    for _ in range(n):\n        res.append(a)\n        a, b = b, a+b\n    return res",
        "public_test_path": "/id/public/fibonacci-015",
        "hidden_test_path": "/id/hidden/fibonacci-015",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "count-characters-016",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Đếm ký tự trong chuỗi",
        "description": "Nhập một **chuỗi** và đếm số lượng ký tự trong chuỗi đó.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def count_characters(s):\n    return len(s)",
        "public_test_path": "/id/public/count-characters-016",
        "hidden_test_path": "/id/hidden/count-characters-016",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "armstrong-017",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh & Vòng lặp",
        "name": "Kiểm tra số Armstrong",
        "description": "Nhập một số `n` và kiểm tra xem nó có phải là **số Armstrong** hay không.\nSố Armstrong là số bằng tổng lập phương các chữ số của nó.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def is_armstrong(n):\n    total = sum(int(d)**3 for d in str(n))\n    return 'Armstrong' if total == n else 'Không phải Armstrong'",
        "public_test_path": "/id/public/armstrong-017",
        "hidden_test_path": "/id/hidden/armstrong-017",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 19
    },
    {
        "problem_id": "swap-two-numbers-019",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh & Vòng lặp",
        "name": "Hoán đổi hai số",
        "description": "Nhập hai số `a` và `b` và **hoán đổi giá trị** của chúng.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def swap_numbers(a, b):\n    return b, a",
        "public_test_path": "/id/public/swap-two-numbers-019",
        "hidden_test_path": "/id/hidden/swap-two-numbers-019",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "sum-of-digits-020",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh & Vòng lặp",
        "name": "Tổng các chữ số",
        "description": "Nhập một số `n` và tính **tổng các chữ số** của nó.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def sum_of_digits(n):\n    return sum(int(d) for d in str(n))",
        "public_test_path": "/id/public/sum-of-digits-020",
        "hidden_test_path": "/id/hidden/sum-of-digits-020",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "reverse-number-021",
        "topic": "Chương 1",
        "sub_topic": "Rẽ nhánh & Vòng lặp",
        "name": "Đảo ngược số",
        "description": "Nhập một số `n` và in ra các chữ số của nó theo **thứ tự ngược lại**.",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def reverse_number(n):\n    rev = 0\n    temp = n\n    while temp > 0:\n        rev = rev*10 + temp%10\n        temp //= 10\n    return rev",
        "public_test_path": "/id/public/reverse-number-021",
        "hidden_test_path": "/id/hidden/reverse-number-021",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "count-vowels-022",
        "topic": "Chương 1",
        "sub_topic": "Chuỗi",
        "name": "Đếm nguyên âm trong chuỗi",
        "description": "Nhập một **chuỗi** và đếm số lượng **nguyên âm** (`a, e, i, o, u`).",
        "difficulty": 1,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def count_vowels(s):\n    return sum(1 for ch in s.lower() if ch in 'aeiou')",
        "public_test_path": "/id/public/count-vowels-022",
        "hidden_test_path": "/id/hidden/count-vowels-022",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 70
    },
    {
        "problem_id": "missingnumber1083",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Missing Number",
        "description": "You are given all numbers between 1,2,…,n except one. Your task is to find the missing number.\n\nInput\n\nThe first input line contains an integer n .\n\nThe second line contains n-1 numbers. Each number is distinct and between 1 and n (inclusive).\n\nOutput\n\nPrint the missing number.\n\nConstraints\n\n2 ≤ n ≤ 2 · 10^5\n\nExample\n\nInput:\n\n\n5\n2 3 1 5\n\n\nOutput:\n\n\n4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    contains = [False] * n\n    numbers = list(map(int, sys.stdin.readline().strip().split()))\n    \n    for num in numbers:\n        contains[num - 1] = True\n    \n    for i in range(n):\n        if not contains[i]:\n            print(i + 1)\n            break\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1083",
        "hidden_test_path": "/id/hidden/1083",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "repetitions1069",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Repetitions",
        "description": "You are given a DNA sequence: a string consisting of characters A, C, G, and T. Your task is to find the longest repetition in the sequence. This is a maximum-length substring containing only one type of character.\n\nInput\n\nThe only input line contains a string of n characters.\n\nOutput\n\nPrint one integer: the length of the longest repetition.\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\nATTCGGGA\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    s = input()\n    prev = ' '\n    max_count = 0\n    curr = 0\n    for i in range(len(s)):\n        if s[i] == prev:\n            curr += 1\n        else:\n            prev = s[i]\n            curr = 1\n        if curr > max_count:\n            max_count = curr\n    print(max_count)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1069",
        "hidden_test_path": "/id/hidden/1069",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "increasingarray1094",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Increasing Array",
        "description": "You are given an array of n integers. You want to modify the array so that it is increasing, i.e., every element is at least as large as the previous element.\n\nOn each move, you may increase the value of any element by one. What is the minimum number of moves required?\n\nInput\n\nThe first input line contains an integer n : the size of the array.\n\nThen, the second line contains n integers x_1,x_2,…,x_n : the contents of the array.\n\nOutput\n\nPrint the minimum number of moves.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5\n3 2 5 1 7\n\n\nOutput:\n\n\n5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    cur = int(data[1])\n    ans = 0\n    \n    for i in range(2, n + 1):\n        c1 = int(data[i])\n        if c1 < cur:\n            ans += cur - c1\n        cur = max(cur, c1)\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1094",
        "hidden_test_path": "/id/hidden/1094",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "permutations1070",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Permutations",
        "description": "A permutation of integers 1,2,…,n is called beautiful if there are no adjacent elements whose difference is 1 .\n\nGiven n , construct a beautiful permutation if such a permutation exists.\n\nInput\n\nThe only input line contains an integer n .\n\nOutput\n\nPrint a beautiful permutation of integers 1,2,…,n . If there are several solutions, you may print any of them. If there are no solutions, print \"NO SOLUTION\".\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample 1\n\nInput:\n\n\n5\n\n\nOutput:\n\n\n4 2 5 3 1\n\nExample 2\n\nInput:\n\n\n3\n\n\nOutput:\n\n\nNO SOLUTION",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    n = int(input().strip())\n    \n    if n == 1:\n        print(\"1\")\n    elif n == 2 or n == 3:\n        print(\"NO SOLUTION\")\n    else:\n        even_numbers = [str(i) for i in range(2, n + 1, 2)]\n        odd_numbers = [str(i) for i in range(1, n + 1, 2)]\n        print(\" \".join(even_numbers + odd_numbers))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1070",
        "hidden_test_path": "/id/hidden/1070",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 21
    },
    {
        "problem_id": "numberspiral1071",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Number Spiral",
        "description": "A number spiral is an infinite grid whose upper-left square has number 1. Here are the first five layers of the spiral: Your task is to find out the number in row y and column x .\n\nInput\n\nThe first input line contains an integer t : the number of tests.\n\nAfter this, there are t lines, each containing integers y and x .\n\nOutput\n\nFor each test, print the number in row y and column x .\n\nConstraints\n\n1 ≤ t ≤ 10^5 1 ≤ y,x ≤ 10^9\n\nExample\n\nInput:\n\n\n3\n2 3\n1 1\n4 2\n\n\nOutput:\n\n\n8\n1\n15",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\ndef main():\n    numcases = int(sys.stdin.readline().strip())\n    for _ in range(numcases):\n        row, col = map(int, sys.stdin.readline().strip().split())\n        max_val = max(row, col)\n        ans = max_val * max_val\n        if row >= col:\n            if row % 2 == 0:\n                ans -= col - 1\n            else:\n                ans -= 2 * row - 1 - col\n        else:\n            if col % 2 == 1:\n                ans -= row - 1\n            else:\n                ans -= 2 * col - 1 - row\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1071",
        "hidden_test_path": "/id/hidden/1071",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 2
    },
    {
        "problem_id": "twoknights1072",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Two Knights",
        "description": "Your task is to count for k=1,2,…,n the number of ways two knights can be placed on a k × k chessboard so that they do not attack each other.\n\nInput\n\nThe only input line contains an integer n .\n\nOutput\n\nPrint n integers: the results.\n\nConstraints\n\n1 ≤ n ≤ 10000\n\nExample\n\nInput:\n\n\n8\n\n\nOutput:\n\n\n0\n6\n28\n96\n252\n550\n1056\n1848",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    for i in range(1, n + 1):\n        result = (i * i * (i * i - 1) // 2) - (8 // 2) * (i - 1) * (i - 2)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1072",
        "hidden_test_path": "/id/hidden/1072",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 3
    },
    {
        "problem_id": "twosets1092",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Two Sets",
        "description": "Your task is to divide the numbers 1,2,…,n into two sets of equal sum.\n\nInput\n\nThe only input line contains an integer n .\n\nOutput\n\nPrint \"YES\", if the division is possible, and \"NO\" otherwise.\n\nAfter this, if the division is possible, print an example of how to create the sets. First, print the number of elements in the first set followed by the elements themselves in a separate line, and then, print the second set in a similar way.\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample 1\n\nInput:\n\n\n7\n\n\nOutput:\n\n\nYES\n4\n1 2 4 7\n3\n3 5 6\n\nExample 2\n\nInput:\n\n\n6\n\n\nOutput:\n\n\nNO",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    n = int(data[0])\n    sum_value = n * (n + 1) // 2\n    \n    if sum_value % 2 == 0:\n        print(\"YES\")\n        used = [False] * (n + 1)\n        rem = sum_value // 2\n        cnt = 0\n        \n        for i in range(n, 0, -1):\n            if rem >= i:\n                used[i] = True\n                rem -= i\n                cnt += 1\n        \n        print(cnt)\n        print(\" \".join(str(i) for i in range(1, n + 1) if used[i]))\n        print(n - cnt)\n        print(\" \".join(str(i) for i in range(1, n + 1) if not used[i]))\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1092",
        "hidden_test_path": "/id/hidden/1092",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 23
    },
    {
        "problem_id": "bitstrings1617",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Bit Strings",
        "description": "Your task is to calculate the number of bit strings of length n .\n\nFor example, if n=3 , the correct answer is 8 , because the possible bit strings are 000, 001, 010, 011, 100, 101, 110, and 111.\n\nInput\n\nThe only input line has an integer n .\n\nOutput\n\nPrint the result modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\n3\n\n\nOutput:\n\n\n8",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    n = int(input().strip())\n    mod = 10**9 + 7\n    start = 1\n    for i in range(n):\n        start = (2 * start) % mod\n    print(start)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1617",
        "hidden_test_path": "/id/hidden/1617",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "trailingzeros1618",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Trailing Zeros",
        "description": "Your task is to calculate the number of trailing zeros in the factorial n! .\n\nFor example, 20!=2432902008176640000 and it has 4 trailing zeros.\n\nInput\n\nThe only input line has an integer n .\n\nOutput\n\nPrint the number of trailing zeros in n! .\n\nConstraints\n\n1 ≤ n ≤ 10^9\n\nExample\n\nInput:\n\n\n20\n\n\nOutput:\n\n\n4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\ndef main():\n    input = sys.stdin.read\n    n = int(input().strip())\n    ans1 = 0\n    ans2 = 0\n    i = 2\n    while i <= n:\n        ans1 += n // i\n        i *= 2\n    i = 5\n    while i <= n:\n        ans2 += n // i\n        i *= 5\n    print(min(ans1, ans2))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1618",
        "hidden_test_path": "/id/hidden/1618",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "coinpiles1754",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Coin Piles",
        "description": "You have two coin piles containing a and b coins. On each move, you can either remove one coin from the left pile and two coins from the right pile, or two coins from the left pile and one coin from the right pile.\n\nYour task is to efficiently find out if you can empty both the piles.\n\nInput\n\nThe first input line has an integer t : the number of tests.\n\nAfter this, there are t lines, each of which has two integers a and b : the numbers of coins in the piles.\n\nOutput\n\nFor each test, print \"YES\" if you can empty the piles and \"NO\" otherwise.\n\nConstraints\n\n1 ≤ t ≤ 10^5 0 ≤ a, b ≤ 10^9\n\nExample\n\nInput:\n\n\n3\n2 1\n2 2\n3 3\n\n\nOutput:\n\n\nYES\nNO\nYES",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    nc = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(nc):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        \n        if a > b:\n            a, b = b, a\n        \n        dif = b - a\n        a -= dif\n        b -= 2 * dif\n        \n        if a == b and a >= 0 and a % 3 == 0:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1754",
        "hidden_test_path": "/id/hidden/1754",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 3
    },
    {
        "problem_id": "graycode2205",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Gray Code",
        "description": "A Gray code is a list of all 2^n bit strings of length n , where any two successive strings differ in exactly one bit (i.e., their Hamming distance is one).\n\nYour task is to create a Gray code for a given length n .\n\nInput\n\nThe only input line has an integer n .\n\nOutput\n\nPrint 2^n lines that describe the Gray code. You can print any valid solution.\n\nConstraints\n\n1 ≤ n ≤ 16\n\nExample\n\nInput:\n\n\n2\n\n\nOutput:\n\n\n00\n01\n11\n10",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    n = int(sys.stdin.readline().strip())\n    used = [False] * (1 << n)\n    b = []\n    start = 0\n    while True:\n        if used[start]:\n            break\n        used[start] = True\n        s = bin(start)[2:]\n        diff = n - len(s)\n        b.append('0' * diff + s)\n        for i in range(n):\n            next = start ^ (1 << i)\n            if not used[next]:\n                start = next\n                break\n    print(\"\\n\".join(b))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2205",
        "hidden_test_path": "/id/hidden/2205",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "creatingstrings1622",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Creating Strings",
        "description": "Given a string, your task is to generate all different strings that can be created using its characters.\n\nInput\n\nThe only input line has a string of length n . Each character is between a–z.\n\nOutput\n\nFirst print an integer k : the number of strings. Then print k lines: the strings in alphabetical order.\n\nConstraints\n\n1 ≤ n ≤ 8\n\nExample\n\nInput:\n\n\naabac\n\n\nOutput:\n\n\n20\naaabc\naaacb\naabac\naabca\naacab\naacba\nabaac\nabaca\nabcaa\nacaab\nacaba\nacbaa\nbaaac\nbaaca\nbacaa\nbcaaa\ncaaab\ncaaba\ncabaa\ncbaaa",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\ncnt = 0\n\ndef solve(used, freq, b, n, curr):\n    global cnt\n    if len(curr) >= n:\n        b.append(curr + \"\\n\")\n        cnt += 1\n        return\n    for i in range(len(freq)):\n        if used[i] < freq[i]:\n            used[i] += 1\n            curr += chr(ord('a') + i)\n            solve(used, freq, b, n, curr)\n            curr = curr[:-1]\n            used[i] -= 1\n\nif __name__ == \"__main__\":\n    s = sys.stdin.readline().strip()\n    freq = [0] * 26\n    for char in s:\n        freq[ord(char) - ord('a')] += 1\n    b = []\n    solve([0] * 26, freq, b, len(s), \"\")\n    print(cnt)\n    print(''.join(b), end='')",
        "public_test_path": "/id/public/1622",
        "hidden_test_path": "/id/hidden/1622",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    },
    {
        "problem_id": "appledivision1623",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Apple Division",
        "description": "There are n apples with known weights. Your task is to divide the apples into two groups so that the difference between the weights of the groups is minimal.\n\nInput\n\nThe first input line has an integer n : the number of apples.\n\nThe next line has n integers p_1,p_2,…,p_n : the weight of each apple.\n\nOutput\n\nPrint one integer: the minimum difference between the weights of the groups.\n\nConstraints\n\n1 ≤ n ≤ 20 1 ≤ p_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5\n3 2 7 4 1\n\n\nOutput:\n\n\n1\n\n\nExplanation: Group 1 has weights 2, 3 and 4 (total weight 9), and group 2 has weights 1 and 7 (total weight 8).",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    val = list(map(int, sys.stdin.readline().strip().split()))\n    dp = [0] * (1 << n)\n    \n    for i in range(n):\n        dp[1 << i] = val[i]\n    \n    for i in range(1, len(dp)):\n        j = i & (i - 1)\n        dp[i] = dp[i - j] + dp[j]\n    \n    diff = float('inf')\n    for i in range(len(dp)):\n        j = (1 << n) - i - 1\n        diff = min(abs(dp[i] - dp[j]), diff)\n    \n    print(diff)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1623",
        "hidden_test_path": "/id/hidden/1623",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 18
    },
    {
        "problem_id": "chessboardandqueens1624",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Chessboard and Queens",
        "description": "Your task is to place eight queens on a chessboard so that no two queens are attacking each other. As an additional challenge, each square is either free or reserved, and you can only place queens on the free squares. However, the reserved squares do not prevent queens from attacking each other.\n\nHow many possible ways are there to place the queens?\n\nInput\n\nThe input has eight lines, and each of them has eight characters. Each square is either free ( . ) or reserved ( * ).\n\nOutput\n\nPrint one integer: the number of ways you can place the queens.\n\nExample\n\nInput:\n\n\n........\n........\n..*.....\n........\n........\n.....**.\n...*....\n........\n\n\nOutput:\n\n\n65",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    grid = [[0] * 8 for _ in range(8)]\n    for i in range(8):\n        str_row = data[i]\n        for j in range(8):\n            grid[i][j] = str_row[j] == '.'\n    \n    row = [0] * 8\n    col = [0] * 8\n    d1 = [0] * 15\n    d2 = [0] * 15\n    ans = 0\n    \n    def bt(idx):\n        nonlocal ans\n        if idx == 8:\n            ans += 1\n            return\n        for c in range(8):\n            d1v = c + idx\n            d2v = (7 - c) + idx\n            if not grid[idx][c] or row[idx] or col[c] or d1[d1v] or d2[d2v]:\n                continue\n            row[idx] = col[c] = d1[d1v] = d2[d2v] = 1\n            bt(idx + 1)\n            row[idx] = col[c] = d1[d1v] = d2[d2v] = 0\n    \n    bt(0)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1624",
        "hidden_test_path": "/id/hidden/1624",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "knightmovesgrid3217",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Knight Moves Grid",
        "description": "There is a knight on an n × n chessboard. For each square, print the minimum number of moves the knight needs to do to reach the top-left corner.\n\nInput\n\nThe only line has an integer n .\n\nOutput\n\nPrint the number of moves for each square.\n\nConstraints\n\n4 ≤ n ≤ 1000\n\nExample\n\nInput:\n\n\n8\n\n\nOutput:\n\n\n0 3 2 3 2 3 4 5 \n3 4 1 2 3 4 3 4 \n2 1 4 3 2 3 4 5 \n3 2 3 2 3 4 3 4 \n2 3 2 3 4 3 4 5 \n3 4 3 4 3 4 5 4 \n4 3 4 3 4 5 4 5 \n5 4 5 4 5 4 5 6",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import deque\n\nn = int(input())\ndist = [[-1] * n for _ in range(n)]\ndr = [1, 1, -1, -1, 2, 2, -2, -2]\ndc = [2, -2, 2, -2, 1, -1, 1, -1]\nq = deque([(0, 0, 0)])\n\nwhile q:\n    d, r, c = q.popleft()\n    if dist[r][c] != -1:\n        continue\n    dist[r][c] = d\n    for i in range(len(dr)):\n        r1, c1 = r + dr[i], c + dc[i]\n        if min(r1, c1) < 0 or max(r1, c1) >= n:\n            continue\n        q.append((d + 1, r1, c1))\n\nfor i in range(n):\n    for j in range(n):\n        print(dist[i][j], end=\" \")\n    print()",
        "public_test_path": "/id/public/3217",
        "hidden_test_path": "/id/hidden/3217",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 3
    },
    {
        "problem_id": "digitqueries2431",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Digit Queries",
        "description": "Consider an infinite string that consists of all positive integers in increasing order:\n\n12345678910111213141516171819202122232425...\n\nYour task is to process q queries of the form: what is the digit at position k in the string?\n\nInput\n\nThe first input line has an integer q : the number of queries.\n\nAfter this, there are q lines that describe the queries. Each line has an integer k : a 1 -indexed position in the string.\n\nOutput\n\nFor each query, print the corresponding digit.\n\nConstraints\n\n1 ≤ q ≤ 1000 1 ≤ k ≤ 10^{18}\n\nExample\n\nInput:\n\n\n3\n7\n19\n12\n\n\nOutput:\n\n\n7\n4\n1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        k = int(data[index])\n        index += 1\n        k += 1  # 0\n        cursum = 1  # 0\n        curv = 1\n        dig = 1\n        \n        while True:\n            newsum = cursum + (9 * curv) * dig\n            if newsum >= k:\n                break\n            cursum = newsum\n            dig += 1\n        \n        newsum = cursum + 9 * curv * dig\n        addnum = (k - cursum + dig - 1) // dig\n        num = curv - 1 + addnum\n        str_num = str(num)\n        results.append(str_num[(k - 1 - cursum) % dig])\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2431",
        "hidden_test_path": "/id/hidden/2431",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "stringreorder1743",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "String Reorder",
        "description": "Your task is to reorder the characters of a string so that no two adjacent characters are the same. What is the lexicographically minimal such string?\n\nInput\n\nThe only line has a string of length n consisting of characters A–Z.\n\nOutput\n\nPrint the lexicographically minimal reordered string where no two adjacent characters are the same. If it is not possible to create such a string, print -1 .\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\nHATTIVATTI\n\n\nOutput:\n\n\nAHATITITVT",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    from collections import Counter\n\n    input = sys.stdin.read\n    str_input = input().strip()\n    n = len(str_input)\n    freq = Counter(str_input)\n\n    def getmax():\n        return max(freq.values())\n\n    v = getmax()\n    left = n\n    if v > (left + 1) // 2:\n        print(\"-1\")\n        return\n\n    pre = -1\n    result = []\n    for _ in range(n):\n        for j in range(26):\n            if chr(j + ord('A')) == pre or freq[chr(j + ord('A'))] == 0:\n                continue\n            freq[chr(j + ord('A'))] -= 1\n            if getmax() <= left // 2:\n                result.append(chr(j + ord('A')))\n                left -= 1\n                pre = chr(j + ord('A'))\n                break\n            freq[chr(j + ord('A'))] += 1\n\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1743",
        "hidden_test_path": "/id/hidden/1743",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "distinctnumbers1621",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Distinct Numbers",
        "description": "You are given a list of n integers, and your task is to calculate the number of distinct values in the list.\n\nInput\n\nThe first input line has an integer n : the number of values.\n\nThe second line has n integers x_1,x_2,…,x_n .\n\nOutput\n\nPrint one integers: the number of distinct values.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5\n2 3 2 2 3\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:n+1]))\n    \n    a.sort()\n    ans = 1\n    \n    for i in range(n - 1):\n        if a[i] != a[i + 1]:\n            ans += 1\n            \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1621",
        "hidden_test_path": "/id/hidden/1621",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "apartments1084",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Apartments",
        "description": "There are n applicants and m free apartments. Your task is to distribute the apartments so that as many applicants as possible will get an apartment.\n\nEach applicant has a desired apartment size, and they will accept any apartment whose size is close enough to the desired size.\n\nInput\n\nThe first input line has three integers n , m , and k : the number of applicants, the number of apartments, and the maximum allowed difference.\n\nThe next line contains n integers a_1, a_2, …, a_n : the desired apartment size of each applicant. If the desired size of an applicant is x , they will accept any apartment whose size is between x-k and x+k .\n\nThe last line contains m integers b_1, b_2, …, b_m : the size of each apartment.\n\nOutput\n\nPrint one integer: the number of applicants who will get an apartment.\n\nConstraints\n\n1 ≤ n, m ≤ 2 · 10^5 0 ≤ k ≤ 10^9 1 ≤ a_i, b_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4 3 5\n60 45 80 60\n30 60 75\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2])\n    \n    a = list(map(int, data[3:3+n]))\n    b = list(map(int, data[3+n:3+n+m]))\n    \n    a.sort()\n    b.sort()\n    \n    apnt = 0\n    bpnt = 0\n    ans = 0\n    \n    while apnt < n and bpnt < m:\n        if abs(a[apnt] - b[bpnt]) <= k:\n            ans += 1\n            apnt += 1\n            bpnt += 1\n            continue\n        if a[apnt] < b[bpnt]:\n            apnt += 1\n        else:\n            bpnt += 1\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1084",
        "hidden_test_path": "/id/hidden/1084",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 19
    },
    {
        "problem_id": "ferriswheel1090",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Ferris Wheel",
        "description": "There are n children who want to go to a Ferris wheel, and your task is to find a gondola for each child.\n\nEach gondola may have one or two children in it, and in addition, the total weight in a gondola may not exceed x . You know the weight of every child.\n\nWhat is the minimum number of gondolas needed for the children?\n\nInput\n\nThe first input line contains two integers n and x : the number of children and the maximum allowed weight.\n\nThe next line contains n integers p_1,p_2,…,p_n : the weight of each child.\n\nOutput\n\nPrint one integer: the minimum number of gondolas.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x ≤ 10^9 1 ≤ p_i ≤ x\n\nExample\n\nInput:\n\n\n4 10\n7 2 3 9\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    a = list(map(int, data[2:n+2]))\n    \n    a.sort()\n    ans = 0\n    l, r = 0, n - 1\n    \n    while l <= r:\n        if a[l] + a[r] <= x:\n            l += 1\n            r -= 1\n        else:\n            r -= 1\n        ans += 1\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1090",
        "hidden_test_path": "/id/hidden/1090",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "concerttickets1091",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Concert Tickets",
        "description": "There are n concert tickets available, each with a certain price. Then, m customers arrive, one after another.\n\nEach customer announces the maximum price they are willing to pay for a ticket, and after this, they will get a ticket with the nearest possible price such that it does not exceed the maximum price.\n\nInput\n\nThe first input line contains integers n and m : the number of tickets and the number of customers.\n\nThe next line contains n integers h_1,h_2,…,h_n : the price of each ticket.\n\nThe last line contains m integers t_1,t_2,…,t_m : the maximum price for each customer in the order they arrive.\n\nOutput\n\nPrint, for each customer, the price that they will pay for their ticket. After this, the ticket cannot be purchased again.\n\nIf a customer cannot get any ticket, print -1 .\n\nConstraints\n\n1 ≤ n, m ≤ 2 · 10^5 1 ≤ h_i, t_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5 3\n5 3 7 8 5\n4 8 3\n\n\nOutput:\n\n\n3\n8\n-1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom sortedcontainers import SortedList\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\nms = SortedList()\n\nfor i in range(n):\n    v = int(data[2 + i])\n    ms.add(v)\n\noutput = []\nfor i in range(m):\n    v = int(data[2 + n + i])\n    if len(ms) == 0 or ms.bisect_right(v) == 0:\n        output.append(-1)\n        continue\n    it = ms.bisect_right(v) - 1\n    output.append(ms[it])\n    ms.remove(ms[it])\n\nprint(\"\\n\".join(map(str, output)))",
        "public_test_path": "/id/public/1091",
        "hidden_test_path": "/id/hidden/1091",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "restaurantcustomers1619",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Restaurant Customers",
        "description": "You are given the arrival and leaving times of n customers in a restaurant.\n\nWhat was the maximum number of customers in the restaurant at any time?\n\nInput\n\nThe first input line has an integer n : the number of customers.\n\nAfter this, there are n lines that describe the customers. Each line has two integers a and b : the arrival and leaving times of a customer.\n\nYou may assume that all arrival and leaving times are distinct.\n\nOutput\n\nPrint one integer: the maximum number of customers.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ a < b ≤ 10^9\n\nExample\n\nInput:\n\n\n3\n5 8\n2 4\n3 9\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn = int(data[0])\nv = []\n\nfor i in range(1, n + 1):\n    a, b = map(int, data[i].split())\n    v.append((a, 1))\n    v.append((b, -1))\n\nv.sort()\ncur = 0\nans = 0\n\nfor i in range(2 * n):\n    cur += v[i][1]\n    ans = max(ans, cur)\n\nprint(ans)",
        "public_test_path": "/id/public/1619",
        "hidden_test_path": "/id/hidden/1619",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "moviefestival1629",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Movie Festival",
        "description": "In a movie festival n movies will be shown. You know the starting and ending time of each movie. What is the maximum number of movies you can watch entirely?\n\nInput\n\nThe first input line has an integer n : the number of movies.\n\nAfter this, there are n lines that describe the movies. Each line has two integers a and b : the starting and ending times of a movie.\n\nOutput\n\nPrint one integer: the maximum number of movies.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ a < b ≤ 10^9\n\nExample\n\nInput:\n\n\n3\n3 5\n4 9\n5 8\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    v = []\n    \n    for i in range(1, n + 1):\n        a, b = map(int, data[i].split())\n        v.append((b, a))\n    \n    v.sort()\n    curend = 0\n    ans = 0\n    \n    for i in range(n):\n        if curend <= v[i][1]:\n            curend = v[i][0]\n            ans += 1\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1629",
        "hidden_test_path": "/id/hidden/1629",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "sumoftwovalues1640",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Sum of Two Values",
        "description": "You are given an array of n integers, and your task is to find two values (at distinct positions) whose sum is x .\n\nInput\n\nThe first input line has two integers n and x : the array size and the target sum.\n\nThe second line has n integers a_1,a_2,…,a_n : the array values.\n\nOutput\n\nPrint two integers: the positions of the values. If there are several solutions, you may print any of them. If there are no solutions, print IMPOSSIBLE .\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x,a_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4 8\n2 7 5 1\n\n\nOutput:\n\n\n2 4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    a = [(int(data[i + 2]), i) for i in range(n)]\n    \n    a.sort()\n    r = n - 1\n    ans = (-1, -1)\n    \n    for l in range(n):\n        if l >= r:\n            break\n        while a[l][0] + a[r][0] > x:\n            r -= 1\n        if l >= r:\n            break\n        if a[l][0] + a[r][0] == x:\n            ans = (a[l][1] + 1, a[r][1] + 1)\n    \n    if ans[0] == -1:\n        print(\"IMPOSSIBLE\")\n    else:\n        print(ans[0], ans[1])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1640",
        "hidden_test_path": "/id/hidden/1640",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 27
    },
    {
        "problem_id": "maximumsubarraysum1643",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Maximum Subarray Sum",
        "description": "Given an array of n integers, your task is to find the maximum sum of values in a contiguous, nonempty subarray.\n\nInput\n\nThe first input line has an integer n : the size of the array.\n\nThe second line has n integers x_1,x_2,…,x_n : the array values.\n\nOutput\n\nPrint one integer: the maximum subarray sum.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 -10^9 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8\n-1 3 -2 5 3 -5 2 2\n\n\nOutput:\n\n\n9",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    arr = list(map(int, sys.stdin.readline().strip().split()))\n    \n    pref = 0\n    max_sum = float('-inf')\n    \n    for i in range(n):\n        pref = max(pref, 0)\n        pref += arr[i]\n        max_sum = max(max_sum, pref)\n    \n    print(max_sum)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1643",
        "hidden_test_path": "/id/hidden/1643",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "sticklengths1074",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Stick Lengths",
        "description": "There are n sticks with some lengths. Your task is to modify the sticks so that each stick has the same length.\n\nYou can either lengthen and shorten each stick. Both operations cost x where x is the difference between the new and original length.\n\nWhat is the minimum total cost?\n\nInput\n\nThe first input line contains an integer n : the number of sticks.\n\nThen there are n integers: p_1,p_2,…,p_n : the lengths of the sticks.\n\nOutput\n\nPrint one integer: the minimum total cost.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ p_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5\n2 3 1 5 2\n\n\nOutput:\n\n\n5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom bisect import bisect_left, bisect_right\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\n\na.sort()\nmedian = a[n // 2]\nif n % 2 == 0:\n    median = (median + a[n // 2 - 1]) // 2\n\nans = sum(abs(x - median) for x in a)\nprint(ans)",
        "public_test_path": "/id/public/1074",
        "hidden_test_path": "/id/hidden/1074",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "missingcoinsum2183",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Missing Coin Sum",
        "description": "You have n coins with positive integer values. What is the smallest sum you cannot create using a subset of the coins?\n\nInput\n\nThe first line has an integer n : the number of coins.\n\nThe second line has n integers x_1,x_2,…,x_n : the value of each coin.\n\nOutput\n\nPrint one integer: the smallest coin sum.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5\n2 9 1 2 7\n\n\nOutput:\n\n\n6",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:n+1]))\n    \n    a.sort()\n    sum_ = 0\n    \n    for i in a:\n        if sum_ + 1 < i:\n            print(sum_ + 1)\n            return\n        sum_ += i\n    \n    print(sum_ + 1)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2183",
        "hidden_test_path": "/id/hidden/2183",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "collectingnumbers2216",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Collecting Numbers",
        "description": "You are given an array that contains each number between 1 … n exactly once. Your task is to collect the numbers from 1 to n in increasing order.\n\nOn each round, you go through the array from left to right and collect as many numbers as possible. What will be the total number of rounds?\n\nInput\n\nThe first line has an integer n : the array size.\n\nThe next line has n integers x_1,x_2,…,x_n : the numbers in the array.\n\nOutput\n\nPrint one integer: the number of rounds.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5\n\nExample\n\nInput:\n\n\n5\n4 2 1 5 3\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    numbers = list(map(int, sys.stdin.readline().strip().split()))\n    cnt = n\n    seen = [False] * (n + 1)\n    \n    for j in numbers:\n        if seen[j - 1]:\n            cnt -= 1\n        seen[j] = True\n    \n    print(cnt)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2216",
        "hidden_test_path": "/id/hidden/2216",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "playlist1141",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Playlist",
        "description": "You are given a playlist of a radio station since its establishment. The playlist has a total of n songs.\n\nWhat is the longest sequence of successive songs where each song is unique?\n\nInput\n\nThe first input line contains an integer n : the number of songs.\n\nThe next line has n integers k_1,k_2,…,k_n : the id number of each song.\n\nOutput\n\nPrint the length of the longest sequence of unique songs.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ k_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8\n1 2 1 3 2 7 4 2\n\n\nOutput:\n\n\n5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:n+1]))\n    \n    ss = set()\n    l = 0\n    best = 0\n    \n    for i in range(n):\n        while a[i] in ss:\n            ss.remove(a[l])\n            l += 1\n        best = max(i - l + 1, best)\n        ss.add(a[i])\n    \n    print(best)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1141",
        "hidden_test_path": "/id/hidden/1141",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 21
    },
    {
        "problem_id": "towers1073",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Towers",
        "description": "You are given n cubes in a certain order, and your task is to build towers using them. Whenever two cubes are one on top of the other, the upper cube must be smaller than the lower cube.\n\nYou must process the cubes in the given order. You can always either place the cube on top of an existing tower, or begin a new tower. What is the minimum possible number of towers?\n\nInput\n\nThe first input line contains an integer n : the number of cubes.\n\nThe next line contains n integers k_1,k_2,…,k_n : the sizes of the cubes.\n\nOutput\n\nPrint one integer: the minimum number of towers.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ k_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5\n3 8 2 1 5\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    heights = list(map(int, sys.stdin.readline().strip().split()))\n    map = defaultdict(int)\n\n    for c in heights:\n        h = next((key for key in sorted(map.keys()) if key > c), None)\n        if h is not None:\n            if map[h] == 1:\n                del map[h]\n            else:\n                map[h] -= 1\n        map[c] += 1\n\n    cnt = sum(map.values())\n    print(cnt)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1073",
        "hidden_test_path": "/id/hidden/1073",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "trafficlights1163",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Traffic Lights",
        "description": "There is a street of length x whose positions are numbered 0,1,…,x . Initially there are no traffic lights, but n sets of traffic lights are added to the street one after another.\n\nYour task is to calculate the length of the longest passage without traffic lights after each addition.\n\nInput\n\nThe first input line contains two integers x and n : the length of the street and the number of sets of traffic lights.\n\nThen, the next line contains n integers p_1,p_2,…,p_n : the position of each set of traffic lights. Each position is distinct.\n\nOutput\n\nPrint the length of the longest passage without traffic lights after each addition.\n\nConstraints\n\n1 ≤ x ≤ 10^9 1 ≤ n ≤ 2 · 10^5 0 < p_i < x\n\nExample\n\nInput:\n\n\n8 3\n3 6 2\n\n\nOutput:\n\n\n5 3 3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom sortedcontainers import SortedSet\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    x = int(data[0])\n    n = int(data[1])\n    \n    ms = SortedSet()\n    ps = SortedSet([0, x])\n    ms.add(x)\n    \n    result = []\n    \n    for i in range(n):\n        v = int(data[i + 2])\n        l = ps[ps.bisect_left(v) - 1]\n        r = ps[ps.bisect_left(v)]\n        \n        ms.remove(r - l)\n        ms.add(r - v)\n        ms.add(v - l)\n        ps.add(v)\n        \n        result.append(ms[-1])\n    \n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1163",
        "hidden_test_path": "/id/hidden/1163",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "distinctvaluessubarrays3420",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Distinct Values Subarrays",
        "description": "Given an array of n integers, count the number of subarrays where each element is dictinct.\n\nInput\n\nThe first line has an integer n : the array size.\n\nThe second line has n integers x_1,x_2,…,x_n : the array contents.\n\nOutput\n\nPrint the number of subarrays with distinct elements.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4\n1 2 1 3\n\n\nOutput:\n\n\n8\n\n\nExplanation : The subarrays are [1] (two times), [2] , [3] , [1,2] , [1,3] , [2,1] and [2,1,3] .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\n\nfreq = defaultdict(int)\nr = 0\nans = 0\n\nfor l in range(n):\n    while r < n and freq[a[r]] == 0:\n        freq[a[r]] += 1\n        r += 1\n    ans += r - l\n    freq[a[l]] -= 1\n\nprint(ans)",
        "public_test_path": "/id/public/3420",
        "hidden_test_path": "/id/hidden/3420",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "distinctvaluessubsequences3421",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Distinct Values Subsequences",
        "description": "Given an array of n integers, count the number of subsequences where each element is dictinct.\n\nA subsequence is a sequence of array elements from left to right that may have gaps.\n\nInput\n\nThe first line has an integer n : the array size.\n\nThe second line has n integers x_1,x_2,…,x_n : the array contents.\n\nOutput\n\nPrint the number of subsequences with distinct elements. The answer can be large, so print it modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4\n1 2 1 3\n\n\nOutput:\n\n\n11\n\n\nExplanation : The subsequences are [1] (two times), [2] , [3] , [1,2] , [1,3] (two times), [2,1] , [2,3] , [1,2,3] and [2,1,3] .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport sys\n\nmod = 10**9 + 7\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    freq = defaultdict(int)\n    \n    for i in range(1, n + 1):\n        v = int(data[i])\n        freq[v] += 1\n    \n    ans = 1\n    for val in freq.values():\n        ans = ans * (val + 1) % mod\n    \n    print(ans - 1)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3421",
        "hidden_test_path": "/id/hidden/3421",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "roomallocation1164",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Room Allocation",
        "description": "There is a large hotel, and n customers will arrive soon. Each customer wants to have a single room.\n\nYou know each customer's arrival and departure day. Two customers can stay in the same room if the departure day of the first customer is earlier than the arrival day of the second customer.\n\nWhat is the minimum number of rooms that are needed to accommodate all customers? And how can the rooms be allocated?\n\nInput\n\nThe first input line contains an integer n : the number of customers.\n\nThen there are n lines, each of which describes one customer. Each line has two integers a and b : the arrival and departure day.\n\nOutput\n\nPrint first an integer k : the minimum number of rooms required.\n\nAfter that, print a line that contains the room number of each customer in the same order as in the input. The rooms are numbered 1,2,…,k . You can print any valid solution.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ a ≤ b ≤ 10^9\n\nExample\n\nInput:\n\n\n3\n1 2\n2 4\n4 4\n\n\nOutput:\n\n\n2\n1 2 1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    from bisect import bisect_left\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    v = []\n    \n    for i in range(n):\n        a, b = map(int, data[i + 1].split())\n        v.append((a, b, i))\n    \n    v.sort()\n    ends = []\n    ans = [0] * n\n    \n    for i in range(n):\n        if not ends or ends[0][0] >= v[i][0]:\n            ends.append((v[i][1], len(ends) + 1))\n            ans[v[i][2]] = len(ends)\n        else:\n            v1 = ends[0]\n            ans[v[i][2]] = v1[1]\n            ends[0] = (v[i][1], v1[1])\n            ends.sort()\n    \n    print(len(ends))\n    print(\" \".join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1164",
        "hidden_test_path": "/id/hidden/1164",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "factorymachines1620",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Factory Machines",
        "description": "A factory has n machines which can be used to make products. Your goal is to make a total of t products.\n\nFor each machine, you know the number of seconds it needs to make a single product. The machines can work simultaneously, and you can freely decide their schedule.\n\nWhat is the shortest time needed to make t products?\n\nInput\n\nThe first input line has two integers n and t : the number of machines and products.\n\nThe next line has n integers k_1,k_2,…,k_n : the time needed to make a product using each machine.\n\nOutput\n\nPrint one integer: the minimum time needed to make t products.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ t ≤ 10^9 1 ≤ k_i ≤ 10^9\n\nExample\n\nInput:\n\n\n3 7\n3 2 5\n\n\nOutput:\n\n\n8\n\n\nExplanation: Machine 1 makes two products, machine 2 makes four products and machine 3 makes one product.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    t = int(data[1])\n    a = list(map(int, data[2:n+2]))\n    \n    lo, hi = 0, 10**18\n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        t1 = 0\n        for i in range(n):\n            t1 += mid // a[i]\n            if t1 >= t:\n                break\n        if t1 >= t:\n            hi = mid\n        else:\n            lo = mid + 1\n    \n    print(lo)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1620",
        "hidden_test_path": "/id/hidden/1620",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "tasksanddeadlines1630",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Tasks and Deadlines",
        "description": "You have to process n tasks. Each task has a duration and a deadline, and you will process the tasks in some order one after another. Your reward for a task is d-f where d is its deadline and f is your finishing time. (The starting time is 0 , and you have to process all tasks even if a task would yield negative reward.)\n\nWhat is your maximum reward if you act optimally?\n\nInput\n\nThe first input line has an integer n : the number of tasks.\n\nAfter this, there are n lines that describe the tasks. Each line has two integers a and d : the duration and deadline of the task.\n\nOutput\n\nPrint one integer: the maximum reward.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ a,d ≤ 10^6\n\nExample\n\nInput:\n\n\n3\n6 10\n8 15\n5 12\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom typing import List, Tuple\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    v: List[Tuple[int, int]] = []\n    \n    for i in range(1, n + 1):\n        a, b = map(int, data[i].split())\n        v.append((a, b))\n    \n    ans = 0\n    v.sort()\n    curtime = 0\n    \n    for i in range(n):\n        curtime += v[i][0]\n        ans += v[i][1] - curtime\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1630",
        "hidden_test_path": "/id/hidden/1630",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    },
    {
        "problem_id": "readingbooks1631",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Reading Books",
        "description": "There are n books, and Kotivalo and Justiina are going to read them all. For each book, you know the time it takes to read it.\n\nThey both read each book from beginning to end, and they cannot read a book at the same time. What is the minimum total time required?\n\nInput\n\nThe first input line has an integer n : the number of books.\n\nThe second line has n integers t_1,t_2,…,t_n : the time required to read each book.\n\nOutput\n\nPrint one integer: the minimum total time.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ t_i ≤ 10^9\n\nExample\n\nInput:\n\n\n3\n2 8 3\n\n\nOutput:\n\n\n16",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    mx = 0\n    sum_ = 0\n    \n    for i in range(1, n + 1):\n        v = int(data[i])\n        mx = max(v, mx)\n        sum_ += v\n    \n    print(max(mx * 2, sum_))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1631",
        "hidden_test_path": "/id/hidden/1631",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "sumofthreevalues1641",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Sum of Three Values",
        "description": "You are given an array of n integers, and your task is to find three values (at distinct positions) whose sum is x .\n\nInput\n\nThe first input line has two integers n and x : the array size and the target sum.\n\nThe second line has n integers a_1,a_2,…,a_n : the array values.\n\nOutput\n\nPrint three integers: the positions of the values. If there are several solutions, you may print any of them. If there are no solutions, print IMPOSSIBLE .\n\nConstraints\n\n1 ≤ n ≤ 5000 1 ≤ x,a_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4 8\n2 7 5 1\n\n\nOutput:\n\n\n1 3 4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    a = [(int(data[i + 2]), i + 1) for i in range(n)]\n    \n    ans = [-1]\n    a.sort()\n    \n    for i in range(n):\n        r = n - 1\n        for l in range(i + 1, n):\n            if l >= r:\n                break\n            while a[l][0] + a[r][0] > x - a[i][0]:\n                r -= 1\n            if l >= r:\n                break\n            if a[l][0] + a[r][0] == x - a[i][0]:\n                ans = [a[i][1], a[l][1], a[r][1]]\n    \n    if ans[0] == -1:\n        print(\"IMPOSSIBLE\")\n    else:\n        print(\" \".join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1641",
        "hidden_test_path": "/id/hidden/1641",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 27
    },
    {
        "problem_id": "sumoffourvalues1642",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Sum of Four Values",
        "description": "You are given an array of n integers, and your task is to find four values (at distinct positions) whose sum is x .\n\nInput\n\nThe first input line has two integers n and x : the array size and the target sum.\n\nThe second line has n integers a_1,a_2,…,a_n : the array values.\n\nOutput\n\nPrint four integers: the positions of the values. If there are several solutions, you may print any of them. If there are no solutions, print IMPOSSIBLE .\n\nConstraints\n\n1 ≤ n ≤ 1000 1 ≤ x,a_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8 15\n3 2 5 8 1 3 2 3\n\n\nOutput:\n\n\n2 4 6 7",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:n+2]))\n\nprev = {}\nans = [-1]\n\nfor i in range(n):\n    for j in range(i):\n        if (a[i - 1] + a[j]) not in prev:\n            prev[a[i - 1] + a[j]] = (i + 1, j + 1)\n    for j in range(i + 1, n):\n        if (x - a[i] - a[j]) in prev:\n            p = prev[x - a[i] - a[j]]\n            ans = [p[0], p[1], i + 1, j + 1]\n\nif ans[0] == -1:\n    print(\"IMPOSSIBLE\")\nelse:\n    print(\" \".join(map(str, ans)))",
        "public_test_path": "/id/public/1642",
        "hidden_test_path": "/id/hidden/1642",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 33
    },
    {
        "problem_id": "nearestsmallervalues1645",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Nearest Smaller Values",
        "description": "Given an array of n integers, your task is to find for each array position the nearest position to its left having a smaller value.\n\nInput\n\nThe first input line has an integer n : the size of the array.\n\nThe second line has n integers x_1,x_2,…,x_n : the array values.\n\nOutput\n\nPrint n integers: for each array position the nearest position with a smaller value. If there is no such position, print 0 .\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8\n2 5 1 4 8 3 2 5\n\n\nOutput:\n\n\n0 1 0 3 4 3 3 7",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import deque\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nst = deque([(0, 0)])\n\nresult = []\nfor i in range(1, n + 1):\n    v = int(data[i])\n    while st[-1][0] >= v:\n        st.pop()\n    result.append(st[-1][1])\n    st.append((v, i))\n\nprint(\" \".join(map(str, result)))",
        "public_test_path": "/id/public/1645",
        "hidden_test_path": "/id/hidden/1645",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "subarraydivisibility1662",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Subarray Divisibility",
        "description": "Given an array of n integers, your task is to count the number of subarrays where the sum of values is divisible by n .\n\nInput\n\nThe first input line has an integer n : the size of the array.\n\nThe next line has n integers a_1,a_2,…,a_n : the contents of the array.\n\nOutput\n\nPrint one integer: the required number of subarrays.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 -10^9 ≤ a_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5\n3 1 2 7 4\n\n\nOutput:\n\n\n1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncur = 0\nans = 0\nprev = defaultdict(int)\nprev[0] += 1\n\nfor i in range(1, n + 1):\n    v = int(data[i])\n    cur += v\n    cur %= n\n    cur += n\n    cur %= n\n    ans += prev[cur]\n    prev[cur] += 1\n\nprint(ans)",
        "public_test_path": "/id/public/1662",
        "hidden_test_path": "/id/hidden/1662",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "arraydivision1085",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Array Division",
        "description": "You are given an array containing n positive integers.\n\nYour task is to divide the array into k subarrays so that the maximum sum in a subarray is as small as possible.\n\nInput\n\nThe first input line contains two integers n and k : the size of the array and the number of subarrays in the division.\n\nThe next line contains n integers x_1,x_2,…,x_n : the contents of the array.\n\nOutput\n\nPrint one integer: the maximum sum in a subarray in the optimal division.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ k ≤ n 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5 3\n2 4 7 3 5\n\n\nOutput:\n\n\n8\n\n\nExplanation: An optimal division is [2,4],[7],[3,5] where the sums of the subarrays are 6,7,8 . The largest sum is the last sum 8 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom bisect import bisect_left, bisect_right\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:n+2]))\n    \n    mx = max(a)\n    lo, hi = mx, 10**18\n    \n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        k1 = 0\n        l, r = 0, 0\n        sum_ = 0\n        \n        while l < n:\n            while r < n and sum_ + a[r] <= mid:\n                sum_ += a[r]\n                r += 1\n            k1 += 1\n            l = r\n            sum_ = 0\n        \n        if k1 <= k:\n            hi = mid\n        else:\n            lo = mid + 1\n    \n    print(lo)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1085",
        "hidden_test_path": "/id/hidden/1085",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 18
    },
    {
        "problem_id": "bookshop1158",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Book Shop",
        "description": "You are in a book shop which sells n different books. You know the price and number of pages of each book.\n\nYou have decided that the total price of your purchases will be at most x . What is the maximum number of pages you can buy? You can buy each book at most once.\n\nInput\n\nThe first input line contains two integers n and x : the number of books and the maximum total price.\n\nThe next line contains n integers h_1,h_2,…,h_n : the price of each book.\n\nThe last line contains n integers s_1,s_2,…,s_n : the number of pages of each book.\n\nOutput\n\nPrint one integer: the maximum number of pages.\n\nConstraints\n\n1 ≤ n ≤ 1000 1 ≤ x ≤ 10^5 1 ≤ h_i, s_i ≤ 1000\n\nExample\n\nInput:\n\n\n4 10\n4 8 5 3\n5 12 8 1\n\n\nOutput:\n\n\n13\n\n\nExplanation: You can buy books 1 and 3. Their price is 4+5=9 and the number of pages is 5+8=13 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Book:\n    def __init__(self, pages, price):\n        self.pages = pages\n        self.price = price\n\n    def __lt__(self, other):\n        return self.pages < other.pages\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    num_books, max_cost = map(int, data[0].split())\n    prices = list(map(int, data[1].split()))\n    pages = list(map(int, data[2].split()))\n    \n    books = [Book(pages[i], prices[i]) for i in range(num_books)]\n    books.sort()\n    \n    pages_per_price = [0] * (max_cost + 1)\n    \n    for book in books:\n        price = book.price\n        page = book.pages\n        for j in range(max_cost, price - 1, -1):\n            if pages_per_price[j] < page + pages_per_price[j - price]:\n                pages_per_price[j] = page + pages_per_price[j - price]\n    \n    print(pages_per_price[max_cost])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1158",
        "hidden_test_path": "/id/hidden/1158",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "countingtowers2413",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Counting Towers",
        "description": "Your task is to build a tower whose width is 2 and height is n . You have an unlimited supply of blocks whose width and height are integers.\n\nFor example, here are some possible solutions for n=6 : Given n , how many different towers can you build? Mirrored and rotated towers are counted separately if they look different.\n\nInput\n\nThe first input line contains an integer t : the number of tests.\n\nAfter this, there are t lines, and each line contains an integer n : the height of the tower.\n\nOutput\n\nFor each test, print the number of towers modulo 10^9+7 .\n\nConstraints\n\n1 ≤ t ≤ 100 1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\n3\n2\n6\n1337\n\n\nOutput:\n\n\n8\n2864\n640403945",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = int(1e9 + 7)\n\ndef mod(k):\n    return (k % MOD + MOD) % MOD\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    LIM = int(1e6 + 10)\n    precomp = [0] * LIM\n    precomp[0] = 1\n    sum1 = 1\n    sum3 = 1\n    \n    for i in range(1, LIM):\n        precomp[i] = mod(sum1 + sum3)\n        sum1 = mod(sum1 + precomp[i])\n        sum3 = mod(mod(3 * sum3) + precomp[i])\n    \n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n = int(data[i])\n        results.append(precomp[n])\n    \n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2413",
        "hidden_test_path": "/id/hidden/2413",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "editdistance1639",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Edit Distance",
        "description": "The edit distance between two strings is the minimum number of operations required to transform one string into the other.\n\nThe allowed operations are:\n\nAdd one character to the string. Remove one character from the string. Replace one character in the string.\n\nFor example, the edit distance between LOVE and MOVIE is 2, because you can first replace L with M, and then add I.\n\nYour task is to calculate the edit distance between two strings.\n\nInput\n\nThe first input line has a string that contains n characters between A–Z.\n\nThe second input line has a string that contains m characters between A–Z.\n\nOutput\n\nPrint one integer: the edit distance between the strings.\n\nConstraints\n\n1 ≤ n,m ≤ 5000\n\nExample\n\nInput:\n\n\nLOVE\nMOVIE\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    str1, str2 = data[0], data[1]\n    n, m = len(str1) + 1, len(str2) + 1\n    BLANK = -1\n    dp = [[BLANK] * m for _ in range(n)]\n    dp[0][0] = 0\n\n    def solve(i, j):\n        if dp[i][j] != BLANK:\n            return dp[i][j]\n        dp[i][j] = float('inf')\n        if i > 0 and j > 0:\n            dp[i][j] = min(dp[i][j], (str1[i - 1] != str2[j - 1]) + solve(i - 1, j - 1))\n        if i > 0:\n            dp[i][j] = min(dp[i][j], 1 + solve(i - 1, j))\n        if j > 0:\n            dp[i][j] = min(dp[i][j], 1 + solve(i, j - 1))\n        return dp[i][j]\n\n    print(solve(n - 1, m - 1))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1639",
        "hidden_test_path": "/id/hidden/1639",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 17
    },
    {
        "problem_id": "longestcommonsubsequence3403",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Longest Common Subsequence",
        "description": "Given two arrays of integers, find their longest common subsequence.\n\nA subsequence is a sequence of array elements from left to right that can contain gaps. A common subsequence is a subsequence that appears in both arrays.\n\nInput\n\nThe first line has two integers n and m : the sizes of the arrays.\n\nThe second line has n integers a_1,a_2,…,a_n : the contents of the first array.\n\nThe third line has m integers b_1,b_2,…,b_m : the contents of the second array.\n\nOutput\n\nFirst print the length of the longest common subsequence.\n\nAfter that, print an example of such a sequence. If there are several solutions, you can print any of them.\n\nConstraints\n\n1 ≤ n,m ≤ 1000 1 ≤ a_i, b_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8 6\n3 1 3 2 7 4 8 2\n6 5 1 2 3 4\n\n\nOutput:\n\n\n3\n1 2 4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:n+2]))\n    b = list(map(int, data[n+2:n+2+m]))\n    \n    dp = [[-1] * (m + 1) for _ in range(n + 1)]\n    \n    def go(i, j):\n        if i == n or j == m:\n            return 0\n        if dp[i][j] != -1:\n            return dp[i][j]\n        ans = max(go(i + 1, j), go(i, j + 1))\n        if a[i] == b[j]:\n            ans = max(ans, 1 + go(i + 1, j + 1))\n        dp[i][j] = ans\n        return ans\n    \n    ans = go(0, 0)\n    i, j = 0, 0\n    print(ans)\n    \n    while ans:\n        if go(i + 1, j) == ans:\n            i += 1\n            continue\n        if go(i, j + 1) == ans:\n            j += 1\n            continue\n        if a[i] == b[j] and 1 + go(i + 1, j + 1) == ans:\n            print(a[i], end=\" \")\n            ans -= 1\n            i += 1\n            j += 1\n            continue\n        assert False\n    \n    print()\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3403",
        "hidden_test_path": "/id/hidden/3403",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "rectanglecutting1744",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Rectangle Cutting",
        "description": "Given an a × b rectangle, your task is to cut it into squares. On each move you can select a rectangle and cut it into two rectangles in such a way that all side lengths remain integers. What is the minimum possible number of moves?\n\nInput\n\nThe only input line has two integers a and b .\n\nOutput\n\nPrint one integer: the minimum number of moves.\n\nConstraints\n\n1 ≤ a,b ≤ 500\n\nExample\n\nInput:\n\n\n3 5\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    BLANK = -1\n    dp = [[BLANK] * (b + 1) for _ in range(a + 1)]\n    \n    for i in range(min(a, b) + 1):\n        dp[i][i] = 0\n    \n    def solve(i, j):\n        if dp[i][j] != BLANK:\n            return dp[i][j]\n        dp[i][j] = float('inf')\n        for k in range(1, i):\n            dp[i][j] = min(dp[i][j], 1 + solve(k, j) + solve(i - k, j))\n        for k in range(1, j):\n            dp[i][j] = min(dp[i][j], 1 + solve(i, k) + solve(i, j - k))\n        return dp[i][j]\n    \n    print(solve(a, b))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1744",
        "hidden_test_path": "/id/hidden/1744",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 27
    },
    {
        "problem_id": "minimalgridpath3359",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Minimal Grid Path",
        "description": "You are given an n × n grid whose each square contains a letter.\n\nYou should move from the upper-left square to the lower-right square. You can only move right or down.\n\nWhat is the lexicographically minimal string you can construct?\n\nInput\n\nThe first line has an integer n : the size of the grid.\n\nAfter this, there are n lines that describe the grid. Each line has n letters between A and Z .\n\nOutput\n\nPrint the lexicographically minimal string.\n\nConstraints\n\n1 ≤ n ≤ 3000\n\nExample\n\nInput:\n\n\n4\nAACA\nBABC\nABDA\nAACA\n\n\nOutput:\n\n\nAAABACA",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    grid = data[1:n+1]\n    \n    ans = []\n    pos = [(0, 0)]\n    ans.append(grid[0][0])\n    \n    for _ in range(2 * (n - 1)):\n        best = chr(ord('Z') + 1)\n        for r, c in pos:\n            if r + 1 < n:\n                best = min(best, grid[r + 1][c])\n            if c + 1 < n:\n                best = min(best, grid[r][c + 1])\n        \n        ans.append(best)\n        new_pos = []\n        for r, c in pos:\n            if r + 1 < n and grid[r + 1][c] == best:\n                new_pos.append((r + 1, c))\n            if c + 1 < n and grid[r][c + 1] == best:\n                new_pos.append((r, c + 1))\n        \n        new_pos = list(set(new_pos))\n        new_pos.sort()\n        pos = new_pos\n    \n    print(\"\".join(ans))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3359",
        "hidden_test_path": "/id/hidden/3359",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "moneysums1745",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Money Sums",
        "description": "You have n coins with certain values. Your task is to find all money sums you can create using these coins.\n\nInput\n\nThe first input line has an integer n : the number of coins.\n\nThe next line has n integers x_1,x_2,…,x_n : the values of the coins.\n\nOutput\n\nFirst print an integer k : the number of distinct money sums. After this, print all possible sums in increasing order.\n\nConstraints\n\n1 ≤ n ≤ 100 1 ≤ x_i ≤ 1000\n\nExample\n\nInput:\n\n\n4\n4 2 5 2\n\n\nOutput:\n\n\n9\n2 4 5 6 7 8 9 11 13",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    LIM = int(1e5) + 10\n    dp = [False] * LIM\n    dp[0] = True\n    \n    index = 1\n    for _ in range(n):\n        v = int(data[index])\n        index += 1\n        for j in range(LIM - 1, v - 1, -1):\n            dp[j] |= dp[j - v]\n    \n    ans = [i for i in range(1, LIM) if dp[i]]\n    print(len(ans))\n    print(\" \".join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1745",
        "hidden_test_path": "/id/hidden/1745",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "removalgame1097",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Removal Game",
        "description": "There is a list of n numbers and two players who move alternately. On each move, a player removes either the first or last number from the list, and their score increases by that number. Both players try to maximize their scores.\n\nWhat is the maximum possible score for the first player when both players play optimally?\n\nInput\n\nThe first input line contains an integer n : the size of the list.\n\nThe next line has n integers x_1,x_2,…,x_n : the contents of the list.\n\nOutput\n\nPrint the maximum possible score for the first player.\n\nConstraints\n\n1 ≤ n ≤ 5000 -10^9 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4\n4 5 1 3\n\n\nOutput:\n\n\n8",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:n+1]))\n    total_sum = sum(a)\n    BLANK = -1\n    dp = [[BLANK] * n for _ in range(n)]\n    \n    def solve(i, j):\n        if i > j:\n            return 0\n        if dp[i][j] != BLANK:\n            return dp[i][j]\n        dp[i][j] = float('-inf')\n        dp[i][j] = max(a[i] - solve(i + 1, j), a[j] - solve(i, j - 1))\n        return dp[i][j]\n    \n    val = solve(0, n - 1)\n    av = (total_sum + val) // 2\n    print(av)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1097",
        "hidden_test_path": "/id/hidden/1097",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "mountainrange3314",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Mountain Range",
        "description": "There are n mountains in a row, each with a specific height. You begin your hang gliding route from some mountain.\n\nYou can glide from mountain a to mountain b if mountain a is taller than mountain b and all mountains between a and b .\n\nWhat is the maximum number of mountains you can visit on your route?\n\nInput\n\nThe first line has an integer n : the number of mountains.\n\nThe next line has n integers h_1, h_2,…, h_n : the heights of the mountains.\n\nOutput:\n\nPrint one integer: the maximum number of mountains.\n\nConstraints\n\n1≤ n ≤ 2 · 10^5 1≤ h_i ≤ 10^9\n\nExample\n\nInput:\n\n\n10\n20 15 17 35 25 40 12 19 13 12\n\n\nOutput:\n\n\n5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:n+1]))\n    \n    adj = [[] for _ in range(n)]\n    \n    for it in range(2):\n        st = [(int(1e9 + 1), -1)]\n        for i in range(n):\n            while st[-1][0] <= a[i]:\n                st.pop()\n            if len(st) > 1:\n                adj[it * (n - 1 - i) if it else i].append(it * (n - 1 - st[-1][1]) if it else st[-1][1])\n            st.append((a[i], i))\n        a.reverse()\n    \n    dp = [-1] * n\n    \n    def go(u):\n        if dp[u] != -1:\n            return dp[u]\n        dp[u] = 1\n        for v in adj[u]:\n            dp[u] = max(dp[u], 1 + go(v))\n        return dp[u]\n    \n    ans = 0\n    for i in range(n):\n        ans = max(ans, go(i))\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3314",
        "hidden_test_path": "/id/hidden/3314",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "increasingsubsequence1145",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Increasing Subsequence",
        "description": "You are given an array containing n integers. Your task is to determine the longest increasing subsequence in the array, i.e., the longest subsequence where every element is larger than the previous one.\n\nA subsequence is a sequence that can be derived from the array by deleting some elements without changing the order of the remaining elements.\n\nInput\n\nThe first line contains an integer n : the size of the array.\n\nAfter this there are n integers x_1,x_2,…,x_n : the contents of the array.\n\nOutput\n\nPrint the length of the longest increasing subsequence.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8\n7 3 5 3 6 2 9 8\n\n\nOutput:\n\n\n4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Node:\n    def __init__(self, lo, hi, v=None):\n        self.l = None\n        self.r = None\n        self.lo = lo\n        self.hi = hi\n        self.mset = float('inf')\n        self.madd = 0\n        self.val = -float('inf')\n        if v is not None:\n            if lo + 1 < hi:\n                mid = lo + (hi - lo) // 2\n                self.l = Node(lo, mid, v)\n                self.r = Node(mid, hi, v)\n                self.val = max(self.l.val, self.r.val)\n            else:\n                self.val = v[lo]\n\n    def query(self, L, R):\n        if R <= self.lo or self.hi <= L:\n            return -float('inf')\n        if L <= self.lo and self.hi <= R:\n            return self.val\n        self.push()\n        return max(self.l.query(L, R), self.r.query(L, R))\n\n    def set(self, L, R, x):\n        if R <= self.lo or self.hi <= L:\n            return\n        if L <= self.lo and self.hi <= R:\n            self.mset = self.val = x\n            self.madd = 0\n        else:\n            self.push()\n            self.l.set(L, R, x)\n            self.r.set(L, R, x)\n            self.val = max(self.l.val, self.r.val)\n\n    def add(self, L, R, x):\n        if R <= self.lo or self.hi <= L:\n            return\n        if L <= self.lo and self.hi <= R:\n            if self.mset != float('inf'):\n                self.mset += x\n            else:\n                self.madd += x\n            self.val += x\n        else:\n            self.push()\n            self.l.add(L, R, x)\n            self.r.add(L, R, x)\n            self.val = max(self.l.val, self.r.val)\n\n    def push(self):\n        if not self.l:\n            mid = self.lo + (self.hi - self.lo) // 2\n            self.l = Node(self.lo, mid)\n            self.r = Node(mid, self.hi)\n        if self.mset != float('inf'):\n            self.l.set(self.lo, self.hi, self.mset)\n            self.r.set(self.lo, self.hi, self.mset)\n            self.mset = float('inf')\n        elif self.madd:\n            self.l.add(self.lo, self.hi, self.madd)\n            self.r.add(self.lo, self.hi, self.madd)\n            self.madd = 0\n\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nfreq = set(a)\n\nlabel = {}\ncnt = 0\nfor i in sorted(freq):\n    label[i] = cnt\n    cnt += 1\n\nfor i in range(n):\n    a[i] = label[a[i]]\n\ntree = Node(0, cnt + 10)\ntree.set(0, cnt + 10, 0)\n\nfor i in range(n):\n    tree.set(a[i], a[i] + 1, 1 + max(0, tree.query(0, a[i])))\n\nans = tree.query(0, cnt + 5)\nprint(ans)",
        "public_test_path": "/id/public/1145",
        "hidden_test_path": "/id/hidden/1145",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 19
    },
    {
        "problem_id": "projects1140",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Projects",
        "description": "There are n projects you can attend. For each project, you know its starting and ending days and the amount of money you would get as reward. You can only attend one project during a day.\n\nWhat is the maximum amount of money you can earn?\n\nInput\n\nThe first input line contains an integer n : the number of projects.\n\nAfter this, there are n lines. Each such line has three integers a_i , b_i , and p_i : the starting day, the ending day, and the reward.\n\nOutput\n\nPrint one integer: the maximum amount of money you can earn.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ a_i ≤ b_i ≤ 10^9 1 ≤ p_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4\n2 4 4\n3 6 6\n6 8 2\n5 7 3\n\n\nOutput:\n\n\n7",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    proj = []\n    freq = set()\n    \n    for i in range(1, n + 1):\n        a, b, p = map(int, data[i].split())\n        proj.append([a, b, p])\n        freq.add(a)\n        freq.add(b)\n    \n    proj.sort()\n    cnt = 5\n    label = {}\n    \n    for i in freq:\n        label[i] = cnt\n        cnt += 1\n    \n    for i in range(n):\n        proj[i][0] = label[proj[i][0]]\n        proj[i][1] = label[proj[i][1]]\n        proj[i][1] += 1\n    \n    dp = [0] * (cnt + 10)\n    pnter = 0\n    \n    for i in range(len(dp)):\n        if i > 0:\n            dp[i] = max(dp[i], dp[i - 1])\n        while pnter < n and proj[pnter][0] == i:\n            dp[proj[pnter][1]] = max(dp[proj[pnter][1]], dp[i] + proj[pnter][2])\n            pnter += 1\n    \n    print(dp[-1])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1140",
        "hidden_test_path": "/id/hidden/1140",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "elevatorrides1653",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Elevator Rides",
        "description": "There are n people who want to get to the top of a building which has only one elevator. You know the weight of each person and the maximum allowed weight in the elevator. What is the minimum number of elevator rides?\n\nInput\n\nThe first input line has two integers n and x : the number of people and the maximum allowed weight in the elevator.\n\nThe second line has n integers w_1,w_2,…,w_n : the weight of each person.\n\nOutput\n\nPrint one integer: the minimum number of rides.\n\nConstraints\n\n1 ≤ n ≤ 20 1 ≤ x ≤ 10^9 1 ≤ w_i ≤ x\n\nExample\n\nInput:\n\n\n4 10\n4 8 6 1\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    w = list(map(int, data[2:n + 2]))\n    \n    dp = [(n + 1, 0)] * (1 << n)\n    dp[0] = (1, 0)\n    \n    for i in range(1 << n):\n        for j in range(n):\n            if (i & (1 << j)) == 0:\n                new_mask = i | (1 << j)\n                dp[new_mask] = min(dp[new_mask], \n                                   (dp[i][0] + (dp[i][1] + w[j] > x), \n                                    (dp[i][1] + w[j] > x and w[j] or dp[i][1] + w[j])))\n    \n    print(dp[(1 << n) - 1][0])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1653",
        "hidden_test_path": "/id/hidden/1653",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 39
    },
    {
        "problem_id": "countingtilings2181",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Counting Tilings",
        "description": "Your task is to count the number of ways you can fill an n × m grid using 1 × 2 and 2 × 1 tiles.\n\nInput\n\nThe only input line has two integers n and m .\n\nOutput\n\nPrint one integer: the number of ways modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 10 1 ≤ m ≤ 1000\n\nExample\n\nInput:\n\n\n4 7\n\n\nOutput:\n\n\n781",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = int(1e9 + 7)\nmaxn = 10\nmaxm = 1000\nmaxn2 = 1 << maxn\ntrans = [[] for _ in range(maxn2)]\ndp = [[0] * maxn2 for _ in range(maxm + 1)]\n\ndef bt(mask, mask2, idx):\n    if idx == n:\n        trans[mask].append(mask2)\n        return\n    if mask & (1 << idx):\n        bt(mask, mask2, idx + 1)\n    else:\n        bt(mask, mask2 | (1 << idx), idx + 1)\n        if idx + 1 < n and (mask & (1 << (idx + 1))) == 0:\n            bt(mask, mask2, idx + 2)\n\nn, m = map(int, input().split())\nn2 = 1 << n\n\nfor i in range(n2):\n    bt(i, 0, 0)\n\nsum_trans = sum(len(trans[i]) for i in range(n2))\ndp[0][0] = 1\n\nfor i in range(m):\n    for j in range(n2):\n        if dp[i][j] == 0:\n            continue\n        for j2 in trans[j]:\n            dp[i + 1][j2] += dp[i][j]\n            if dp[i + 1][j2] >= MOD:\n                dp[i + 1][j2] -= MOD\n\nprint(dp[m][0])",
        "public_test_path": "/id/public/2181",
        "hidden_test_path": "/id/hidden/2181",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "countingnumbers2220",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Counting Numbers",
        "description": "Your task is to count the number of integers between a and b where no two adjacent digits are the same.\n\nInput\n\nThe only input line has two integers a and b .\n\nOutput\n\nPrint one integer: the answer to the problem.\n\nConstraints\n\n0 ≤ a ≤ b ≤ 10^{18}\n\nExample\n\nInput:\n\n\n123 321\n\n\nOutput:\n\n\n171",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from sys import stdin, stdout\n\nBLANK = -1\ndp = []\nstr_digits = []\n\ndef solve(dig, curdigit, matched, leadingzeros):\n    if dp[dig][curdigit][matched][leadingzeros] != BLANK:\n        return dp[dig][curdigit][matched][leadingzeros]\n    if dig == 0:\n        dp[dig][curdigit][matched][leadingzeros] = not matched or curdigit <= str_digits[dig]\n        return dp[dig][curdigit][matched][leadingzeros]\n    LIM = str_digits[dig - 1] if matched else 9\n    dp[dig][curdigit][matched][leadingzeros] = 0\n    for i in range(LIM + 1):\n        if i == curdigit and not leadingzeros:\n            continue\n        newmatched = matched\n        newleadingzeros = leadingzeros\n        if leadingzeros and i != 0:\n            newleadingzeros = False\n        if newmatched and i < str_digits[dig - 1]:\n            newmatched = False\n        dp[dig][curdigit][matched][leadingzeros] += solve(dig - 1, i, newmatched, newleadingzeros)\n    return dp[dig][curdigit][matched][leadingzeros]\n\ndef calc(v):\n    if v < 0:\n        return 0\n    if v == 0:\n        return 1\n    global str_digits, dp\n    str_digits.clear()\n    while v > 0:\n        str_digits.append(v % 10)\n        v //= 10\n    dp = [[[ [BLANK for _ in range(2)] for _ in range(2)] for _ in range(10)] for _ in range(len(str_digits))]\n    ans = 0\n    for i in range(1 + str_digits[-1]):\n        val = solve(len(str_digits) - 1, i, i == str_digits[-1], i == 0)\n        ans += val\n    return ans\n\ndef main():\n    a, b = map(int, stdin.readline().split())\n    b1 = calc(b)\n    a1 = calc(a - 1)\n    stdout.write(f\"{b1 - a1}\\n\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2220",
        "hidden_test_path": "/id/hidden/2220",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "countingrooms1192",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Counting Rooms",
        "description": "You are given a map of a building, and your task is to count the number of its rooms. The size of the map is n × m squares, and each square is either floor or wall. You can walk left, right, up, and down through the floor squares.\n\nInput\n\nThe first input line has two integers n and m : the height and width of the map.\n\nThen there are n lines of m characters describing the map. Each character is either . (floor) or # (wall).\n\nOutput\n\nPrint one integer: the number of rooms.\n\nConstraints\n\n1 ≤ n,m ≤ 1000\n\nExample\n\nInput:\n\n\n5 8\n########\n#..#...#\n####.#.#\n#..#...#\n########\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m = map(int, data[0].split())\n    grid = [[0] * m for _ in range(n)]\n    \n    for i in range(n):\n        str_row = data[i + 1]\n        for j in range(m):\n            grid[i][j] = str_row[j] == '.'\n    \n    ds = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    numcomp = 0\n    component = [[-1] * m for _ in range(n)]\n    \n    def floodfill(i, j):\n        nonlocal numcomp\n        component[i][j] = numcomp\n        for k in range(4):\n            i1, j1 = i + ds[k][0], j + ds[k][1]\n            if 0 <= i1 < n and 0 <= j1 < m and component[i1][j1] == -1 and grid[i1][j1]:\n                floodfill(i1, j1)\n    \n    for i in range(n):\n        for j in range(m):\n            if component[i][j] == -1 and grid[i][j]:\n                floodfill(i, j)\n                numcomp += 1\n    \n    print(numcomp)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1192",
        "hidden_test_path": "/id/hidden/1192",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 19
    },
    {
        "problem_id": "labyrinth1193",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Labyrinth",
        "description": "You are given a map of a labyrinth, and your task is to find a path from start to end. You can walk left, right, up and down.\n\nInput\n\nThe first input line has two integers n and m : the height and width of the map.\n\nThen there are n lines of m characters describing the labyrinth. Each character is . (floor), # (wall), A (start), or B (end). There is exactly one A and one B in the input.\n\nOutput\n\nFirst print \"YES\", if there is a path, and \"NO\" otherwise.\n\nIf there is a path, print the length of the shortest such path and its description as a string consisting of characters L (left), R (right), U (up), and D (down). You can print any valid solution.\n\nConstraints\n\n1 ≤ n,m ≤ 1000\n\nExample\n\nInput:\n\n\n5 8\n########\n#.A#...#\n#.##.#B#\n#......#\n########\n\n\nOutput:\n\n\nYES\n9\nLDDRRRRRU",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, m = map(int, data[0].split())\ngrid = [[0] * m for _ in range(n)]\na = b = None\n\nfor i in range(n):\n    str_row = data[i + 1]\n    for j in range(m):\n        grid[i][j] = str_row[j] != '#'\n        if str_row[j] == 'A':\n            a = (i, j)\n        if str_row[j] == 'B':\n            b = (i, j)\n\nds = [(1, 0), (0, 1), (-1, 0), (0, -1)]\ndist = [[float('inf')] * m for _ in range(n)]\nvisited = [[False] * m for _ in range(n)]\npq = []\ndir = \"DRUL\"\n\ndist[a[0]][a[1]] = 0\nheapq.heappush(pq, (0, a))\n\nwhile pq:\n    d, (i, j) = heapq.heappop(pq)\n    if visited[i][j]:\n        continue\n    visited[i][j] = True\n    for k in range(4):\n        i1, j1 = i + ds[k][0], j + ds[k][1]\n        if 0 <= i1 < n and 0 <= j1 < m and not visited[i1][j1] and grid[i1][j1] and dist[i1][j1] > 1 + dist[i][j]:\n            dist[i1][j1] = 1 + dist[i][j]\n            heapq.heappush(pq, (dist[i1][j1], (i1, j1)))\n\nprint(\"YES\" if visited[b[0]][b[1]] else \"NO\")\n\nif visited[b[0]][b[1]]:\n    path = [b]\n    actions = []\n    while path[-1] != a:\n        i, j = path[-1]\n        for k in range(4):\n            i1, j1 = i + ds[k][0], j + ds[k][1]\n            if 0 <= i1 < n and 0 <= j1 < m and grid[i1][j1] and dist[i1][j1] == dist[i][j] - 1:\n                path.append((i1, j1))\n                actions.append((k + 2) % 4)\n                break\n    actions.reverse()\n    print(len(actions))\n    print(''.join(dir[action] for action in actions))",
        "public_test_path": "/id/public/1193",
        "hidden_test_path": "/id/hidden/1193",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 17
    },
    {
        "problem_id": "buildingroads1666",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Building Roads",
        "description": "Byteland has n cities, and m roads between them. The goal is to construct new roads so that there is a route between any two cities.\n\nYour task is to find out the minimum number of roads required, and also determine which roads should be built.\n\nInput\n\nThe first input line has two integers n and m : the number of cities and roads. The cities are numbered 1,2,…,n .\n\nAfter that, there are m lines describing the roads. Each line has two integers a and b : there is a road between those cities.\n\nA road always connects two different cities, and there is at most one road between any two cities.\n\nOutput\n\nFirst print an integer k : the number of required roads.\n\nThen, print k lines that describe the new roads. You can print any valid solution.\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n4 2\n1 2\n3 4\n\n\nOutput:\n\n\n1\n2 3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class UF:\n    def __init__(self, n):\n        self.e = [-1] * n\n\n    def same_set(self, a, b):\n        return self.find(a) == self.find(b)\n\n    def size(self, x):\n        return -self.e[self.find(x)]\n\n    def find(self, x):\n        if self.e[x] < 0:\n            return x\n        self.e[x] = self.find(self.e[x])\n        return self.e[x]\n\n    def join(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return False\n        if self.e[a] > self.e[b]:\n            a, b = b, a\n        self.e[a] += self.e[b]\n        self.e[b] = a\n        return True\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    uf = UF(n)\n    index = 2\n    for _ in range(m):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        uf.join(a, b)\n        index += 2\n\n    roads = []\n    comps = []\n    for i in range(n):\n        if uf.find(i) == i:\n            if comps:\n                roads.append((comps[-1] + 1, i + 1))\n            comps.append(i)\n\n    print(len(comps) - 1)\n    for p in roads:\n        print(p[0], p[1])\n\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1666",
        "hidden_test_path": "/id/hidden/1666",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "messageroute1667",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Message Route",
        "description": "Syrjälä's network has n computers and m connections. Your task is to find out if Uolevi can send a message to Maija, and if it is possible, what is the minimum number of computers on such a route.\n\nInput\n\nThe first input line has two integers n and m : the number of computers and connections. The computers are numbered 1,2,…,n . Uolevi's computer is 1 and Maija's computer is n .\n\nThen, there are m lines describing the connections. Each line has two integers a and b : there is a connection between those computers.\n\nEvery connection is between two different computers, and there is at most one connection between any two computers.\n\nOutput\n\nIf it is possible to send a message, first print k : the minimum number of computers on a valid route. After this, print an example of such a route. You can print any valid solution.\n\nIf there are no routes, print \"IMPOSSIBLE\".\n\nConstraints\n\n2 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 5\n1 2\n1 3\n1 4\n2 3\n5 4\n\n\nOutput:\n\n\n3\n1 4 5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\nindex = 0\n\nn = int(data[index])\nindex += 1\nm = int(data[index])\nindex += 1\n\nadj = [[] for _ in range(n)]\nfor _ in range(m):\n    a = int(data[index]) - 1\n    index += 1\n    b = int(data[index]) - 1\n    index += 1\n    adj[a].append(b)\n    adj[b].append(a)\n\ndist = [float('inf')] * n\nvisited = [False] * n\npq = []\n\ndist[0] = 0\nheapq.heappush(pq, (0, 0))\n\nwhile pq:\n    d, u = heapq.heappop(pq)\n    if visited[u]:\n        continue\n    visited[u] = True\n    for v in adj[u]:\n        if not visited[v] and dist[v] > 1 + dist[u]:\n            dist[v] = 1 + dist[u]\n            heapq.heappush(pq, (dist[v], v))\n\nif visited[n - 1]:\n    path = [n - 1]\n    while path[-1] != 0:\n        for v in adj[path[-1]]:\n            if dist[v] == dist[path[-1]] - 1:\n                path.append(v)\n                break\n    path.reverse()\n    print(len(path))\n    print(\" \".join(str(i + 1) for i in path))\nelse:\n    print(\"IMPOSSIBLE\")",
        "public_test_path": "/id/public/1667",
        "hidden_test_path": "/id/hidden/1667",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "buildingteams1668",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Building Teams",
        "description": "There are n pupils in Uolevi's class, and m friendships between them. Your task is to divide the pupils into two teams in such a way that no two pupils in a team are friends. You can freely choose the sizes of the teams.\n\nInput\n\nThe first input line has two integers n and m : the number of pupils and friendships. The pupils are numbered 1,2,…,n .\n\nThen, there are m lines describing the friendships. Each line has two integers a and b : pupils a and b are friends.\n\nEvery friendship is between two different pupils. You can assume that there is at most one friendship between any two pupils.\n\nOutput\n\nPrint an example of how to build the teams. For each pupil, print \"1\" or \"2\" depending on to which team the pupil will be assigned. You can print any valid team.\n\nIf there are no solutions, print \"IMPOSSIBLE\".\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 3\n1 2\n1 3\n4 5\n\n\nOutput:\n\n\n1 2 2 1 2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    adj = [[] for _ in range(n)]\n    index = 2\n    for _ in range(m):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        adj[a].append(b)\n        adj[b].append(a)\n        index += 2\n    \n    visited = [False] * n\n    parity = [0] * n\n    \n    def dfs(i, p):\n        visited[i] = True\n        parity[i] = p\n        for j in adj[i]:\n            if not visited[j]:\n                dfs(j, 1 - p)\n    \n    for i in range(n):\n        if not visited[i]:\n            dfs(i, 0)\n    \n    works = True\n    for i in range(n):\n        for j in adj[i]:\n            if parity[i] == parity[j]:\n                works = False\n    \n    if works:\n        print(\" \".join(str(1 + parity[i]) for i in range(n)))\n    else:\n        print(\"IMPOSSIBLE\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1668",
        "hidden_test_path": "/id/hidden/1668",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "roundtrip1669",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Round Trip",
        "description": "Byteland has n cities and m roads between them. Your task is to design a round trip that begins in a city, goes through two or more other cities, and finally returns to the starting city. Every intermediate city on the route has to be distinct.\n\nInput\n\nThe first input line has two integers n and m : the number of cities and roads. The cities are numbered 1,2,…,n .\n\nThen, there are m lines describing the roads. Each line has two integers a and b : there is a road between those cities.\n\nEvery road is between two different cities, and there is at most one road between any two cities.\n\nOutput\n\nFirst print an integer k : the number of cities on the route. Then print k cities in the order they will be visited. You can print any valid solution.\n\nIf there are no solutions, print \"IMPOSSIBLE\".\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 6\n1 3\n1 2\n5 3\n1 5\n2 4\n4 5\n\n\nOutput:\n\n\n4\n3 5 1 3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    adj = defaultdict(list)\n    index = 2\n    for _ in range(m):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        adj[a].append(b)\n        adj[b].append(a)\n        index += 2\n\n    visited = [False] * n\n    path = []\n    paths = set()\n\n    def dfs(i, pre):\n        visited[i] = True\n        for j in adj[i]:\n            if j == pre:\n                continue\n            if j in paths:\n                path.append(j)\n                return True\n            if not visited[j]:\n                path.append(j)\n                paths.add(j)\n                if dfs(j, i):\n                    return True\n                path.pop()\n                paths.remove(j)\n        return False\n\n    for i in range(n):\n        path.append(i)\n        paths.add(i)\n        if dfs(i, -1):\n            break\n        paths.clear()\n        path.clear()\n\n    works = len(path) > 0 and path[-1] in paths\n    if works:\n        st = 0\n        while path[st] != path[-1]:\n            st += 1\n        print(len(path) - st)\n        print(\" \".join(str(1 + path[i]) for i in range(st, len(path))))\n    else:\n        print(\"IMPOSSIBLE\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1669",
        "hidden_test_path": "/id/hidden/1669",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 26
    },
    {
        "problem_id": "monsters1194",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Monsters",
        "description": "You and some monsters are in a labyrinth. When taking a step to some direction in the labyrinth, each monster may simultaneously take one as well. Your goal is to reach one of the boundary squares without ever sharing a square with a monster.\n\nYour task is to find out if your goal is possible, and if it is, print a path that you can follow. Your plan has to work in any situation; even if the monsters know your path beforehand.\n\nInput\n\nThe first input line has two integers n and m : the height and width of the map.\n\nAfter this there are n lines of m characters describing the map. Each character is . (floor), # (wall), A (start), or M (monster). There is exactly one A in the input.\n\nOutput\n\nFirst print \"YES\" if your goal is possible, and \"NO\" otherwise.\n\nIf your goal is possible, also print an example of a valid path (the length of the path and its description using characters D , U , L , and R ). You can print any path, as long as its length is at most n · m steps.\n\nConstraints\n\n1 ≤ n,m ≤ 1000\n\nExample\n\nInput:\n\n\n5 8\n########\n#M..A..#\n#.#.M#.#\n#M#..#..\n#.######\n\n\nOutput:\n\n\nYES\n5\nRRDDR",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, m = map(int, data[0].split())\ngrid = [[0] * m for _ in range(n)]\na = None\nds = [(1, 0), (0, 1), (-1, 0), (0, -1)]\ndist = [[float('inf')] * m for _ in range(n)]\nvisited = [[0] * m for _ in range(n)]\npq = []\nmonsters = []\n\nfor i in range(n):\n    str_row = data[i + 1]\n    for j in range(m):\n        grid[i][j] = str_row[j] != '#'\n        if str_row[j] == 'A':\n            a = (i, j)\n        if str_row[j] == 'M':\n            monsters.append((i, j))\n            dist[i][j] = 0\n            heapq.heappush(pq, (0, (i, j)))\n\ndir = \"DRUL\"\n\nwhile pq:\n    p = heapq.heappop(pq)\n    i, j = p[1]\n    if visited[i][j]:\n        continue\n    visited[i][j] = 1\n    for k in range(4):\n        i1, j1 = i + ds[k][0], j + ds[k][1]\n        if 0 <= i1 < n and 0 <= j1 < m and not visited[i1][j1] and grid[i1][j1] and dist[i1][j1] > 1 + dist[i][j]:\n            dist[i1][j1] = 1 + dist[i][j]\n            heapq.heappush(pq, (dist[i1][j1], (i1, j1)))\n\nactions = []\nvisited = [[0] * m for _ in range(n)]\n\ndef dfs(i, j, d):\n    visited[i][j] = 1\n    if i == 0 or i == n - 1 or j == 0 or j == m - 1:\n        return True\n    for k in range(4):\n        i1, j1 = i + ds[k][0], j + ds[k][1]\n        if 0 <= i1 < n and 0 <= j1 < m and not visited[i1][j1] and grid[i1][j1] and dist[i1][j1] > 1 + d:\n            actions.append(k)\n            if dfs(i1, j1, d + 1):\n                return True\n            actions.pop()\n    return False\n\nres = dfs(a[0], a[1], 0)\nif res:\n    print(\"YES\")\n    print(len(actions))\n    print(''.join(dir[i] for i in actions))\nelse:\n    print(\"NO\")",
        "public_test_path": "/id/public/1194",
        "hidden_test_path": "/id/hidden/1194",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 28
    },
    {
        "problem_id": "highscore1673",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "High Score",
        "description": "You play a game consisting of n rooms and m tunnels. Your initial score is 0 , and each tunnel increases your score by x where x may be both positive or negative. You may go through a tunnel several times.\n\nYour task is to walk from room 1 to room n . What is the maximum score you can get?\n\nInput\n\nThe first input line has two integers n and m : the number of rooms and tunnels. The rooms are numbered 1,2,…,n .\n\nThen, there are m lines describing the tunnels. Each line has three integers a , b and x : the tunnel starts at room a , ends at room b , and it increases your score by x . All tunnels are one-way tunnels.\n\nYou can assume that it is possible to get from room 1 to room n .\n\nOutput\n\nPrint one integer: the maximum score you can get. However, if you can get an arbitrarily large score, print -1 .\n\nConstraints\n\n1 ≤ n ≤ 2500 1 ≤ m ≤ 5000 1 ≤ a,b ≤ n -10^9 ≤ x ≤ 10^9\n\nExample\n\nInput:\n\n\n4 5\n1 2 3\n2 4 -1\n1 3 -2\n3 4 7\n1 4 4\n\n\nOutput:\n\n\n5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, m = map(int, data[0].split())\nadj = defaultdict(list)\nradj = defaultdict(list)\n\nfor i in range(1, m + 1):\n    a, b, w = map(int, data[i].split())\n    a -= 1\n    b -= 1\n    adj[a].append((b, w))\n    radj[b].append(a)\n\nBAD = -1_000_000_000_000_000\ndist = [BAD] * n\ndist[0] = 0\nleads = [0] * n\nvisited = [0] * n\n\ndef dfs(i):\n    if visited[i]:\n        return\n    visited[i] = 1\n    leads[i] = 1\n    for j in radj[i]:\n        dfs(j)\n\ndfs(n - 1)\n\nfor t in range(m):\n    for i in range(n):\n        if dist[i] <= BAD:\n            continue\n        for p in adj[i]:\n            if dist[i] + p[1] > dist[p[0]]:\n                dist[p[0]] = dist[i] + p[1]\n\nhascycle = False\nfor i in range(n):\n    if dist[i] <= BAD:\n        continue\n    for p in adj[i]:\n        if leads[p[0]] and dist[i] + p[1] > dist[p[0]]:\n            hascycle = True\n\nif hascycle:\n    print(\"-1\")\nelse:\n    print(dist[n - 1])",
        "public_test_path": "/id/public/1673",
        "hidden_test_path": "/id/hidden/1673",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 44
    },
    {
        "problem_id": "flightdiscount1195",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Flight Discount",
        "description": "Your task is to find a minimum-price flight route from Syrjälä to Metsälä. You have one discount coupon, using which you can halve the price of any single flight during the route. However, you can only use the coupon once.\n\nWhen you use the discount coupon for a flight whose price is x , its price becomes ⌊ x/2 ⌋ (it is rounded down to an integer).\n\nInput\n\nThe first input line has two integers n and m : the number of cities and flight connections. The cities are numbered 1,2,…,n . City 1 is Syrjälä, and city n is Metsälä.\n\nAfter this there are m lines describing the flights. Each line has three integers a , b , and c : a flight begins at city a , ends at city b , and its price is c . Each flight is unidirectional.\n\nYou can assume that it is always possible to get from Syrjälä to Metsälä.\n\nOutput\n\nPrint one integer: the price of the cheapest route from Syrjälä to Metsälä.\n\nConstraints\n\n2 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n 1 ≤ c ≤ 10^9\n\nExample\n\nInput:\n\n\n3 4\n1 2 3\n2 3 1\n1 3 7\n2 1 5\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\nindex = 0\n\nn = int(data[index])\nindex += 1\nm = int(data[index])\nindex += 1\n\nadj = [[] for _ in range(n * 2)]\nfor _ in range(m):\n    a = int(data[index]) - 1\n    index += 1\n    b = int(data[index]) - 1\n    index += 1\n    w = int(data[index])\n    index += 1\n    adj[a * 2].append((b * 2, w))\n    adj[a * 2 + 1].append((b * 2 + 1, w))\n    adj[a * 2].append((b * 2 + 1, w / 2))\n\ndist = [float('inf')] * (2 * n)\ndist[0] = 0\nvisited = [False] * (2 * n)\npq = [(0, 0)]\n\nwhile pq:\n    d, u = heapq.heappop(pq)\n    if visited[u]:\n        continue\n    visited[u] = True\n    for v, weight in adj[u]:\n        if dist[v] > dist[u] + weight:\n            dist[v] = dist[u] + weight\n            heapq.heappush(pq, (dist[v], v))\n\nprint(min(dist[2 * (n - 1)], dist[2 * (n - 1) + 1]))",
        "public_test_path": "/id/public/1195",
        "hidden_test_path": "/id/hidden/1195",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 24
    },
    {
        "problem_id": "cyclefinding1197",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Cycle Finding",
        "description": "You are given a directed graph, and your task is to find out if it contains a negative cycle, and also give an example of such a cycle.\n\nInput\n\nThe first input line has two integers n and m : the number of nodes and edges. The nodes are numbered 1,2,…,n .\n\nAfter this, the input has m lines describing the edges. Each line has three integers a , b , and c : there is an edge from node a to node b whose length is c .\n\nOutput\n\nIf the graph contains a negative cycle, print first \"YES\", and then the nodes in the cycle in their correct order. If there are several negative cycles, you can print any of them. If there are no negative cycles, print \"NO\".\n\nConstraints\n\n1 ≤ n ≤ 2500 1 ≤ m ≤ 5000 1 ≤ a,b ≤ n -10^9 ≤ c ≤ 10^9\n\nExample\n\nInput:\n\n\n4 5\n1 2 1\n2 4 1\n3 1 1\n4 1 -3\n4 3 -2\n\n\nOutput:\n\n\nYES\n1 2 4 1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m = map(int, data[0].split())\n    adj = defaultdict(list)\n    \n    for i in range(1, m + 1):\n        a, b, c = map(int, data[i].split())\n        a -= 1\n        b -= 1\n        adj[a].append((b, c))\n    \n    path = []\n    works = False\n    visited = [False] * n\n\n    def dfs(cur, d):\n        nonlocal works\n        path.append(cur)\n        visited[cur] = True\n        \n        if len(path) > 1 and path[0] == path[-1]:\n            return d < 0\n        \n        for p in adj[cur]:\n            if (not visited[p[0]] or p[0] == path[0]) and d + p[1] <= 0:\n                if dfs(p[0], d + p[1]):\n                    return True\n        \n        path.pop()\n        return False\n\n    for i in range(n):\n        if dfs(i, 0):\n            works = True\n            break\n\n    if works:\n        print(\"YES\")\n        print(\" \".join(str(i + 1) for i in path))\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1197",
        "hidden_test_path": "/id/hidden/1197",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 27
    },
    {
        "problem_id": "flightroutes1196",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Flight Routes",
        "description": "Your task is to find the k shortest flight routes from Syrjälä to Metsälä. A route can visit the same city several times.\n\nNote that there can be several routes with the same price and each of them should be considered (see the example).\n\nInput\n\nThe first input line has three integers n , m , and k : the number of cities, the number of flights, and the parameter k . The cities are numbered 1,2,…,n . City 1 is Syrjälä, and city n is Metsälä.\n\nAfter this, the input has m lines describing the flights. Each line has three integers a , b , and c : a flight begins at city a , ends at city b , and its price is c . All flights are one-way flights.\n\nYou may assume that there are at least k distinct routes from Syrjälä to Metsälä.\n\nOutput\n\nPrint k integers: the prices of the k cheapest routes sorted according to their prices.\n\nConstraints\n\n2 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n 1 ≤ c ≤ 10^9 1 ≤ k ≤ 10\n\nExample\n\nInput:\n\n\n4 6 3\n1 2 1\n1 3 3\n2 3 2\n2 4 6\n3 2 8\n3 4 1\n\n\nOutput:\n\n\n4 4 7\n\n\nExplanation: The cheapest routes are 1 → 3 → 4 (price 4 ), 1 → 2 → 3 → 4 (price 4 ) and 1 → 2 → 4 (price 7 ).",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport heapq\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\nindex = 0\n\nn = int(data[index])\nindex += 1\nm = int(data[index])\nindex += 1\nk = int(data[index])\nindex += 1\n\nadj = defaultdict(list)\nfor _ in range(m):\n    a = int(data[index]) - 1\n    index += 1\n    b = int(data[index]) - 1\n    index += 1\n    c = int(data[index])\n    index += 1\n    adj[a].append((b, c))\n\ndist = [set() for _ in range(n)]\nprocessed = [0] * n\npq = []\ndist[0].add(0)\nheapq.heappush(pq, (0, 0))\n\nwhile pq:\n    d, node = heapq.heappop(pq)\n    if processed[node] >= k:\n        continue\n    processed[node] += 1\n    for e in adj[node]:\n        newdist = d + e[1]\n        if len(dist[e[0]]) < k or max(dist[e[0]]) > newdist:\n            if len(dist[e[0]]) >= k:\n                dist[e[0]].remove(max(dist[e[0]]))\n            dist[e[0]].add(newdist)\n            heapq.heappush(pq, (newdist, e[0]))\n\nprint(\" \".join(map(str, sorted(dist[n - 1]))))",
        "public_test_path": "/id/public/1196",
        "hidden_test_path": "/id/hidden/1196",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 17
    },
    {
        "problem_id": "courseschedule1679",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Course Schedule",
        "description": "You have to complete n courses. There are m requirements of the form \"course a has to be completed before course b \". Your task is to find an order in which you can complete the courses.\n\nInput\n\nThe first input line has two integers n and m : the number of courses and requirements. The courses are numbered 1,2,…,n .\n\nAfter this, there are m lines describing the requirements. Each line has two integers a and b : course a has to be completed before course b .\n\nOutput\n\nPrint an order in which you can complete the courses. You can print any valid order that includes all the courses.\n\nIf there are no solutions, print \"IMPOSSIBLE\".\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 3\n1 2\n3 1\n4 5\n\n\nOutput:\n\n\n3 4 1 5 2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m = map(int, data[0].split())\n    adj = defaultdict(list)\n    \n    for i in range(1, m + 1):\n        a, b = map(int, data[i].split())\n        a -= 1\n        b -= 1\n        adj[a].append(b)\n\n    visited = [0] * n\n    order = []\n    hascycle = False\n\n    def dfs(cur, pre):\n        nonlocal hascycle\n        visited[cur] = 1\n        for i in adj[cur]:\n            if i == pre:\n                continue\n            if visited[i] == 1:\n                hascycle = True\n                return True\n            if visited[i] == 2:\n                continue\n            if dfs(i, cur):\n                return True\n\n        visited[cur] = 2\n        order.append(cur)\n        return False\n\n    for i in range(n):\n        if visited[i] == 0 and dfs(i, -1):\n            break\n\n    order.reverse()\n    revorder = [0] * n\n    for i in range(len(order)):\n        revorder[order[i]] = i\n\n    if not hascycle:\n        for i in range(n):\n            for j in adj[i]:\n                if revorder[j] < revorder[i]:\n                    hascycle = True\n\n    if hascycle:\n        print(\"IMPOSSIBLE\")\n    else:\n        print(\" \".join(str(i + 1) for i in order))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1679",
        "hidden_test_path": "/id/hidden/1679",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 17
    },
    {
        "problem_id": "longestflightroute1680",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Longest Flight Route",
        "description": "Uolevi has won a contest, and the prize is a free flight trip that can consist of one or more flights through cities. Of course, Uolevi wants to choose a trip that has as many cities as possible.\n\nUolevi wants to fly from Syrjälä to Lehmälä so that he visits the maximum number of cities. You are given the list of possible flights, and you know that there are no directed cycles in the flight network.\n\nInput\n\nThe first input line has two integers n and m : the number of cities and flights. The cities are numbered 1,2,…,n . City 1 is Syrjälä, and city n is Lehmälä.\n\nAfter this, there are m lines describing the flights. Each line has two integers a and b : there is a flight from city a to city b . Each flight is a one-way flight.\n\nOutput\n\nFirst print the maximum number of cities on the route. After this, print the cities in the order they will be visited. You can print any valid solution.\n\nIf there are no solutions, print \"IMPOSSIBLE\".\n\nConstraints\n\n2 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 5\n1 2\n2 5\n1 3\n3 4\n4 5\n\n\nOutput:\n\n\n4\n1 3 4 5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, m = map(int, data[0].split())\nadj = defaultdict(list)\n\nfor i in range(1, m + 1):\n    a, b = map(int, data[i].split())\n    a -= 1\n    b -= 1\n    adj[a].append(b)\n\nBLANK = float('-inf')\nlow = -1e8\ndist = [BLANK] * n\n\ndef solve(cur):\n    if dist[cur] != BLANK:\n        return dist[cur]\n    if cur == n - 1:\n        dist[cur] = 0\n        return dist[cur]\n    dist[cur] = 0\n    for i in adj[cur]:\n        dist[cur] = max(dist[cur], 1 + solve(i))\n    if dist[cur] == 0 and cur != n - 1:\n        dist[cur] = low\n    return dist[cur]\n\nsolve(0)\n\nif dist[0] >= 0:\n    path = [0]\n    while dist[path[-1]] > 0:\n        for i in adj[path[-1]]:\n            if dist[i] == dist[path[-1]] - 1:\n                path.append(i)\n                break\n    print(len(path))\n    print(\" \".join(str(i + 1) for i in path))\nelse:\n    print(\"IMPOSSIBLE\")",
        "public_test_path": "/id/public/1680",
        "hidden_test_path": "/id/hidden/1680",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 25
    },
    {
        "problem_id": "gameroutes1681",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Game Routes",
        "description": "A game has n levels, connected by m teleporters, and your task is to get from level 1 to level n . The game has been designed so that there are no directed cycles in the underlying graph. In how many ways can you complete the game?\n\nInput\n\nThe first input line has two integers n and m : the number of levels and teleporters. The levels are numbered 1,2,…,n .\n\nAfter this, there are m lines describing the teleporters. Each line has two integers a and b : there is a teleporter from level a to level b .\n\nOutput\n\nPrint one integer: the number of ways you can complete the game. Since the result may be large, print it modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n4 5\n1 2\n2 4\n1 3\n3 4\n1 4\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = int(1e9 + 7)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    adj = [[] for _ in range(n)]\n    index = 2\n    for _ in range(m):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        adj[a].append(b)\n        index += 2\n    \n    BLANK = -1\n    ways = [BLANK] * n\n    \n    def solve(cur):\n        if ways[cur] != BLANK:\n            return ways[cur]\n        if cur == n - 1:\n            return (ways[cur] := 1)\n        ways[cur] = 0\n        for i in adj[cur]:\n            ways[cur] = (ways[cur] + solve(i)) % MOD\n        return ways[cur]\n    \n    print(solve(0))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1681",
        "hidden_test_path": "/id/hidden/1681",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "investigation1202",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Investigation",
        "description": "You are going to travel from Syrjälä to Lehmälä by plane. You would like to find answers to the following questions:\n\nwhat is the minimum price of such a route? how many minimum-price routes are there? (modulo 10^9+7) what is the minimum number of flights in a minimum-price route? what is the maximum number of flights in a minimum-price route?\n\nInput\n\nThe first input line contains two integers n and m : the number of cities and the number of flights. The cities are numbered 1,2,…,n . City 1 is Syrjälä, and city n is Lehmälä.\n\nAfter this, there are m lines describing the flights. Each line has three integers a , b , and c : there is a flight from city a to city b with price c . All flights are one-way flights.\n\nYou may assume that there is a route from Syrjälä to Lehmälä.\n\nOutput\n\nPrint four integers according to the problem statement.\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n 1 ≤ c ≤ 10^9\n\nExample\n\nInput:\n\n\n4 5\n1 4 5\n1 2 4\n2 4 5\n1 3 2\n3 4 3\n\n\nOutput:\n\n\n5 2 1 2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport heapq\n\nMOD = int(1e9 + 7)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    wadj = [[] for _ in range(n)]\n    adj = [[] for _ in range(n)]\n    \n    index = 2\n    for _ in range(m):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        w = int(data[index + 2])\n        index += 3\n        wadj[a].append((b, w))\n    \n    dist = [float('inf')] * n\n    dist[0] = 0\n    visited = [False] * n\n    pq = [(0, 0)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if visited[u]:\n            continue\n        visited[u] = True\n        for v, weight in wadj[u]:\n            if dist[v] > dist[u] + weight:\n                dist[v] = dist[u] + weight\n                heapq.heappush(pq, (dist[v], v))\n    \n    for i in range(n):\n        for p in wadj[i]:\n            if dist[i] + p[1] == dist[p[0]]:\n                adj[i].append(p[0])\n    \n    print(dist[n - 1], end=\" \")\n    \n    BLANK = -1\n    ways = [BLANK] * n\n    \n    def solve(cur):\n        if ways[cur] != BLANK:\n            return ways[cur]\n        if cur == n - 1:\n            return (ways[cur] := 1)\n        ways[cur] = 0\n        for i in adj[cur]:\n            ways[cur] = (ways[cur] + solve(i)) % MOD\n        return ways[cur]\n    \n    print(solve(0), end=\" \")\n    \n    dist1 = [BLANK] * n\n    \n    def solve3(cur):\n        if dist1[cur] != BLANK:\n            return dist1[cur]\n        if cur == n - 1:\n            dist1[cur] = 0\n            return dist1[cur]\n        dist1[cur] = int(1e8)\n        for i in adj[cur]:\n            dist1[cur] = min(dist1[cur], 1 + solve3(i))\n        return dist1[cur]\n    \n    solve3(0)\n    print(dist1[0], end=\" \")\n    \n    BLANK = float('-inf')\n    low = -int(1e8)\n    dist1 = [BLANK] * n\n    \n    def solve2(cur):\n        if dist1[cur] != BLANK:\n            return dist1[cur]\n        if cur == n - 1:\n            dist1[cur] = 0\n            return dist1[cur]\n        dist1[cur] = 0\n        for i in adj[cur]:\n            dist1[cur] = max(dist1[cur], 1 + solve2(i))\n        if dist1[cur] == 0 and cur != n - 1:\n            dist1[cur] = low\n        return dist1[cur]\n    \n    solve2(0)\n    print(dist1[0])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1202",
        "hidden_test_path": "/id/hidden/1202",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "planetscycles1751",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Planets Cycles",
        "description": "You are playing a game consisting of n planets. Each planet has a teleporter to another planet (or the planet itself).\n\nYou start on a planet and then travel through teleporters until you reach a planet that you have already visited before.\n\nYour task is to calculate for each planet the number of teleportations there would be if you started on that planet.\n\nInput\n\nThe first input line has an integer n : the number of planets. The planets are numbered 1,2,…,n .\n\nThe second line has n integers t_1,t_2,…,t_n : for each planet, the destination of the teleporter. It is possible that t_i=i .\n\nOutput\n\nPrint n integers according to the problem statement.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ t_i ≤ n\n\nExample\n\nInput:\n\n\n5\n2 4 3 1 4\n\n\nOutput:\n\n\n3 3 1 3 4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import deque\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nc = list(map(int, data[1:n+1]))\nc = [x - 1 for x in c]\np = [[] for _ in range(n)]\nans = [0] * n\n\nfor i in range(n):\n    p[c[i]].append(i)\n\nfor i in range(n):\n    if ans[i] == 0:\n        a = i\n        b = i\n        while True:\n            a = c[a]\n            b = c[c[b]]\n            if a == b:\n                break\n        a = i\n        while a != b:\n            a = c[a]\n            b = c[b]\n        l = 0\n        while True:\n            a = c[a]\n            l += 1\n            if a == b:\n                break\n        while True:\n            ans[a] = l\n            a = c[a]\n            if a == b:\n                break\n        q = deque([(a, l)])\n        while q:\n            m = q.popleft()\n            ans[m[0]] = m[1]\n            for idx in p[m[0]]:\n                if ans[idx] == 0:\n                    q.append((idx, m[1] + 1))\n\nprint(\" \".join(map(str, ans)))",
        "public_test_path": "/id/public/1751",
        "hidden_test_path": "/id/hidden/1751",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "roadreparation1675",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Road Reparation",
        "description": "There are n cities and m roads between them. Unfortunately, the condition of the roads is so poor that they cannot be used. Your task is to repair some of the roads so that there will be a decent route between any two cities.\n\nFor each road, you know its reparation cost, and you should find a solution where the total cost is as small as possible.\n\nInput\n\nThe first input line has two integers n and m : the number of cities and roads. The cities are numbered 1,2,…,n .\n\nThen, there are m lines describing the roads. Each line has three integers a , b and c : there is a road between cities a and b , and its reparation cost is c . All roads are two-way roads.\n\nEvery road is between two different cities, and there is at most one road between two cities.\n\nOutput\n\nPrint one integer: the minimum total reparation cost. However, if there are no solutions, print \"IMPOSSIBLE\".\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n 1 ≤ c ≤ 10^9\n\nExample\n\nInput:\n\n\n5 6\n1 2 3\n2 3 5\n2 4 2\n3 4 8\n5 1 7\n5 4 4\n\n\nOutput:\n\n\n14",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class UF:\n    def __init__(self, n):\n        self.e = [-1] * n\n\n    def same_set(self, a, b):\n        return self.find(a) == self.find(b)\n\n    def size(self, x):\n        return -self.e[self.find(x)]\n\n    def find(self, x):\n        if self.e[x] < 0:\n            return x\n        self.e[x] = self.find(self.e[x])\n        return self.e[x]\n\n    def join(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return False\n        if self.e[a] > self.e[b]:\n            a, b = b, a\n        self.e[a] += self.e[b]\n        self.e[b] = a\n        return True\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().splitlines()\n    n, m = map(int, data[0].split())\n    edges = []\n    \n    for i in range(1, m + 1):\n        a, b, c = map(int, data[i].split())\n        edges.append((c, a - 1, b - 1))\n    \n    edges.sort()\n    uf = UF(n)\n    costs = 0\n    joins = 0\n    \n    for cost, a, b in edges:\n        if not uf.same_set(a, b):\n            uf.join(a, b)\n            joins += 1\n            costs += cost\n    \n    if joins == n - 1:\n        print(costs)\n    else:\n        print(\"IMPOSSIBLE\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1675",
        "hidden_test_path": "/id/hidden/1675",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 128,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "roadconstruction1676",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Road Construction",
        "description": "There are n cities and initially no roads between them. However, every day a new road will be constructed, and there will be a total of m roads.\n\nA component is a group of cities where there is a route between any two cities using the roads. After each day, your task is to find the number of components and the size of the largest component.\n\nInput\n\nThe first input line has two integers n and m : the number of cities and roads. The cities are numbered 1,2,…,n .\n\nThen, there are m lines describing the new roads. Each line has two integers a and b : a new road is constructed between cities a and b .\n\nYou may assume that every road will be constructed between two different cities.\n\nOutput\n\nPrint m lines: the required information after each day.\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 3\n1 2\n1 3\n4 5\n\n\nOutput:\n\n\n4 2\n3 3\n2 3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class UF:\n    def __init__(self, n):\n        self.e = [-1] * n\n\n    def same_set(self, a, b):\n        return self.find(a) == self.find(b)\n\n    def size(self, x):\n        return -self.e[self.find(x)]\n\n    def find(self, x):\n        if self.e[x] < 0:\n            return x\n        self.e[x] = self.find(self.e[x])\n        return self.e[x]\n\n    def join(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return False\n        if self.e[a] > self.e[b]:\n            a, b = b, a\n        self.e[a] += self.e[b]\n        self.e[b] = a\n        return True\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    largestcomp = 1\n    uf = UF(n)\n    numcomps = n\n    index = 2\n    results = []\n    \n    for _ in range(m):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        index += 2\n        if uf.join(a, b):\n            numcomps -= 1\n            largestcomp = max(largestcomp, uf.size(a))\n        results.append(f\"{numcomps} {largestcomp}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1676",
        "hidden_test_path": "/id/hidden/1676",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "planetsandkingdoms1683",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Planets and Kingdoms",
        "description": "A game has n planets, connected by m teleporters. Two planets a and b belong to the same kingdom exactly when there is a route both from a to b and from b to a . Your task is to determine for each planet its kingdom.\n\nInput\n\nThe first input line has two integers n and m : the number of planets and teleporters. The planets are numbered 1,2,…,n .\n\nAfter this, there are m lines describing the teleporters. Each line has two integers a and b : you can travel from planet a to planet b through a teleporter.\n\nOutput\n\nFirst print an integer k : the number of kingdoms. After this, print for each planet a kingdom label between 1 and k . You can print any valid solution.\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 6\n1 2\n2 3\n3 1\n3 4\n4 5\n5 4\n\n\nOutput:\n\n\n2\n1 1 1 2 2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def dfs(j, g, f):\n    global Time, ncomps\n    low = val[j] = Time + 1\n    x = None\n    z.append(j)\n    for e in g[j]:\n        if comp[e] < 0:\n            low = min(low, val[e] if val[e] else dfs(e, g, f))\n\n    if low == val[j]:\n        while True:\n            x = z.pop()\n            comp[x] = ncomps\n            cont.append(x)\n            if x == j:\n                break\n        f(cont)\n        cont.clear()\n        ncomps += 1\n    return val[j] = low\n\ndef scc(g, f):\n    global Time, ncomps\n    n = len(g)\n    val[:] = [0] * n\n    comp[:] = [-1] * n\n    Time = ncomps = 0\n    for i in range(n):\n        if comp[i] < 0:\n            dfs(i, g, f)\n\ndef assigncomp(comp):\n    for i in comp:\n        comps[i] = ncomps + 1\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn, m = int(data[0]), int(data[1])\ncomps = [0] * n\nadj = [[] for _ in range(n)]\nindex = 2\nfor _ in range(m):\n    a, b = int(data[index]) - 1, int(data[index + 1]) - 1\n    adj[a].append(b)\n    index += 2\n\nval = []\ncomp = []\nz = []\ncont = []\nTime = 0\nncomps = 0\nscc(adj, assigncomp)\nprint(ncomps)\nprint(\" \".join(map(str, comps)))",
        "public_test_path": "/id/public/1683",
        "hidden_test_path": "/id/hidden/1683",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "giantpizza1684",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Giant Pizza",
        "description": "Uolevi's family is going to order a large pizza and eat it together. A total of n family members will join the order, and there are m possible toppings. The pizza may have any number of toppings.\n\nEach family member gives two wishes concerning the toppings of the pizza. The wishes are of the form \"topping x is good/bad\". Your task is to choose the toppings so that at least one wish from everybody becomes true (a good topping is included in the pizza or a bad topping is not included).\n\nInput\n\nThe first input line has two integers n and m : the number of family members and toppings. The toppings are numbered 1,2,…,m .\n\nAfter this, there are n lines describing the wishes. Each line has two wishes of the form \"+ x \" (topping x is good) or \"- x \" (topping x is bad).\n\nOutput\n\nPrint a line with m symbols: for each topping \"+\" if it is included and \"-\" if it is not included. You can print any valid solution.\n\nIf there are no valid solutions, print \"IMPOSSIBLE\".\n\nConstraints\n\n1 ≤ n,m ≤ 10^5 1 ≤ x ≤ m\n\nExample\n\nInput:\n\n\n3 5\n+ 1 + 2\n- 1 + 3\n+ 4 - 2\n\n\nOutput:\n\n\n- + + + -",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class TwoSat:\n    def __init__(self, n=0):\n        self.N = n\n        self.gr = [[] for _ in range(2 * n)]\n        self.values = [-1] * n\n\n    def add_var(self):\n        self.gr.append([])\n        self.gr.append([])\n        self.N += 1\n        return self.N - 1\n\n    def either(self, f, j):\n        f = max(2 * f, -1 - 2 * f)\n        j = max(2 * j, -1 - 2 * j)\n        self.gr[f].append(j ^ 1)\n        self.gr[j].append(f ^ 1)\n\n    def set_value(self, x):\n        self.either(x, x)\n\n    def at_most_one(self, li):\n        if len(li) <= 1:\n            return\n        cur = ~li[0]\n        for i in range(2, len(li)):\n            next_var = self.add_var()\n            self.either(cur, ~li[i])\n            self.either(cur, next_var)\n            self.either(~li[i], next_var)\n            cur = ~next_var\n        self.either(cur, ~li[1])\n\n    def dfs(self, i):\n        low = self.val[i] = self.time + 1\n        self.time += 1\n        self.z.append(i)\n        for e in self.gr[i]:\n            if not self.comp[e]:\n                low = min(low, self.val[e] if self.val[e] else self.dfs(e))\n        if low == self.val[i]:\n            while True:\n                x = self.z.pop()\n                self.comp[x] = low\n                if self.values[x >> 1] == -1:\n                    self.values[x >> 1] = x & 1\n                if x == i:\n                    break\n        return self.val[i] = low\n\n    def solve(self):\n        self.values = [-1] * self.N\n        self.val = [0] * (2 * self.N)\n        self.comp = self.val[:]\n        self.z = []\n        self.time = 0\n        for i in range(2 * self.N):\n            if not self.comp[i]:\n                self.dfs(i)\n        for i in range(self.N):\n            if self.comp[2 * i] == self.comp[2 * i + 1]:\n                return False\n        return True\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m = map(int, data[0].split())\n    ts = TwoSat(m)\n    \n    for i in range(1, n + 1):\n        s1, v1, s2, v2 = data[i].split()\n        v1, v2 = int(v1) - 1, int(v2) - 1\n        ts.either(v1 if s1 == '+' else ~v1, v2 if s2 == '+' else ~v2)\n    \n    works = ts.solve()\n    if works:\n        print(\" \".join('+' if ts.values[i] else '-' for i in range(m)))\n    else:\n        print(\"IMPOSSIBLE\")\n\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1684",
        "hidden_test_path": "/id/hidden/1684",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 22
    },
    {
        "problem_id": "coincollector1686",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Coin Collector",
        "description": "A game has n rooms and m tunnels between them. Each room has a certain number of coins. What is the maximum number of coins you can collect while moving through the tunnels when you can freely choose your starting and ending room?\n\nInput\n\nThe first input line has two integers n and m : the number of rooms and tunnels. The rooms are numbered 1,2,…,n .\n\nThen, there are n integers k_1,k_2,…,k_n : the number of coins in each room.\n\nFinally, there are m lines describing the tunnels. Each line has two integers a and b : there is a tunnel from room a to room b . Each tunnel is a one-way tunnel.\n\nOutput\n\nPrint one integer: the maximum number of coins you can collect.\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ k_i ≤ 10^9 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n4 4\n4 5 2 7\n1 2\n2 1\n1 3\n2 4\n\n\nOutput:\n\n\n16",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\n\nn, m = map(int, input().split())\nk = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    adj[a].append(b)\n\nTime = 0\nncomps = 0\ntin = [0] * n\ncomp = [-1] * n\nz = []\ncont = []\ncval = []\ncset = []\nsolved = []\nradj = [set() for _ in range(n)]\n\ndef dfs(u, g, f):\n    global Time, ncomps\n    low = tin[u] = Time + 1\n    z.append(u)\n    for v in g[u]:\n        if comp[v] < 0:\n            low = min(low, tin[v] if tin[v] > 0 else dfs(v, g, f))\n    \n    if low == tin[u]:\n        while True:\n            x = z.pop()\n            comp[x] = ncomps\n            cont.append(x)\n            if x == u:\n                break\n        f(cont)\n        cont.clear()\n        ncomps += 1\n    return tin[u] = low\n\ndef scc(g, f):\n    global Time, ncomps\n    n = len(g)\n    global tin, comp\n    tin = [0] * n\n    comp = [-1] * n\n    Time = ncomps = 0\n    for i in range(n):\n        if comp[i] < 0:\n            dfs(i, g, f)\n\ndef buildcomp(v):\n    cval.append(0)\n    cset.append([])\n    solved.append(False)\n    for i in v:\n        cval[-1] += k[i]\n        cset[-1].append(i)\n\nscc(adj, buildcomp)\n\nfor i in range(n):\n    for j in adj[i]:\n        if comp[j] == comp[i]:\n            continue\n        radj[comp[i]].add(comp[j])\n\ndp = [0] * len(cval)\nvis = [False] * len(cval)\n\ndef solve(cur):\n    if vis[cur]:\n        return dp[cur]\n    path = 0\n    for i in radj[cur]:\n        path = max(path, solve(i))\n    dp[cur] = cval[cur] + path\n    vis[cur] = True\n    return dp[cur]\n\nbest = 0\nfor i in range(len(cval)):\n    best = max(best, solve(i))\n\nprint(best)",
        "public_test_path": "/id/public/1686",
        "hidden_test_path": "/id/hidden/1686",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "maildelivery1691",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Mail Delivery",
        "description": "Your task is to deliver mail to the inhabitants of a city. For this reason, you want to find a route whose starting and ending point are the post office, and that goes through every street exactly once.\n\nInput\n\nThe first input line has two integers n and m : the number of crossings and streets. The crossings are numbered 1,\\,2,…,\\,n , and the post office is located at crossing 1 .\n\nAfter that, there are m lines describing the streets. Each line has two integers a and b : there is a street between crossings a and b . All streets are two-way streets.\n\nEvery street is between two different crossings, and there is at most one street between two crossings.\n\nOutput\n\nPrint all the crossings on the route in the order you will visit them. You can print any valid solution.\n\nIf there are no solutions, print \"IMPOSSIBLE\".\n\nConstraints\n\n2≤q n≤q 10^5 1≤q m≤q 2 · 10^5 1≤q a,\\,b≤q n\n\nExample\n\nInput:\n\n\n6 8\n1 2\n1 3\n2 3\n2 4\n2 6\n3 5\n3 6\n4 5\n\n\nOutput:\n\n\n1 2 6 3 2 4 5 3 1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, m = map(int, data[0].split())\nadj = defaultdict(set)\n\nfor i in range(1, m + 1):\n    a, b = map(int, data[i].split())\n    a -= 1\n    b -= 1\n    adj[a].add(b)\n    adj[b].add(a)\n\nworks = True\nfor i in range(n):\n    if len(adj[i]) % 2 == 1:\n        works = False\n\nif not works:\n    print(\"IMPOSSIBLE\")\n    sys.exit(0)\n\nst = []\nans = []\nst.append(0)\n\nwhile st:\n    if len(adj[st[-1]]) == 0:\n        ans.append(st.pop())\n    else:\n        i = adj[st[-1]].pop()\n        adj[i].remove(st[-1])\n        st.append(i)\n\nif len(ans) != m + 1:\n    print(\"IMPOSSIBLE\")\n    sys.exit(0)\n\nprint(\" \".join(str(1 + x) for x in ans))",
        "public_test_path": "/id/public/1691",
        "hidden_test_path": "/id/hidden/1691",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "debruijnsequence1692",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "De Bruijn Sequence",
        "description": "Your task is to construct a minimum-length bit string that contains all possible substrings of length n . For example, when n=2 , the string 00110 is a valid solution, because its substrings of length 2 are 00, 01, 10 and 11.\n\nInput\n\nThe only input line has an integer n .\n\nOutput\n\nPrint a minimum-length bit string that contains all substrings of length n . You can print any valid solution.\n\nConstraints\n\n1 ≤ n ≤ 15\n\nExample\n\nInput:\n\n\n2\n\n\nOutput:\n\n\n00110",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def binstr(i, siz):\n    return ''.join('1' if (i & (1 << j)) > 0 else '0' for j in range(siz - 1, -1, -1))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    n = int(input().strip())\n    bs = n\n    n = 1 << bs\n    adj = [[] for _ in range(n)]\n    \n    for i in range(n):\n        adj[i].append(((i & ((1 << (bs - 1)) - 1)) << 1))\n        adj[i].append(((i & ((1 << (bs - 1)) - 1)) << 1) ^ 1)\n    \n    found = False\n    sol = \"\"\n    ans = \"\"\n    \n    def dfs(used, last, cnt):\n        nonlocal found, ans, sol\n        if found:\n            return\n        used[last] = True\n        if cnt == n:\n            found = True\n            ans = sol\n            return\n\n        for i in range(2):\n            if used[adj[last][i]]:\n                continue\n            sol += '1' if i else '0'\n            dfs(used, adj[last][i], cnt + 1)\n            sol = sol[:-1]\n        used[last] = False\n\n    used = [False] * n\n    for i in range(n):\n        sol = binstr(i, bs)\n        dfs(used, i, 1)\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1692",
        "hidden_test_path": "/id/hidden/1692",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "teleporterspath1693",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Teleporters Path",
        "description": "A game has n levels and m teleportes between them. You win the game if you move from level 1 to level n using every teleporter exactly once.\n\nCan you win the game, and what is a possible way to do it?\n\nInput\n\nThe first input line has two integers n and m : the number of levels and teleporters. The levels are numbered 1,2,…,n .\n\nThen, there are m lines describing the teleporters. Each line has two integers a and b : there is a teleporter from level a to level b .\n\nYou can assume that each pair (a,b) in the input is distinct.\n\nOutput\n\nPrint m+1 integers: the sequence in which you visit the levels during the game. You can print any valid solution.\n\nIf there are no solutions, print \"IMPOSSIBLE\".\n\nConstraints\n\n2 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 6\n1 2\n1 3\n2 4\n2 5\n3 1\n4 2\n\n\nOutput:\n\n\n1 3 1 2 4 2 5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\nn, m = int(data[0]), int(data[1])\nadj = [set() for _ in range(n)]\nadjcp = [set() for _ in range(n)]\n\nindex = 2\nfor _ in range(m):\n    a, b = int(data[index]) - 1, int(data[index + 1]) - 1\n    index += 2\n    adj[a].add(b)\n    adjcp[a].add(b)\n\nst = []\nans = []\nst.append(0)\n\nwhile st:\n    if not adj[st[-1]]:\n        ans.append(st.pop())\n    else:\n        for i in adj[st[-1]]:\n            adj[st[-1]].remove(i)\n            st.append(i)\n            break\n\nans.reverse()\nworks = True\nfor i in range(len(ans) - 1):\n    if ans[i + 1] not in adjcp[ans[i]]:\n        works = False\n        break\n    else:\n        adjcp[ans[i]].remove(ans[i + 1])\n\nfor i in range(n):\n    if adjcp[i]:\n        works = False\n\nif not works or len(ans) != m + 1 or ans[-1] != n - 1:\n    print(\"IMPOSSIBLE\")\nelse:\n    print(\" \".join(str(x + 1) for x in ans))",
        "public_test_path": "/id/public/1693",
        "hidden_test_path": "/id/hidden/1693",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 22
    },
    {
        "problem_id": "hamiltonianflights1690",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Hamiltonian Flights",
        "description": "There are n cities and m flight connections between them. You want to travel from Syrjälä to Lehmälä so that you visit each city exactly once. How many possible routes are there?\n\nInput\n\nThe first input line has two integers n and m : the number of cities and flights. The cities are numbered 1,2,…,n . City 1 is Syrjälä, and city n is Lehmälä.\n\nThen, there are m lines describing the flights. Each line has two integers a and b : there is a flight from city a to city b . All flights are one-way flights.\n\nOutput\n\nPrint one integer: the number of routes modulo 10^9+7 .\n\nConstraints\n\n2 ≤ n ≤ 20 1 ≤ m ≤ n^2 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n4 6\n1 2\n1 3\n2 3\n3 2\n2 4\n3 4\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from sys import stdin, stdout\nfrom collections import defaultdict\n\nMOD = 1_000_000_007\nBLANK = -1\n\ndef solve(mask, last):\n    if dp[mask][last] != BLANK:\n        return dp[mask][last]\n    dp[mask][last] = 0\n    newmask = mask ^ (1 << last)\n    for i in range(n):\n        cnt = radj[last][i]\n        if cnt == 0:\n            continue\n        if newmask & (1 << i):\n            dp[mask][last] = (dp[mask][last] + (cnt * solve(newmask, i)) % MOD) % MOD\n    return dp[mask][last]\n\nn, m = map(int, stdin.readline().split())\nadj = [[0] * 20 for _ in range(20)]\nradj = [[0] * 20 for _ in range(20)]\ndp = [[BLANK] * 20 for _ in range(1 << 20)]\n\nfor _ in range(m):\n    a, b = map(int, stdin.readline().split())\n    a -= 1\n    b -= 1\n    adj[a][b] += 1\n    radj[b][a] += 1\n\ndp[1][0] = 1\nresult = solve((1 << n) - 1, n - 1)\nstdout.write(f\"{result}\\n\")",
        "public_test_path": "/id/public/1690",
        "hidden_test_path": "/id/hidden/1690",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "downloadspeed1694",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Download Speed",
        "description": "Consider a network consisting of n computers and m connections. Each connection specifies how fast a computer can send data to another computer.\n\nKotivalo wants to download some data from a server. What is the maximum speed he can do this, using the connections in the network?\n\nInput\n\nThe first input line has two integers n and m : the number of computers and connections. The computers are numbered 1,2,…,n . Computer 1 is the server and computer n is Kotivalo's computer.\n\nAfter this, there are m lines describing the connections. Each line has three integers a , b and c : computer a can send data to computer b at speed c .\n\nOutput\n\nPrint one integer: the maximum speed Kotivalo can download data.\n\nConstraints\n\n1 ≤ n ≤ 500 1 ≤ m ≤ 1000 1 ≤ a,b ≤ n 1 ≤ c ≤ 10^9\n\nExample\n\nInput:\n\n\n4 5\n1 2 3\n2 4 2\n1 3 4\n3 4 5\n4 1 3\n\n\nOutput:\n\n\n6",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import deque\n\nclass Node:\n    def __init__(self, id):\n        self.parent = None\n        self.id = id\n        self.visited = False\n        self.neighbors = set()\n        self.weights = {}\n\ndef bfs(start, end, nodes):\n    q = deque()\n    for n in nodes:\n        n.parent = None\n        n.visited = False\n    q.append(start)\n    while q:\n        n = q.popleft()\n        if n.visited:\n            continue\n        n.visited = True\n        if n == end:\n            return True\n        for n2 in n.neighbors:\n            if not n2.visited and n.weights[n2] > 0:\n                n2.parent = n\n                q.append(n2)\n    return False\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m = map(int, data[0].split())\n    nodes = [Node(i) for i in range(n)]\n    \n    for i in range(1, m + 1):\n        a, b, c = map(int, data[i].split())\n        a -= 1\n        b -= 1\n        if nodes[b] not in nodes[a].neighbors:\n            nodes[a].neighbors.add(nodes[b])\n            nodes[a].weights[nodes[b]] = c\n        else:\n            nodes[a].weights[nodes[b]] += c\n        if nodes[a] not in nodes[b].neighbors:\n            nodes[b].neighbors.add(nodes[a])\n            nodes[b].weights[nodes[a]] = 0\n\n    max_flow = 0\n    while bfs(nodes[0], nodes[n - 1], nodes):\n        min_flow = float('inf')\n        v = nodes[n - 1]\n        while v.parent is not None:\n            min_flow = min(min_flow, v.parent.weights[v])\n            v = v.parent\n        max_flow += min_flow\n        v = nodes[n - 1]\n        while v.parent is not None:\n            v.weights[v.parent] += min_flow\n            v.parent.weights[v] -= min_flow\n            v = v.parent\n\n    print(max_flow)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1694",
        "hidden_test_path": "/id/hidden/1694",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 70
    },
    {
        "problem_id": "policechase1695",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Police Chase",
        "description": "Kaaleppi has just robbed a bank and is now heading to the harbor. However, the police wants to stop him by closing some streets of the city.\n\nWhat is the minimum number of streets that should be closed so that there is no route between the bank and the harbor?\n\nInput\n\nThe first input line has two integers n and m : the number of crossings and streets. The crossings are numbered 1,2,…,n . The bank is located at crossing 1 , and the harbor is located at crossing n .\n\nAfter this, there are m lines that describing the streets. Each line has two integers a and b : there is a street between crossings a and b . All streets are two-way streets, and there is at most one street between two crossings.\n\nOutput\n\nFirst print an integer k : the minimum number of streets that should be closed. After this, print k lines describing the streets. You can print any valid solution.\n\nConstraints\n\n2 ≤ n ≤ 500 1 ≤ m ≤ 1000 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n4 5\n1 2\n1 3\n2 3\n3 4\n1 4\n\n\nOutput:\n\n\n2\n3 4\n1 4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import deque\n\nclass Dinic:\n    class Edge:\n        def __init__(self, to, rev, c, oc):\n            self.to = to\n            self.rev = rev\n            self.c = c\n            self.oc = oc\n        \n        def flow(self):\n            return max(self.oc - self.c, 0)\n\n    def __init__(self, n):\n        self.lvl = [0] * n\n        self.ptr = [0] * n\n        self.q = [0] * n\n        self.adj = [[] for _ in range(n)]\n\n    def add_edge(self, a, b, c, rcap=0):\n        self.adj[a].append(self.Edge(b, len(self.adj[b]), c, c))\n        self.adj[b].append(self.Edge(a, len(self.adj[a]) - 1, rcap, rcap))\n\n    def dfs(self, v, t, f):\n        if v == t or f == 0:\n            return f\n        for i in range(self.ptr[v], len(self.adj[v])):\n            e = self.adj[v][i]\n            if self.lvl[e.to] == self.lvl[v] + 1:\n                p = self.dfs(e.to, t, min(f, e.c))\n                if p:\n                    e.c -= p\n                    self.adj[e.to][e.rev].c += p\n                    return p\n        return 0\n\n    def calc(self, s, t):\n        flow = 0\n        self.q[0] = s\n        for L in range(31):\n            self.lvl = [0] * len(self.lvl)\n            self.ptr = [0] * len(self.ptr)\n            qi = 0\n            qe = self.lvl[s] = 1\n            while qi < qe and not self.lvl[t]:\n                v = self.q[qi]\n                qi += 1\n                for e in self.adj[v]:\n                    if not self.lvl[e.to] and e.c >> (30 - L):\n                        self.q[qe] = e.to\n                        qe += 1\n                        self.lvl[e.to] = self.lvl[v] + 1\n            while (p := self.dfs(s, t, float('inf'))):\n                flow += p\n        return flow\n\n    def left_of_min_cut(self, a):\n        return self.lvl[a] != 0\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    d = Dinic(n + 2)\n    source = n\n    sink = n + 1\n    \n    index = 2\n    for _ in range(m):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        d.add_edge(a, b, 1, 1)\n        index += 2\n    \n    mf = d.calc(0, n - 1)\n    print(mf)\n    \n    for i in range(n):\n        for e in d.adj[i]:\n            if d.left_of_min_cut(i) and not d.left_of_min_cut(e.to):\n                print(i + 1, e.to + 1)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1695",
        "hidden_test_path": "/id/hidden/1695",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "schooldance1696",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "School Dance",
        "description": "There are n boys and m girls in a school. Next week a school dance will be organized. A dance pair consists of a boy and a girl, and there are k potential pairs.\n\nYour task is to find out the maximum number of dance pairs and show how this number can be achieved.\n\nInput\n\nThe first input line has three integers n , m and k : the number of boys, girls, and potential pairs. The boys are numbered 1,2,…,n , and the girls are numbered 1,2,…,m .\n\nAfter this, there are k lines describing the potential pairs. Each line has two integers a and b : boy a and girl b are willing to dance together.\n\nOutput\n\nFirst print one integer r : the maximum number of dance pairs. After this, print r lines describing the pairs. You can print any valid solution.\n\nConstraints\n\n1 ≤ n,m ≤ 500 1 ≤ k ≤ 1000 1 ≤ a ≤ n 1 ≤ b ≤ m\n\nExample\n\nInput:\n\n\n3 2 4\n1 1\n1 2\n2 1\n3 1\n\n\nOutput:\n\n\n2\n1 2\n3 1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict, deque\nimport sys\n\ndef edmonds_karp(graph, source, sink):\n    assert source != sink\n    flow = 0\n    par = [-1] * len(graph)\n    \n    while True:\n        fill(par, -1)\n        par[source] = 0\n        ptr = 1\n        q = [source]\n\n        for i in range(ptr):\n            x = q[i]\n            for e in graph[x].items():\n                if par[e[0]] == -1 and e[1] > 0:\n                    par[e[0]] = x\n                    q.append(e[0])\n                    ptr += 1\n                    if e[0] == sink:\n                        break\n            else:\n                continue\n            break\n        else:\n            return flow\n        \n        inc = float('inf')\n        y = sink\n        while y != source:\n            inc = min(inc, graph[par[y]][y])\n            y = par[y]\n\n        flow += inc\n        y = sink\n        while y != source:\n            p = par[y]\n            if (graph[p][y] := graph[p][y] - inc) <= 0:\n                del graph[p][y]\n            graph[y][p] += inc\n            y = par[y]\n\ndef routes(graph, graph1, source, sink):\n    par = [-1] * len(graph)\n    rs = []\n    \n    while True:\n        fill(par, -1)\n        par[source] = source\n        ptr = 1\n        q = [source]\n\n        for i in range(ptr):\n            x = q[i]\n            for e in graph[x].items():\n                if par[e[0]] == -1 and e[1] < graph1[x][e[0]]:\n                    par[e[0]] = x\n                    q.append(e[0])\n                    ptr += 1\n                    if e[0] == sink:\n                        break\n            else:\n                continue\n            break\n        else:\n            return rs\n        \n        rs.append([sink])\n        y = sink\n        while y != source:\n            graph[par[y]][y] += 1\n            graph[y][par[y]] -= 1\n            rs[-1].append(par[y])\n            y = par[y]\n        rs[-1].reverse()\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    n = int(data[idx]); idx += 1\n    m = int(data[idx]); idx += 1\n    k = int(data[idx]); idx += 1\n    \n    graph = [defaultdict(int) for _ in range(n + m + 2)]\n    graph1 = [defaultdict(int) for _ in range(n + m + 2)]\n    \n    for _ in range(k):\n        a = int(data[idx]); idx += 1\n        b = int(data[idx]); idx += 1\n        graph[a][b + n] = 1\n    \n    for i in range(1, n + 1):\n        graph[0][i] = 1\n    for i in range(1, m + 1):\n        graph[i + n][n + m + 1] = 1\n    \n    for i in range(len(graph)):\n        graph1[i] = graph[i].copy()\n    \n    mf = edmonds_karp(graph, 0, n + m + 1)\n    print(mf)\n    \n    for i in range(len(graph)):\n        for e in graph1[i].items():\n            graph[i][e[0]]\n    \n    rs = routes(graph, graph1, 0, n + m + 1)\n    for r in rs:\n        print(r[1], r[2] - n)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1696",
        "hidden_test_path": "/id/hidden/1696",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "distinctroutes1711",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Distinct Routes",
        "description": "A game consists of n rooms and m teleporters. At the beginning of each day, you start in room 1 and you have to reach room n .\n\nYou can use each teleporter at most once during the game. How many days can you play if you choose your routes optimally?\n\nInput\n\nThe first input line has two integers n and m : the number of rooms and teleporters. The rooms are numbered 1,2,…,n .\n\nAfter this, there are m lines describing the teleporters. Each line has two integers a and b : there is a teleporter from room a to room b .\n\nThere are no two teleporters whose starting and ending room are the same.\n\nOutput\n\nFirst print an integer k : the maximum number of days you can play the game. Then, print k route descriptions according to the example. You can print any valid solution.\n\nConstraints\n\n2 ≤ n ≤ 500 1 ≤ m ≤ 1000 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n6 7\n1 2\n1 3\n2 6\n3 4\n3 5\n4 6\n5 6\n\n\nOutput:\n\n\n2\n3\n1 2 6\n4\n1 3 4 6",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict, deque\nimport sys\n\ndef edmonds_karp(graph, source, sink):\n    assert source != sink\n    flow = 0\n    par = [-1] * len(graph)\n    \n    while True:\n        fill(par, -1)\n        par[source] = 0\n        ptr = 1\n        q = [source]\n\n        while ptr > 0:\n            x = q.pop(0)\n            for e in graph[x].items():\n                if par[e[0]] == -1 and e[1] > 0:\n                    par[e[0]] = x\n                    q.append(e[0])\n                    ptr += 1\n                    if e[0] == sink:\n                        break\n            else:\n                continue\n            break\n        else:\n            return flow\n        \n        inc = float('inf')\n        y = sink\n        while y != source:\n            inc = min(inc, graph[par[y]][y])\n            y = par[y]\n\n        flow += inc\n        y = sink\n        while y != source:\n            p = par[y]\n            if (graph[p][y] := graph[p][y] - inc) <= 0:\n                del graph[p][y]\n            graph[y][p] += inc\n            y = par[y]\n\ndef routes(graph, graph1, source, sink):\n    par = [-1] * len(graph)\n    rs = []\n    \n    while True:\n        fill(par, -1)\n        par[source] = source\n        ptr = 1\n        q = [source]\n\n        while ptr > 0:\n            x = q.pop(0)\n            for e in graph[x].items():\n                if par[e[0]] == -1 and e[1] < graph1[x][e[0]]:\n                    par[e[0]] = x\n                    q.append(e[0])\n                    ptr += 1\n                    if e[0] == sink:\n                        break\n            else:\n                continue\n            break\n        else:\n            for r in rs:\n                r.reverse()\n            return rs\n        \n        rs.append([])\n        y = sink\n        while y != source:\n            graph[par[y]][y] += 1\n            graph[y][par[y]] -= 1\n            rs[-1].append(y)\n            y = par[y]\n        rs[-1].append(source)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    graph = [defaultdict(int) for _ in range(n)]\n    graph1 = [defaultdict(int) for _ in range(n)]\n    \n    index = 2\n    for _ in range(m):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        index += 2\n        graph1[a][b] = graph[a][b] = 1\n\n    mf = edmonds_karp(graph, 0, n - 1)\n    print(mf)\n    \n    for i in range(n):\n        for p in graph1[i]:\n            graph[i][p]\n\n    rs = routes(graph, graph1, 0, n - 1)\n    for r in rs:\n        print(len(r))\n        for j in range(len(r)):\n            print(r[j] + 1, end=' ')\n            if j + 1 < len(r):\n                graph1[r[j]][r[j + 1]] -= 1\n                if graph1[r[j]][r[j + 1]] < 0:\n                    print(\"illegal edge to use\")\n        print()\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1711",
        "hidden_test_path": "/id/hidden/1711",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 18
    },
    {
        "problem_id": "forestqueries1652",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Forest Queries",
        "description": "You are given an n × n grid representing the map of a forest. Each square is either empty or contains a tree. The upper-left square has coordinates (1,1) , and the lower-right square has coordinates (n,n) .\n\nYour task is to process q queries of the form: how many trees are inside a given rectangle in the forest?\n\nInput\n\nThe first input line has two integers n and q : the size of the forest and the number of queries.\n\nThen, there are n lines describing the forest. Each line has n characters: . is an empty square and * is a tree.\n\nFinally, there are q lines describing the queries. Each line has four integers y_1 , x_1 , y_2 , x_2 corresponding to the corners of a rectangle.\n\nOutput\n\nPrint the number of trees inside each rectangle.\n\nConstraints\n\n1 ≤ n ≤ 1000 1 ≤ q ≤ 2 · 10^5 1 ≤ y_1 ≤ y_2 ≤ n 1 ≤ x_1 ≤ x_2 ≤ n\n\nExample\n\nInput:\n\n\n4 3\n.*..\n*.**\n**..\n****\n2 2 3 4\n3 1 3 1\n1 1 2 2\n\n\nOutput:\n\n\n3\n1\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    size, num_queries = map(int, data[0].split())\n    arr = [[0] * size for _ in range(size)]\n    prefix = [[0] * size for _ in range(size)]\n    \n    for i in range(size):\n        s = data[i + 1]\n        for j in range(size):\n            prefix[i][j] = arr[i][j] = 1 if s[j] == '*' else 0\n            if i > 0:\n                prefix[i][j] += prefix[i - 1][j]\n            if j > 0:\n                prefix[i][j] += prefix[i][j - 1]\n            if i > 0 and j > 0:\n                prefix[i][j] -= prefix[i - 1][j - 1]\n    \n    results = []\n    for i in range(num_queries):\n        x1, y1, x2, y2 = map(int, data[size + 1 + i].split())\n        x1 -= 1\n        y1 -= 1\n        x2 -= 1\n        y2 -= 1\n        ans = prefix[x2][y2]\n        if x1 > 0:\n            ans -= prefix[x1 - 1][y2]\n        if y1 > 0:\n            ans -= prefix[x2][y1 - 1]\n        if x1 > 0 and y1 > 0:\n            ans += prefix[x1 - 1][y1 - 1]\n        results.append(str(ans))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1652",
        "hidden_test_path": "/id/hidden/1652",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 3
    },
    {
        "problem_id": "hotelqueries1143",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Hotel Queries",
        "description": "There are n hotels on a street. For each hotel you know the number of free rooms. Your task is to assign hotel rooms for groups of tourists. All members of a group want to stay in the same hotel.\n\nThe groups will come to you one after another, and you know for each group the number of rooms it requires. You always assign a group to the first hotel having enough rooms. After this, the number of free rooms in the hotel decreases.\n\nInput\n\nThe first input line contains two integers n and m : the number of hotels and the number of groups. The hotels are numbered 1,2,…,n .\n\nThe next line contains n integers h_1,h_2,…,h_n : the number of free rooms in each hotel.\n\nThe last line contains m integers r_1,r_2,…,r_m : the number of rooms each group requires.\n\nOutput\n\nPrint the assigned hotel for each group. If a group cannot be assigned a hotel, print 0 instead.\n\nConstraints\n\n1 ≤ n,m ≤ 2 · 10^5 1 ≤ h_i ≤ 10^9 1 ≤ r_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8 5\n3 2 4 1 5 5 2 6\n4 4 7 1 1\n\n\nOutput:\n\n\n3 5 0 1 1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\ndef index_max(tree, t):\n    size = len(tree) // 2\n    start = 1\n    if tree[start] < t:\n        return -1\n    while 2 * start < len(tree):\n        if tree[2 * start] >= t:\n            start = 2 * start\n        elif tree[2 * start + 1] >= t:\n            start = 2 * start + 1\n        else:\n            start = -1\n            break\n    if start >= size:\n        update(tree, start - size, tree[start] - t)\n        return start - size\n    return start\n\ndef maximum(tree, i1, i2):\n    size = len(tree) // 2\n    i1 += size\n    i2 += size\n    max_val = float('-inf')\n    while i1 <= i2:\n        if i1 % 2 == 1:\n            max_val = max(max_val, tree[i1])\n            i1 += 1\n        if i2 % 2 == 0:\n            max_val = max(max_val, tree[i2])\n            i2 -= 1\n        i1 //= 2\n        i2 //= 2\n    return max_val\n\ndef update(tree, index, value):\n    size = len(tree) // 2\n    index += size\n    tree[index] = value\n    for index //= 2; index >= 1; index //= 2:\n        tree[index] = max(tree[2 * index], tree[2 * index + 1])\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    size, num_queries = map(int, data[0].split())\n    size2 = size\n    while (size2 & -size2) != size2:\n        size2 += size2 & -size2\n    arr = [0] * size\n    tree = [float('-inf')] * (2 * size2)\n    \n    arr = list(map(int, data[1].split()))\n    for i in range(size):\n        update(tree, i, arr[i])\n    \n    queries = list(map(int, data[2].split()))\n    result = []\n    for i in range(num_queries):\n        t = queries[i]\n        index = index_max(tree, t)\n        result.append(index + 1)\n    \n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1143",
        "hidden_test_path": "/id/hidden/1143",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "listremovals1749",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "List Removals",
        "description": "You are given a list consisting of n integers. Your task is to remove elements from the list at given positions, and report the removed elements.\n\nInput\n\nThe first input line has an integer n : the initial size of the list. During the process, the elements are numbered 1,2,…,k where k is the current size of the list.\n\nThe second line has n integers x_1,x_2,…,x_n : the contents of the list.\n\nThe last line has n integers p_1,p_2,…,p_n : the positions of the elements to be removed.\n\nOutput\n\nPrint the elements in the order they are removed.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9 1 ≤ p_i ≤ n-i+1\n\nExample\n\nInput:\n\n\n5\n2 6 1 4 2\n3 1 3 1 1\n\n\nOutput:\n\n\n1 2 2 6 4\n\n\nExplanation: The contents of the list are [2,6,1,4,2] , [2,6,4,2] , [6,4,2] , [6,4] , [4] and [] .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class FT:\n    def __init__(self, n):\n        self.s = [0] * n\n\n    def update(self, pos, dif):\n        while pos < len(self.s):\n            self.s[pos] += dif\n            pos |= pos + 1\n\n    def query(self, pos):\n        res = 0\n        while pos > 0:\n            res += self.s[pos - 1]\n            pos &= pos - 1\n        return res\n\n    def lower_bound(self, sum):\n        if sum <= 0:\n            return -1\n        pos = 0\n        for pw in (1 << i for i in range(25, -1, -1)):\n            if pos + pw <= len(self.s) and self.s[pos + pw - 1] < sum:\n                pos += pw\n                sum -= self.s[pos - 1]\n        return pos\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n + 1]))\nft = FT(n + 5)\n\nfor i in range(n):\n    ft.update(i, 1)\n\nresult = []\nfor i in range(n):\n    x = int(data[n + 1 + i])\n    ind = ft.lower_bound(x)\n    ft.update(ind, -1)\n    result.append(a[ind])\n\nprint(\" \".join(map(str, result)))",
        "public_test_path": "/id/public/1749",
        "hidden_test_path": "/id/hidden/1749",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "salaryqueries1144",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Salary Queries",
        "description": "A company has n employees with certain salaries. Your task is to keep track of the salaries and process queries.\n\nInput\n\nThe first input line contains two integers n and q : the number of employees and queries. The employees are numbered 1,2,…,n .\n\nThe next line has n integers p_1,p_2,…,p_n : each employee's salary.\n\nAfter this, there are q lines describing the queries. Each line has one of the following forms:\n\n! k x : change the salary of employee k to x ? a b : count the number of employees whose salary is between a … b\n\nOutput\n\nPrint the answer to each ? query.\n\nConstraints\n\n1 ≤ n, q ≤ 2 · 10^5 1 ≤ p_i ≤ 10^9 1 ≤ k ≤ n 1 ≤ x ≤ 10^9 1 ≤ a ≤ b ≤ 10^9\n\nExample\n\nInput:\n\n\n5 3\n3 7 2 2 5\n? 2 3\n! 3 6\n? 2 3\n\n\nOutput:\n\n\n3\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class FT:\n    def __init__(self):\n        self.s = [0] * 1_000_000\n        self.n = 1_000_000\n\n    def update(self, pos, dif):  # a[pos] += dif\n        while pos < self.n:\n            self.s[pos] += dif\n            pos |= pos + 1\n\n    def query(self, pos):  # sum of values in [0, pos)\n        res = 0\n        while pos > 0:\n            res += self.s[pos - 1]\n            pos &= pos - 1\n        return res\n\n    def lower_bound(self, sum):  # min pos st sum of [0, pos] >= sum\n        if sum <= 0:\n            return -1\n        pos = 0\n        for pw in (1 << 25, 1 << 24, 1 << 23, 1 << 22, 1 << 21, 1 << 20, 1 << 19, 1 << 18, 1 << 17, 1 << 16,\n                    1 << 15, 1 << 14, 1 << 13, 1 << 12, 1 << 11, 1 << 10, 1 << 9, 1 << 8, 1 << 7, 1 << 6,\n                    1 << 5, 1 << 4, 1 << 3, 1 << 2, 1 << 1, 1):\n            if pos + pw <= self.n and self.s[pos + pw - 1] < sum:\n                pos += pw\n                sum -= self.s[pos - 1]\n        return pos\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, q = map(int, data[0].split())\n    a = list(map(int, data[1:n + 1]))\n    cc = []\n    \n    for i in range(n):\n        cc.append(a[i])\n    \n    qs = []\n    for i in range(q):\n        c, a, b = data[n + 1 + i].split()\n        a, b = int(a), int(b)\n        qs.append([0 if c == '!' else 1, a, b])\n        cc.append(b)\n        if c == '?':\n            cc.append(a)\n    \n    cc = sorted(set(cc))\n    \n    for i in range(n):\n        a[i] = cc.index(a[i])\n    \n    for i in range(q):\n        if qs[i][0] == 1:\n            qs[i][1] = cc.index(qs[i][1])\n        else:\n            qs[i][1] -= 1\n        qs[i][2] = cc.index(qs[i][2])\n    \n    ft = FT()\n    \n    for i in range(n):\n        ft.update(a[i], 1)\n    \n    result = []\n    \n    for i in range(q):\n        if qs[i][0] == 1:\n            result.append(str(ft.query(qs[i][2] + 1) - ft.query(qs[i][1])))\n        else:\n            ft.update(a[qs[i][1]], -1)\n            a[qs[i][1]] = qs[i][2]\n            ft.update(a[qs[i][1]], 1)\n    \n    print(\"\\n\".join(result))\n\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1144",
        "hidden_test_path": "/id/hidden/1144",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "prefixsumqueries2166",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Prefix Sum Queries",
        "description": "Given an array of n integers, your task is to process q queries of the following types:\n\nupdate the value at position k to u what is the maximum prefix sum in range [a,b] ?\n\nInput\n\nThe first input line has two integers n and q : the number of values and queries.\n\nThe second line has n integers x_1,x_2,…,x_n : the array values.\n\nFinally, there are q lines describing the queries. Each line has three integers: either \" 1 k u \" or \" 2 a b \".\n\nOutput\n\nPrint the result of each query of type 2.\n\nConstraints\n\n1 ≤ n,q ≤ 2 · 10^5 -10^9 ≤ x_i, u ≤ 10^9 1 ≤ k ≤ n 1 ≤ a ≤ b ≤ n\n\nExample\n\nInput:\n\n\n8 4\n1 2 -1 3 1 -5 1 4\n2 2 6\n1 4 -2\n2 2 6\n2 3 4\n\n\nOutput:\n\n\n5\n2\n0",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Node:\n    def __init__(self, lo, hi, v=None):\n        self.l = None\n        self.r = None\n        self.lo = lo\n        self.hi = hi\n        self.mset = float('inf')\n        self.madd = 0\n        self.val = -float('inf')\n        if v is not None:\n            if lo + 1 < hi:\n                mid = lo + (hi - lo) // 2\n                self.l = Node(lo, mid, v)\n                self.r = Node(mid, hi, v)\n                self.val = max(self.l.val, self.r.val)\n            else:\n                self.val = v[lo]\n\n    def query(self, L, R):\n        if R <= self.lo or self.hi <= L:\n            return -float('inf')\n        if L <= self.lo and self.hi <= R:\n            return self.val\n        self.push()\n        return max(self.l.query(L, R), self.r.query(L, R))\n\n    def set(self, L, R, x):\n        if R <= self.lo or self.hi <= L:\n            return\n        if L <= self.lo and self.hi <= R:\n            self.mset = self.val = x\n            self.madd = 0\n        else:\n            self.push()\n            self.l.set(L, R, x)\n            self.r.set(L, R, x)\n            self.val = max(self.l.val, self.r.val)\n\n    def add(self, L, R, x):\n        if R <= self.lo or self.hi <= L:\n            return\n        if L <= self.lo and self.hi <= R:\n            if self.mset != float('inf'):\n                self.mset += x\n            else:\n                self.madd += x\n            self.val += x\n        else:\n            self.push()\n            self.l.add(L, R, x)\n            self.r.add(L, R, x)\n            self.val = max(self.l.val, self.r.val)\n\n    def push(self):\n        if not self.l:\n            mid = self.lo + (self.hi - self.lo) // 2\n            self.l = Node(self.lo, mid)\n            self.r = Node(mid, self.hi)\n        if self.mset != float('inf'):\n            self.l.set(self.lo, self.hi, self.mset)\n            self.r.set(self.lo, self.hi, self.mset)\n            self.mset = float('inf')\n        elif self.madd:\n            self.l.add(self.lo, self.hi, self.madd)\n            self.r.add(self.lo, self.hi, self.madd)\n            self.madd = 0\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    q = int(data[idx])\n    idx += 1\n    pref = [0] * n\n    arr = [0] * n\n    for i in range(n):\n        arr[i] = int(data[idx])\n        pref[i] = arr[i]\n        if i > 0:\n            pref[i] += pref[i - 1]\n        idx += 1\n    root = Node(0, n, pref)\n    results = []\n    for _ in range(q):\n        t = int(data[idx])\n        a = int(data[idx + 1]) - 1\n        b = int(data[idx + 2])\n        idx += 3\n        if t == 1:\n            root.add(a, n, b - arr[a])\n            arr[a] = b\n        else:\n            b -= 1\n            result = max(root.query(a, b + 1) - (root.query(a - 1, a) if a > 0 else 0), 0)\n            results.append(result)\n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2166",
        "hidden_test_path": "/id/hidden/2166",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    },
    {
        "problem_id": "pizzeriaqueries2206",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Pizzeria Queries",
        "description": "There are n buildings on a street, numbered 1,2,…,n . Each building has a pizzeria and an apartment.\n\nThe pizza price in building k is p_k . If you order a pizza from building a to building b , its price (with delivery) is p_a+|a-b| .\n\nYour task is to process two types of queries:\n\nThe pizza price p_k in building k becomes x . You are in building k and want to order a pizza. What is the minimum price?\n\nInput\n\nThe first input line has two integers n and q : the number of buildings and queries.\n\nThe second line has n integers p_1,p_2,…,p_n : the initial pizza price in each building.\n\nFinally, there are q lines that describe the queries. Each line is either \"1 k x \" or \"2 k \".\n\nOutput\n\nPrint the answer for each query of type 2.\n\nConstraints\n\n1 ≤ n,q ≤ 2 · 10^5 1 ≤ p_i, x ≤ 10^9 1 ≤ k ≤ n\n\nExample\n\nInput:\n\n\n6 3\n8 6 4 5 7 5\n2 2\n1 5 1\n2 2\n\n\nOutput:\n\n\n5\n4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Node:\n    def __init__(self, lo, hi, v=None):\n        self.l = None\n        self.r = None\n        self.lo = lo\n        self.hi = hi\n        self.mset = float('inf')\n        self.madd = 0\n        self.val = float('inf')\n        if v is not None:\n            if lo + 1 < hi:\n                mid = lo + (hi - lo) // 2\n                self.l = Node(lo, mid, v)\n                self.r = Node(mid, hi, v)\n                self.val = min(self.l.val, self.r.val)\n            else:\n                self.val = v[lo]\n\n    def query(self, L, R):\n        if R <= self.lo or self.hi <= L:\n            return float('inf')\n        if L <= self.lo and self.hi <= R:\n            return self.val\n        self.push()\n        return min(self.l.query(L, R), self.r.query(L, R))\n\n    def set(self, L, R, x):\n        if R <= self.lo or self.hi <= L:\n            return\n        if L <= self.lo and self.hi <= R:\n            self.mset = self.val = x\n            self.madd = 0\n        else:\n            self.push()\n            self.l.set(L, R, x)\n            self.r.set(L, R, x)\n            self.val = min(self.l.val, self.r.val)\n\n    def add(self, L, R, x):\n        if R <= self.lo or self.hi <= L:\n            return\n        if L <= self.lo and self.hi <= R:\n            if self.mset != float('inf'):\n                self.mset += x\n            else:\n                self.madd += x\n            self.val += x\n        else:\n            self.push()\n            self.l.add(L, R, x)\n            self.r.add(L, R, x)\n            self.val = min(self.l.val, self.r.val)\n\n    def push(self):\n        if self.l is None:\n            mid = self.lo + (self.hi - self.lo) // 2\n            self.l = Node(self.lo, mid)\n            self.r = Node(mid, self.hi)\n        if self.mset != float('inf'):\n            self.l.set(self.lo, self.hi, self.mset)\n            self.r.set(self.lo, self.hi, self.mset)\n            self.mset = float('inf')\n        elif self.madd:\n            self.l.add(self.lo, self.hi, self.madd)\n            self.r.add(self.lo, self.hi, self.madd)\n            self.madd = 0\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    q = int(data[idx + 1])\n    idx += 2\n    \n    p = list(map(int, data[idx:idx + n]))\n    idx += n\n    \n    left = [i + p[i] for i in range(n)]\n    right = [n - 1 - i + p[i] for i in range(n)]\n    \n    ltree = Node(0, n, left)\n    rtree = Node(0, n, right)\n    \n    results = []\n    \n    for _ in range(q):\n        t = int(data[idx])\n        idx += 1\n        if t == 1:\n            a = int(data[idx]) - 1\n            b = int(data[idx + 1])\n            idx += 2\n            ltree.add(a, a + 1, b - p[a])\n            rtree.add(a, a + 1, b - p[a])\n            p[a] = b\n        else:\n            a = int(data[idx]) - 1\n            idx += 1\n            ans = min(ltree.query(a, n) - a, rtree.query(0, a) - (n - 1 - a))\n            results.append(ans)\n    \n    print(\"\\n\".join(map(str, results)))\n\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2206",
        "hidden_test_path": "/id/hidden/2206",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "rangeintervalqueries3163",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Range Interval Queries",
        "description": "Given an array x of n integers, your task is to process q queries of the form: how many integers i satisfy a ≤ i ≤ b and c ≤ x_i ≤ d ?\n\nInput\n\nThe first line has two integers n and q : the number of values and queries.\n\nThe second line has n integers x_1,x_2,…,x_n : the array values.\n\nFinally, there are q lines describing the queries. Each line has four integers a , b , c and d : how many integers i satisfy a ≤ i ≤ b and c ≤ x_i ≤ d ?\n\nOutput\n\nPrint the result of each query.\n\nConstraints\n\n1 ≤ n,q ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9 1 ≤ a ≤ b ≤ n 1 ≤ c ≤ d ≤ 10^9\n\nExample\n\nInput:\n\n\n8 4\n3 2 4 5 1 1 5 3\n2 4 2 4\n5 6 2 9\n1 8 1 5\n3 3 4 4\n\n\nOutput:\n\n\n2\n0\n8\n1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom math import log2\n\nclass WaveletTree:\n    def __init__(self, a, max_val):\n        self.n = len(a)\n        self.bv = [[] for _ in range(1 + int(log2(max_val)))]\n        nxt = [0] * self.n\n        \n        for h in range(len(self.bv) - 1, -1, -1):\n            b = [0] * self.n\n            for i in range(self.n):\n                b[i] = (a[i] >> h) & 1\n            \n            self.bv[h] = [0] * (self.n + 1)\n            for i in range(self.n):\n                self.bv[h][i + 1] = self.bv[h][i] + (1 - b[i])\n            \n            it = iter(nxt[:self.bv[h][self.n]])\n            for i in range(self.n):\n                if b[i]:\n                    nxt[self.bv[h][self.n] + self.bv[h][i]] = a[i]\n                    next(it)\n                else:\n                    nxt[self.bv[h][i]] = a[i]\n        \n            a = nxt[:]\n    \n    def kth(self, l, r, k):\n        res = 0\n        for h in range(len(self.bv) - 1, -1, -1):\n            l0 = self.bv[h][l]\n            r0 = self.bv[h][r]\n            if k < r0 - l0:\n                l, r = l0, r0\n            else:\n                k -= r0 - l0\n                res |= 1 << h\n                l += self.bv[h][self.n] - l0\n                r += self.bv[h][self.n] - r0\n        return res\n    \n    def count(self, l, r, ub):\n        res = 0\n        for h in range(len(self.bv) - 1, -1, -1):\n            l0 = self.bv[h][l]\n            r0 = self.bv[h][r]\n            if (~ub >> h) & 1:\n                l, r = l0, r0\n            else:\n                res += r0 - l0\n                l += self.bv[h][self.n] - l0\n                r += self.bv[h][self.n] - r0\n        return res\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    a = list(map(int, data[2:n + 2]))\n    \n    wt = WaveletTree(a, int(1e9))\n    \n    index = n + 2\n    results = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1])\n        lo = int(data[index + 2])\n        hi = int(data[index + 3]) + 1\n        index += 4\n        results.append(str(wt.count(l, r, hi) - wt.count(l, r, lo)))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3163",
        "hidden_test_path": "/id/hidden/3163",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    },
    {
        "problem_id": "subarraysumqueries1190",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Subarray Sum Queries",
        "description": "There is an array consisting of n integers. Some values of the array will be updated, and after each update, your task is to report the maximum subarray sum in the array.\n\nInput\n\nThe first input line contains integers n and m : the size of the array and the number of updates. The array is indexed 1,2,…,n .\n\nThe next line has n integers: x_1,x_2,…,x_n : the initial contents of the array.\n\nThen there are m lines describing the changes. Each line has two integers k and x : the value at position k becomes x .\n\nOutput\n\nAfter each update, print the maximum subarray sum. Empty subarrays (with sum 0 ) are allowed.\n\nConstraints\n\n1 ≤ n, m ≤ 2 · 10^5 -10^9 ≤ x_i ≤ 10^9 1 ≤ k ≤ n -10^9 ≤ x ≤ 10^9\n\nExample\n\nInput:\n\n\n5 3\n1 2 -3 5 -1\n2 6\n3 1\n2 -2\n\n\nOutput:\n\n\n9\n13\n6",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class DataStruct:\n    def __init__(self, sum=0, pref=0, suff=0, ans=0):\n        self.sum = sum\n        self.pref = pref\n        self.suff = suff\n        self.ans = ans\n\ndef combine(l, r):\n    res = DataStruct()\n    res.sum = l.sum + r.sum\n    res.pref = max(l.pref, l.sum + r.pref)\n    res.suff = max(r.suff, r.sum + l.suff)\n    res.ans = max(max(l.ans, r.ans), l.suff + r.pref)\n    return res\n\ndef make_data(val):\n    res = DataStruct()\n    res.sum = val\n    res.pref = res.suff = res.ans = max(0, val)\n    return res\n\ndef build(a, v, tl, tr):\n    if tl == tr:\n        t[v] = make_data(a[tl])\n    else:\n        tm = (tl + tr) // 2\n        build(a, v * 2, tl, tm)\n        build(a, v * 2 + 1, tm + 1, tr)\n        t[v] = combine(t[v * 2], t[v * 2 + 1])\n\ndef update(v, tl, tr, pos, new_val):\n    if tl == tr:\n        t[v] = make_data(new_val)\n    else:\n        tm = (tl + tr) // 2\n        if pos <= tm:\n            update(v * 2, tl, tm, pos, new_val)\n        else:\n            update(v * 2 + 1, tm + 1, tr, pos, new_val)\n        t[v] = combine(t[v * 2], t[v * 2 + 1])\n\ndef query(v, tl, tr, l, r):\n    if l > r:\n        return make_data(0)\n    if l == tl and r == tr:\n        return t[v]\n    tm = (tl + tr) // 2\n    lv = query(v * 2, tl, tm, l, min(r, tm))\n    rv = query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r)\n    return combine(lv, rv)\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nindex = 0\n\nn = int(data[index])\nindex += 1\nm = int(data[index])\nindex += 1\na = list(map(int, data[index:index + n]))\nindex += n\n\nt = [DataStruct() for _ in range(4 * n)]\nbuild(a, 1, 0, n - 1)\n\nresults = []\nfor _ in range(m):\n    k = int(data[index]) - 1\n    index += 1\n    x = int(data[index])\n    index += 1\n    update(1, 0, n - 1, k, x)\n    results.append(query(1, 0, n - 1, 0, n - 1).ans)\n\nprint(\"\\n\".join(map(str, results)))",
        "public_test_path": "/id/public/1190",
        "hidden_test_path": "/id/hidden/1190",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "distinctvaluesqueries1734",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Distinct Values Queries",
        "description": "You are given an array of n integers and q queries of the form: how many distinct values are there in a range [a,b] ?\n\nInput\n\nThe first input line has two integers n and q : the array size and number of queries.\n\nThe next line has n integers x_1,x_2,…,x_n : the array values.\n\nFinally, there are q lines describing the queries. Each line has two integers a and b .\n\nOutput\n\nFor each query, print the number of distinct values in the range.\n\nConstraints\n\n1 ≤ n,q ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9 1 ≤ a ≤ b ≤ n\n\nExample\n\nInput:\n\n\n5 3\n3 2 3 1 2\n1 3\n2 4\n1 5\n\n\nOutput:\n\n\n2\n3\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class FT:\n    def __init__(self, n):\n        self.s = [0] * n\n\n    def update(self, pos, dif):\n        while pos < len(self.s):\n            self.s[pos] += dif\n            pos |= pos + 1\n\n    def query(self, pos):\n        res = 0\n        while pos > 0:\n            res += self.s[pos - 1]\n            pos &= pos - 1\n        return res\n\n    def lower_bound(self, sum):\n        if sum <= 0:\n            return -1\n        pos = 0\n        for pw in (1 << i for i in range(25, -1, -1)):\n            if pos + pw <= len(self.s) and self.s[pos + pw - 1] < sum:\n                pos += pw\n                sum -= self.s[pos - 1]\n        return pos\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nindex = 0\n\nn = int(data[index])\nindex += 1\nq = int(data[index])\nindex += 1\n\na = list(map(int, data[index:index + n]))\nindex += n\n\nc = sorted(set(a))\nocc = [-1] * n\nnex = [0] * n\n\nfor i in range(n - 1, -1, -1):\n    a[i] = c.index(a[i])\n    nex[i] = occ[a[i]]\n    occ[a[i]] = i\n\nqueries = [[] for _ in range(n)]\nfor i in range(q):\n    l = int(data[index]) - 1\n    index += 1\n    r = int(data[index]) - 1\n    index += 1\n    queries[l].append((r, i))\n\nft = FT(n + 5)\nfor i in range(n):\n    occ[a[i]] = -1\n\nfor i in range(n):\n    if occ[a[i]] == -1:\n        ft.update(i, 1)\n        occ[a[i]] = i\n\nans = [0] * q\nfor i in range(n):\n    for p in queries[i]:\n        ans[p[1]] = ft.query(p[0] + 1)\n    ft.update(i, -1)\n    if nex[i] != -1:\n        ft.update(nex[i], 1)\n\nprint(\"\\n\".join(map(str, ans)))",
        "public_test_path": "/id/public/1734",
        "hidden_test_path": "/id/hidden/1734",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "increasingarrayqueries2416",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Increasing Array Queries",
        "description": "You are given an array that consists of n integers. The array elements are indexed 1,2,…,n .\n\nYou can modify the array using the following operation: choose an array element and increase its value by one.\n\nYour task is to process q queries of the form: when we consider a subarray from position a to position b , what is the minimum number of operations after which the subarray is increasing?\n\nAn array is increasing if each element is greater than or equal with the previous element.\n\nInput\n\nThe first input line has two integers n and q : the size of the array and the number of queries.\n\nThe next line has n integers x_1,x_2,…,x_n : the contents of the array.\n\nFinally, there are q lines that describe the queries. Each line has two integers a and b : the starting and ending position of a subarray.\n\nOutput\n\nFor each query, print the minimum number of operations.\n\nConstraints\n\n1 ≤ n,q ≤ 2·10^5 1 ≤ x_i ≤ 10^9 1 ≤ a ≤ b ≤ n\n\nExample\n\nInput:\n\n\n5 3\n2 10 4 2 5\n3 5\n2 2\n1 4\n\n\nOutput:\n\n\n2\n0\n14",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    q = int(data[idx + 1])\n    idx += 2\n    \n    a = list(map(int, data[idx:idx + n]))\n    idx += n\n    \n    pref = [0] * n\n    for i in range(n):\n        pref[i] = a[i]\n        if i > 0:\n            pref[i] += pref[i - 1]\n    \n    queries = [[] for _ in range(n)]\n    for i in range(q):\n        a_query = int(data[idx]) - 1\n        b_query = int(data[idx + 1]) - 1\n        queries[a_query].append((b_query, i))\n        idx += 2\n    \n    ans = [0] * q\n    st = []\n    sumst = []\n    \n    for i in range(n - 1, -1, -1):\n        while st and a[st[-1]] < a[i]:\n            st.pop()\n            sumst.pop()\n        \n        bk = st[-1] if st else n\n        st.append(i)\n        sumst.append((sumst[-1] if sumst else 0) + a[i] * (bk - i))\n        \n        for j, idx in queries[i]:\n            curtop = sumst[-1]\n            if j + 1 < n:\n                lo, hi = 0, len(st) - 1\n                while lo < hi:\n                    mid = lo + (hi - lo) // 2\n                    if st[mid] <= j + 1:\n                        hi = mid\n                    else:\n                        lo = mid + 1\n                excl = sumst[lo] - a[st[lo]] * abs(j + 1 - st[lo])\n                curtop -= excl\n            \n            ans[idx] = curtop - (pref[j] - (pref[i - 1] if i > 0 else 0))\n    \n    sys.stdout.write('\\n'.join(map(str, ans)) + '\\n')\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2416",
        "hidden_test_path": "/id/hidden/2416",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 9
    },
    {
        "problem_id": "moviefestivalqueries1664",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Movie Festival Queries",
        "description": "In a movie festival, n movies will be shown. You know the starting and ending time of each movie.\n\nYour task is to process q queries of the form: if you arrive and leave the festival at specific times, what is the maximum number of movies you can watch?\n\nYou can watch two movies if the first movie ends before or exactly when the second movie starts. You can start the first movie exactly when you arrive and leave exactly when the last movie ends.\n\nInput\n\nThe first input line has two integers n and q : the number of movies and queries.\n\nAfter this, there are n lines describing the movies. Each line has two integers a and b : the starting and ending time of a movie.\n\nFinally, there are q lines describing the queries. Each line has two integers a and b : your arrival and leaving time.\n\nOutput\n\nPrint the maximum number of movies for each query.\n\nConstraints\n\n1 ≤ n,q ≤ 2 · 10^5 1 ≤ a < b ≤ 10^6\n\nExample\n\nInput:\n\n\n4 3\n2 5\n6 10\n4 7\n9 10\n5 9\n2 10\n7 10\n\n\nOutput:\n\n\n0\n2\n1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    q = int(data[idx + 1])\n    idx += 2\n    \n    ivls = []\n    for i in range(n):\n        l = int(data[idx])\n        r = int(data[idx + 1])\n        ivls.append([l, r, i])\n        idx += 2\n    \n    ivls.append([int(1e9), int(1e9) + 10, n])\n    ivlcopy = ivls.copy()\n    best = ivls[-1]\n    curbest = ivls[-1]\n    ivls.sort(reverse=True)\n    \n    queries = []\n    for i in range(q):\n        l = int(data[idx])\n        r = int(data[idx + 1])\n        queries.append([l, r, i])\n        idx += 2\n    \n    queries.sort(reverse=True)\n    \n    idx = 0\n    idx1 = 0\n    ans = [0] * q\n    par = [-1] * (n + 1)\n    par[n] = n\n    jmp = [[0] * 20 for _ in range(n + 1)]\n    n += 1\n    \n    for l, r, iq in queries:\n        while idx < n and ivls[idx][0] >= l:\n            a, b, iv = ivls[idx]\n            while idx1 < n and ivls[idx1][0] <= b:\n                if ivls[idx1][1] < best[1]:\n                    best = ivls[idx1]\n                idx1 += 1\n            \n            jmp[iv][0] = par[iv] = best[2]\n            for i in range(1, 20):\n                jmp[iv][i] = jmp[jmp[iv][i - 1]][i - 1]\n            if b < curbest[1]:\n                curbest = ivls[idx]\n            idx += 1\n        \n        a = 0\n        if curbest[1] <= r:\n            a += 1\n            cur = curbest[2]\n            for i in range(19, -1, -1):\n                if ivlcopy[jmp[cur][i]][1] <= r:\n                    a += 1 << i\n                    cur = jmp[cur][i]\n        \n        ans[iq] = a\n    \n    print(\"\\n\".join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1664",
        "hidden_test_path": "/id/hidden/1664",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 5
    },
    {
        "problem_id": "polynomialqueries1736",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Polynomial Queries",
        "description": "Your task is to maintain an array of n values and efficiently process the following types of queries:\n\nIncrease the first value in range [a,b] by 1 , the second value by 2 , the third value by 3 , and so on. Calculate the sum of values in range [a,b] .\n\nInput\n\nThe first input line has two integers n and q : the size of the array and the number of queries.\n\nThe next line has n values t_1,t_2,…,t_n : the initial contents of the array.\n\nFinally, there are q lines describing the queries. The format of each line is either \"1 a b \" or \"2 a b \".\n\nOutput\n\nPrint the answer to each sum query.\n\nConstraints\n\n1 ≤ n, q ≤ 2 · 10^5 1 ≤ t_i ≤ 10^6 1 ≤ a ≤ b ≤ n\n\nExample\n\nInput:\n\n\n5 3\n4 2 3 1 7\n2 1 5\n1 1 5\n2 1 5\n\n\nOutput:\n\n\n17\n32",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Node:\n    def __init__(self, v, lo, hi):\n        self.l = None\n        self.r = None\n        self.lo = lo\n        self.hi = hi\n        self.lzconst = 0\n        self.lzslope = 0\n        self.initial = 0\n        if lo + 1 < hi:\n            mid = lo + (hi - lo) // 2\n            self.l = Node(v, lo, mid)\n            self.r = Node(v, mid, hi)\n            self.initial = self.l.initial + self.r.initial\n        else:\n            self.initial = v[lo]\n\n    def query(self, L, R):\n        if R <= self.lo or self.hi <= L:\n            return 0\n        if L <= self.lo and self.hi <= R:\n            return self.initial\n        self.push()\n        return self.l.query(L, R) + self.r.query(L, R)\n\n    def add(self, L, R):\n        if R <= self.lo or self.hi <= L:\n            return\n        if L <= self.lo and self.hi <= R:\n            self.initial += (self.lo - L) * (self.hi - self.lo)\n            self.lzconst += (self.lo - L)\n            self.initial += tri(self.hi - self.lo)\n            self.lzslope += 1\n        else:\n            self.push()\n            self.l.add(L, R)\n            self.r.add(L, R)\n            self.initial = self.l.initial + self.r.initial\n\n    def push(self):\n        if self.lo + 1 == self.hi:\n            return\n        if self.lzslope != 0:\n            self.l.lzslope += self.lzslope\n            self.r.lzslope += self.lzslope\n            self.r.lzconst += (self.r.lo - self.lo) * self.lzslope\n            self.r.initial += (self.r.lo - self.lo) * self.lzslope * (self.r.hi - self.r.lo)\n            self.l.initial += self.lzslope * tri(self.l.hi - self.l.lo)\n            self.r.initial += self.lzslope * tri(self.r.hi - self.r.lo)\n            self.lzslope = 0\n        if self.lzconst != 0:\n            self.l.lzconst += self.lzconst\n            self.r.lzconst += self.lzconst\n            self.l.initial += self.lzconst * (self.l.hi - self.l.lo)\n            self.r.initial += self.lzconst * (self.r.hi - self.r.lo)\n            self.lzconst = 0\n\ndef tri(x):\n    if x <= 1:\n        return 1\n    return (x + 1) * x // 2\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    q = int(data[idx])\n    idx += 1\n    a = list(map(int, data[idx:idx+n]))\n    idx += n\n    \n    tree = Node(a, 0, n)\n    \n    output = []\n    for _ in range(q):\n        t = int(data[idx])\n        idx += 1\n        if t == 1:\n            a = int(data[idx]) - 1\n            idx += 1\n            b = int(data[idx]) - 1\n            idx += 1\n            tree.add(a, b + 1)\n        else:\n            a = int(data[idx]) - 1\n            idx += 1\n            b = int(data[idx]) - 1\n            idx += 1\n            output.append(tree.query(a, b + 1))\n    \n    print(\"\\n\".join(map(str, output)))",
        "public_test_path": "/id/public/1736",
        "hidden_test_path": "/id/hidden/1736",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 3
    },
    {
        "problem_id": "rangequeriesandcopies1737",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Range Queries and Copies",
        "description": "Your task is to maintain a list of arrays which initially has a single array. You have to process the following types of queries:\n\nSet the value a in array k to x . Calculate the sum of values in range [a,b] in array k . Create a copy of array k and add it to the end of the list.\n\nInput\n\nThe first input line has two integers n and q : the array size and the number of queries.\n\nThe next line has n integers t_1,t_2,…,t_n : the initial contents of the array.\n\nFinally, there are q lines describing the queries. The format of each line is one of the following: \"1 k a x \", \"2 k a b \" or \"3 k \".\n\nOutput\n\nPrint the answer to each sum query.\n\nConstraints\n\n1 ≤ n, q ≤ 2 · 10^5 1 ≤ t_i, x ≤ 10^9 1 ≤ a ≤ b ≤ n\n\nExample\n\nInput:\n\n\n5 6\n2 3 1 2 5\n3 1\n2 1 1 5\n2 2 1 5\n1 2 2 5\n2 1 1 5\n2 2 1 5\n\n\nOutput:\n\n\n13\n13\n13\n15",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Node:\n    def __init__(self, v, lo, hi):\n        self.l = None\n        self.r = None\n        self.lo = lo\n        self.hi = hi\n        self.mset = 0\n        if lo + 1 < hi:\n            mid = lo + (hi - lo) // 2\n            self.l = Node(v, lo, mid)\n            self.r = Node(v, mid, hi)\n            self.sum = self.l.sum + self.r.sum\n        else:\n            self.sum = v[lo]\n\n    def query(self, L, R):\n        if R <= self.lo or self.hi <= L:\n            return 0\n        if L <= self.lo and self.hi <= R:\n            return self.sum\n        return self.l.query(L, R) + self.r.query(L, R)\n\n    def set(self, ind, x):\n        L = ind\n        R = ind + 1\n        if R <= self.lo or self.hi <= L:\n            return self\n        ret = Node(self.v, self.lo, self.hi)\n        if L <= self.lo and self.hi <= R:\n            ret.mset = x\n            ret.sum = x * (self.hi - self.lo)\n            return ret\n        else:\n            ret.l = self.l.set(ind, x)\n            ret.r = self.r.set(ind, x)\n            ret.sum = ret.l.sum + ret.r.sum\n        return ret\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nindex = 0\n\nn = int(data[index])\nindex += 1\nq = int(data[index])\nindex += 1\na = list(map(int, data[index:index + n]))\nindex += n\n\ntree = Node(a, 0, n)\nroots = [tree]\n\nfor _ in range(q):\n    t = int(data[index])\n    index += 1\n    k = int(data[index]) - 1\n    index += 1\n    if t == 1:\n        a = int(data[index]) - 1\n        index += 1\n        x = int(data[index])\n        index += 1\n        roots[k] = roots[k].set(a, x)\n    elif t == 2:\n        a = int(data[index]) - 1\n        index += 1\n        b = int(data[index])\n        index += 1\n        print(roots[k].query(a, b))\n    else:\n        roots.append(Node(roots[k].v, roots[k].lo, roots[k].hi))",
        "public_test_path": "/id/public/1737",
        "hidden_test_path": "/id/hidden/1737",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "missingcoinsumqueries2184",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Missing Coin Sum Queries",
        "description": "You have n coins with positive integer values. The coins are numbered 1,2,…,n .\n\nYour task is to process q queries of the form: \"if you can use coins a … b , what is the smallest sum you cannot produce?\"\n\nInput\n\nThe first input line has two integers n and q : the number of coins and queries.\n\nThe second line has n integers x_1,x_2,…,x_n : the value of each coin.\n\nFinally, there are q lines that describe the queries. Each line has two values a and b : you can use coins a … b .\n\nOutput\n\nPrint the answer for each query.\n\nConstraints\n\n1 ≤ n, q ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9 1 ≤ a ≤ b ≤ n\n\nExample\n\nInput:\n\n\n5 3\n2 9 1 2 7\n2 4\n4 4\n1 5\n\n\nOutput:\n\n\n4\n1\n6\n\n\nExplanation: First you can use coins [9,1,2] , then coins [2] and finally coins [2,9,1,2,7] .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport math\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nmx = int(2e5 + 5)\nn, q = int(data[0]), int(data[1])\nA = [0] * mx\nsm = [[0] * 30 for _ in range(mx)]\nseg = [[float('inf')] * 30 for _ in range(mx * 2)]\n\ndef comb(A, B):\n    return [min(A[i], B[i]) for i in range(30)]\n\ndef qry(l, r):\n    ret = [float('inf')] * 30\n    l += mx\n    r += mx\n    while l <= r:\n        if l % 2 == 1:\n            ret = comb(ret, seg[l])\n            l += 1\n        if r % 2 == 0:\n            ret = comb(seg[r], ret)\n            r -= 1\n        l //= 2\n        r //= 2\n    return ret\n\nindex = 2\nfor i in range(1, n + 1):\n    x = int(data[index])\n    index += 1\n    g = int(math.log2(x))\n    seg[i + mx][g] = x\n    sm[i][g] = x\n\nfor i in range(1, n + 1):\n    for j in range(30):\n        sm[i][j] += sm[i - 1][j]\n\nfor i in range(mx - 1, 0, -1):\n    seg[i] = comb(seg[i * 2], seg[i * 2 + 1])\n\noutput = []\nfor _ in range(q):\n    l = int(data[index])\n    r = int(data[index + 1])\n    index += 2\n\n    bst = qry(l, r)\n    tot = 0\n    ans = -1\n    for i in range(30):\n        if tot + 1 < (1 << (i + 1)) and bst[i] > tot + 1:\n            ans = tot + 1\n            break\n        tot += sm[r][i] - sm[l - 1][i]\n    \n    output.append(str(tot + 1 if ans == -1 else ans))\n\nprint(\"\\n\".join(output))",
        "public_test_path": "/id/public/2184",
        "hidden_test_path": "/id/hidden/2184",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "subordinates1674",
        "topic": "Chương 1",
        "sub_topic": "Tree Algorithms",
        "name": "Subordinates",
        "description": "Given the structure of a company, your task is to calculate for each employee the number of their subordinates.\n\nInput\n\nThe first input line has an integer n : the number of employees. The employees are numbered 1,2,…,n , and employee 1 is the general director of the company.\n\nAfter this, there are n-1 integers: for each employee 2,3,…,n their direct boss in the company.\n\nOutput\n\nPrint n integers: for each employee 1,2,…,n the number of their subordinates.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5\n\nExample\n\nInput:\n\n\n5\n1 1 2 3\n\n\nOutput:\n\n\n4 1 1 0 0",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    from collections import defaultdict\n    \n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    par = list(map(int, data[1:n]))\n    par = [p - 1 for p in par]  # Convert to 0-based index\n    child = defaultdict(list)\n    \n    for i in range(1, n):\n        child[par[i - 1]].append(i)\n    \n    subsz = [1] * n\n    \n    def dfs(cur):\n        for i in child[cur]:\n            dfs(i)\n            subsz[cur] += subsz[i]\n    \n    dfs(0)\n    \n    print(\" \".join(str(subsz[i] - 1) for i in range(n)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1674",
        "hidden_test_path": "/id/hidden/1674",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "treematching1130",
        "topic": "Chương 1",
        "sub_topic": "Tree Algorithms",
        "name": "Tree Matching",
        "description": "You are given a tree consisting of n nodes.\n\nA matching is a set of edges where each node is an endpoint of at most one edge. What is the maximum number of edges in a matching?\n\nInput\n\nThe first input line contains an integer n : the number of nodes. The nodes are numbered 1,2,…,n .\n\nThen there are n-1 lines describing the edges. Each line contains two integers a and b : there is an edge between nodes a and b .\n\nOutput\n\nPrint one integer: the maximum number of pairs.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5\n1 2\n1 3\n3 4\n3 5\n\n\nOutput:\n\n\n2\n\n\nExplanation: One possible matching is (1,2) and (3,4) .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    adj = defaultdict(list)\n    \n    index = 1\n    for _ in range(n - 1):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        adj[a].append(b)\n        adj[b].append(a)\n        index += 2\n\n    BLANK = -1\n    dp = [[BLANK] * 2 for _ in range(n)]\n\n    def dfs(cur, pre, used):\n        if dp[cur][used] != BLANK:\n            return dp[cur][used]\n        dp[cur][used] = 0\n        reg = 0\n        for i in adj[cur]:\n            if i == pre:\n                continue\n            reg += max(dfs(i, cur, 0), dfs(i, cur, 1))\n        if used:\n            for i in adj[cur]:\n                if i == pre:\n                    continue\n                dp[cur][used] = max(dp[cur][used], 1 + reg - max(dfs(i, cur, 0), dfs(i, cur, 1)) + dfs(i, cur, 0))\n        else:\n            dp[cur][used] = reg\n        return dp[cur][used]\n\n    print(max(dfs(0, -1, 0), dfs(0, -1, 1)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1130",
        "hidden_test_path": "/id/hidden/1130",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "treediameter1131",
        "topic": "Chương 1",
        "sub_topic": "Tree Algorithms",
        "name": "Tree Diameter",
        "description": "You are given a tree consisting of n nodes.\n\nThe diameter of a tree is the maximum distance between two nodes. Your task is to determine the diameter of the tree.\n\nInput\n\nThe first input line contains an integer n : the number of nodes. The nodes are numbered 1,2,…,n .\n\nThen there are n-1 lines describing the edges. Each line contains two integers a and b : there is an edge between nodes a and b .\n\nOutput\n\nPrint one integer: the diameter of the tree.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5\n1 2\n1 3\n3 4\n3 5\n\n\nOutput:\n\n\n3\n\n\nExplanation: The diameter corresponds to the path 2 → 1 → 3 → 5 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    adj = defaultdict(list)\n    \n    for i in range(1, n):\n        a, b = map(int, data[i].split())\n        a -= 1\n        b -= 1\n        adj[a].append(b)\n        adj[b].append(a)\n\n    farthest = -1\n    dist = -1\n\n    def dfs(cur, pre, d):\n        nonlocal farthest, dist\n        if d > dist:\n            dist = d\n            farthest = cur\n        for i in adj[cur]:\n            if i == pre:\n                continue\n            dfs(i, cur, d + 1)\n\n    dfs(0, -1, 0)\n    t1 = farthest\n    farthest = dist = -1\n    dfs(t1, -1, 0)\n    \n    print(dist)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1131",
        "hidden_test_path": "/id/hidden/1131",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 18
    },
    {
        "problem_id": "distancequeries1135",
        "topic": "Chương 1",
        "sub_topic": "Tree Algorithms",
        "name": "Distance Queries",
        "description": "You are given a tree consisting of n nodes.\n\nYour task is to process q queries of the form: what is the distance between nodes a and b ?\n\nInput\n\nThe first input line contains two integers n and q : the number of nodes and queries. The nodes are numbered 1,2,…,n .\n\nThen there are n-1 lines describing the edges. Each line contains two integers a and b : there is an edge between nodes a and b .\n\nFinally, there are q lines describing the queries. Each line contains two integer a and b : what is the distance between nodes a and b ?\n\nOutput\n\nPrint q integers: the answer to each query.\n\nConstraints\n\n1 ≤ n, q ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 3\n1 2\n1 3\n3 4\n3 5\n1 3\n2 5\n1 4\n\n\nOutput:\n\n\n1\n3\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from sys import stdin, stdout\nfrom collections import defaultdict\nimport math\n\nclass RMQ:\n    def __init__(self, V):\n        self.jmp = [V]\n        n = len(V)\n        pw = 1\n        k = 1\n        while pw * 2 <= n:\n            self.jmp.append([0] * (n - pw * 2 + 1))\n            for j in range(len(self.jmp[k])):\n                self.jmp[k][j] = min(self.jmp[k - 1][j], self.jmp[k - 1][j + pw])\n            pw *= 2\n            k += 1\n\n    def query(self, a, b):\n        assert a < b\n        dep = 31 - (b - a).bit_length() + 1\n        return min(self.jmp[dep][a], self.jmp[dep][b - (1 << dep)])\n\nclass LCA:\n    def __init__(self, C):\n        self.T = 0\n        self.time = [0] * len(C)\n        self.path = []\n        self.ret = []\n        self.depth = [0] * len(C)\n        self.rmq = RMQ(self.dfs(C, 0, -1, 0))\n\n    def dfs(self, C, v, par, d):\n        self.time[v] = self.T\n        self.depth[v] = d\n        self.T += 1\n        for y in C[v]:\n            if y != par:\n                self.path.append(v)\n                self.ret.append(self.time[v])\n                self.dfs(C, y, v, d + 1)\n        return self.ret\n\n    def lca(self, a, b):\n        if a == b:\n            return a\n        a, b = sorted((self.time[a], self.time[b]))\n        return self.path[self.rmq.query(a, b)]\n\n    def dist(self, a, b):\n        return self.depth[a] + self.depth[b] - 2 * self.depth[self.lca(a, b)]\n\ndef main():\n    input = stdin.read\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    q = int(data[idx])\n    idx += 1\n    \n    adj = defaultdict(list)\n    \n    for _ in range(n - 1):\n        a = int(data[idx]) - 1\n        idx += 1\n        b = int(data[idx]) - 1\n        idx += 1\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    lca = LCA(adj)\n    \n    result = []\n    for _ in range(q):\n        a = int(data[idx]) - 1\n        idx += 1\n        b = int(data[idx]) - 1\n        idx += 1\n        result.append(str(lca.dist(a, b)))\n    \n    stdout.write(\"\\n\".join(result) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1135",
        "hidden_test_path": "/id/hidden/1135",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "countingpaths1136",
        "topic": "Chương 1",
        "sub_topic": "Tree Algorithms",
        "name": "Counting Paths",
        "description": "You are given a tree consisting of n nodes, and m paths in the tree.\n\nYour task is to calculate for each node the number of paths containing that node.\n\nInput\n\nThe first input line contains integers n and m : the number of nodes and paths. The nodes are numbered 1,2,…,n .\n\nThen there are n-1 lines describing the edges. Each line contains two integers a and b : there is an edge between nodes a and b .\n\nFinally, there are m lines describing the paths. Each line contains two integers a and b : there is a path between nodes a and b .\n\nOutput\n\nPrint n integers: for each node 1,2,…,n , the number of paths containing that node.\n\nConstraints\n\n1 ≤ n, m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 3\n1 2\n1 3\n3 4\n3 5\n1 3\n2 5\n1 4\n\n\nOutput:\n\n\n3 1 3 1 1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport sys\nimport math\n\nclass RMQ:\n    def __init__(self, V):\n        self.jmp = [V]\n        n = len(V)\n        pw = 1\n        k = 1\n        while pw * 2 <= n:\n            self.jmp.append([0] * (n - pw * 2 + 1))\n            for j in range(len(self.jmp[k])):\n                self.jmp[k][j] = min(self.jmp[k - 1][j], self.jmp[k - 1][j + pw])\n            pw *= 2\n            k += 1\n\n    def query(self, a, b):\n        assert a < b\n        dep = 31 - (b - a).bit_length() + 1\n        return min(self.jmp[dep][a], self.jmp[dep][b - (1 << dep)])\n\nclass LCA:\n    def __init__(self, C):\n        self.T = 0\n        self.time = [0] * len(C)\n        self.path = []\n        self.ret = []\n        self.rmq = RMQ(self.dfs(C, 0, -1))\n\n    def dfs(self, C, v, par):\n        self.time[v] = self.T\n        self.T += 1\n        for y in C[v]:\n            if y != par:\n                self.path.append(v)\n                self.ret.append(self.time[v])\n                self.dfs(C, y, v)\n        return self.ret\n\n    def lca(self, a, b):\n        if a == b:\n            return a\n        a, b = sorted((self.time[a], self.time[b]))\n        return self.path[self.rmq.query(a, b)]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    q = int(data[idx + 1])\n    idx += 2\n\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        a = int(data[idx]) - 1\n        b = int(data[idx + 1]) - 1\n        adj[a].append(b)\n        adj[b].append(a)\n        idx += 2\n\n    lca = LCA(adj)\n    subsz = [1] * n\n    marked = [0] * n\n    par = [0] * n\n\n    def dfs(cur, pre):\n        par[cur] = pre\n        for i in adj[cur]:\n            if i == pre:\n                continue\n            dfs(i, cur)\n            subsz[cur] += subsz[i]\n\n    dfs(0, -1)\n\n    for _ in range(q):\n        a = int(data[idx]) - 1\n        b = int(data[idx + 1]) - 1\n        idx += 2\n        lc = lca.lca(a, b)\n        marked[a] += 1\n        marked[b] += 1\n        marked[lc] -= 1\n        if lc != 0:\n            marked[par[lc]] -= 1\n\n    def dfs1(cur, pre):\n        for i in adj[cur]:\n            if i == pre:\n                continue\n            dfs1(i, cur)\n            marked[cur] += marked[i]\n\n    dfs1(0, -1)\n    ans = [0] * n\n    for i in range(n):\n        print(marked[i], end=\" \")\n    print()\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1136",
        "hidden_test_path": "/id/hidden/1136",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "subtreequeries1137",
        "topic": "Chương 1",
        "sub_topic": "Tree Algorithms",
        "name": "Subtree Queries",
        "description": "You are given a rooted tree consisting of n nodes. The nodes are numbered 1,2,…,n , and node 1 is the root. Each node has a value.\n\nYour task is to process following types of queries:\n\nchange the value of node s to x calculate the sum of values in the subtree of node s\n\nInput\n\nThe first input line contains two integers n and q : the number of nodes and queries. The nodes are numbered 1,2,…,n .\n\nThe next line has n integers v_1,v_2,…,v_n : the value of each node.\n\nThen there are n-1 lines describing the edges. Each line contans two integers a and b : there is an edge between nodes a and b .\n\nFinally, there are q lines describing the queries. Each query is either of the form \"1 s x \" or \"2 s \".\n\nOutput\n\nPrint the answer to each query of type 2.\n\nConstraints\n\n1 ≤ n, q ≤ 2 · 10^5 1 ≤ a,b, s ≤ n 1 ≤ v_i, x ≤ 10^9\n\nExample\n\nInput:\n\n\n5 3\n4 2 5 2 1\n1 2\n1 3\n3 4\n3 5\n2 3\n1 5 3\n2 3\n\n\nOutput:\n\n\n8\n10",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Node:\n    def __init__(self, lo, hi, v=None):\n        self.l = None\n        self.r = None\n        self.lo = lo\n        self.hi = hi\n        if v is not None:\n            if lo + 1 < hi:\n                mid = lo + (hi - lo) // 2\n                self.l = Node(lo, mid, v)\n                self.r = Node(mid, hi, v)\n                self.val = self.l.val + self.r.val\n            else:\n                self.val = v[lo]\n        else:\n            self.val = 0\n\n    def query(self, L, R):\n        if R <= self.lo or self.hi <= L:\n            return 0\n        if L <= self.lo and self.hi <= R:\n            return self.val\n        return self.l.query(L, R) + self.r.query(L, R)\n\n    def set(self, L, R, x):\n        if R <= self.lo or self.hi <= L:\n            return\n        if L <= self.lo and self.hi <= R:\n            self.val = x\n        else:\n            self.l.set(L, R, x)\n            self.r.set(L, R, x)\n            self.val = self.l.val + self.r.val\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    q = int(data[idx + 1])\n    idx += 2\n    \n    a = list(map(int, data[idx:idx + n]))\n    idx += n\n    \n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u = int(data[idx]) - 1\n        v = int(data[idx + 1]) - 1\n        adj[u].append(v)\n        adj[v].append(u)\n        idx += 2\n    \n    euler = []\n    dfsorder = [0] * n\n    treesz = [1] * n\n\n    def dfs(cur, pre):\n        dfsorder[cur] = len(euler)\n        euler.append(a[cur])\n        for i in adj[cur]:\n            if i == pre:\n                continue\n            dfs(i, cur)\n            treesz[cur] += treesz[i]\n\n    dfs(0, -1)\n    tree = Node(0, n, euler)\n\n    output = []\n    for _ in range(q):\n        t = int(data[idx])\n        if t == 1:\n            s = int(data[idx + 1]) - 1\n            x = int(data[idx + 2])\n            tree.set(dfsorder[s], dfsorder[s] + 1, x)\n            idx += 3\n        else:\n            s = int(data[idx + 1]) - 1\n            output.append(tree.query(dfsorder[s], dfsorder[s] + treesz[s]))\n            idx += 2\n\n    print(\"\\n\".join(map(str, output)))\n\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1137",
        "hidden_test_path": "/id/hidden/1137",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "pathqueries1138",
        "topic": "Chương 1",
        "sub_topic": "Tree Algorithms",
        "name": "Path Queries",
        "description": "You are given a rooted tree consisting of n nodes. The nodes are numbered 1,2,…,n , and node 1 is the root. Each node has a value.\n\nYour task is to process following types of queries:\n\nchange the value of node s to x calculate the sum of values on the path from the root to node s\n\nInput\n\nThe first input line contains two integers n and q : the number of nodes and queries. The nodes are numbered 1,2,…,n .\n\nThe next line has n integers v_1,v_2,…,v_n : the value of each node.\n\nThen there are n-1 lines describing the edges. Each line contains two integers a and b : there is an edge between nodes a and b .\n\nFinally, there are q lines describing the queries. Each query is either of the form \"1 s x \" or \"2 s \".\n\nOutput\n\nPrint the answer to each query of type 2.\n\nConstraints\n\n1 ≤ n, q ≤ 2 · 10^5 1 ≤ a,b, s ≤ n 1 ≤ v_i, x ≤ 10^9\n\nExample\n\nInput:\n\n\n5 3\n4 2 5 2 1\n1 2\n1 3\n3 4\n3 5\n2 4\n1 3 2\n2 4\n\n\nOutput:\n\n\n11\n8",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Node:\n    def __init__(self, lo, hi, v=None):\n        self.l = None\n        self.r = None\n        self.lo = lo\n        self.hi = hi\n        if v is not None:\n            if lo + 1 < hi:\n                mid = lo + (hi - lo) // 2\n                self.l = Node(lo, mid, v)\n                self.r = Node(mid, hi, v)\n                self.val = self.l.val + self.r.val\n            else:\n                self.val = v[lo]\n        else:\n            self.val = 0\n\n    def query(self, L, R):\n        if R <= self.lo or self.hi <= L:\n            return 0\n        if L <= self.lo and self.hi <= R:\n            return self.val\n        return self.l.query(L, R) + self.r.query(L, R)\n\n    def set(self, L, R, x):\n        if R <= self.lo or self.hi <= L:\n            return\n        if L <= self.lo and self.hi <= R:\n            self.val = x\n        else:\n            self.l.set(L, R, x)\n            self.r.set(L, R, x)\n            self.val = self.l.val + self.r.val\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    q = int(data[idx + 1])\n    idx += 2\n    \n    a = list(map(int, data[idx:idx + n]))\n    idx += n\n    \n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b = int(data[idx]) - 1, int(data[idx + 1]) - 1\n        adj[a].append(b)\n        adj[b].append(a)\n        idx += 2\n    \n    siz = 0\n    euler = [0] * (2 * n + 5)\n    dfsorder1 = [0] * n\n    dfsorder2 = [0] * n\n    treesz = [1] * n\n\n    def dfs(cur, pre):\n        nonlocal siz\n        dfsorder1[cur] = siz\n        euler[siz] = a[cur]\n        siz += 1\n        for i in adj[cur]:\n            if i == pre:\n                continue\n            dfs(i, cur)\n            treesz[cur] += treesz[i]\n        dfsorder2[cur] = siz\n        euler[siz] = -a[cur]\n        siz += 1\n\n    dfs(0, -1)\n    tree = Node(0, len(euler), euler)\n\n    output = []\n    for _ in range(q):\n        t = int(data[idx])\n        if t == 1:\n            s = int(data[idx + 1]) - 1\n            x = int(data[idx + 2])\n            tree.set(dfsorder1[s], dfsorder1[s] + 1, x)\n            tree.set(dfsorder2[s], dfsorder2[s] + 1, -x)\n            idx += 3\n        else:\n            s = int(data[idx + 1]) - 1\n            output.append(str(tree.query(0, dfsorder1[s] + 1)))\n            idx += 2\n\n    print(\"\\n\".join(output))\n\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1138",
        "hidden_test_path": "/id/hidden/1138",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "distinctcolors1139",
        "topic": "Chương 1",
        "sub_topic": "Tree Algorithms",
        "name": "Distinct Colors",
        "description": "You are given a rooted tree consisting of n nodes. The nodes are numbered 1,2,…,n , and node 1 is the root. Each node has a color.\n\nYour task is to determine for each node the number of distinct colors in the subtree of the node.\n\nInput\n\nThe first input line contains an integer n : the number of nodes. The nodes are numbered 1,2,…,n .\n\nThe next line consists of n integers c_1,c_2,…,c_n : the color of each node.\n\nThen there are n-1 lines describing the edges. Each line contains two integers a and b : there is an edge between nodes a and b .\n\nOutput\n\nPrint n integers: for each node 1,2,…,n , the number of distinct colors.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ a,b ≤ n 1 ≤ c_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5\n2 3 2 2 1\n1 2\n1 3\n3 4\n3 5\n\n\nOutput:\n\n\n3 1 2 1 1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport sys\ninput = sys.stdin.read\n\nclass FT:\n    def __init__(self, n):\n        self.s = [0] * n\n\n    def update(self, pos, dif):\n        while pos < len(self.s):\n            self.s[pos] += dif\n            pos |= pos + 1\n\n    def query(self, pos):\n        res = 0\n        while pos > 0:\n            res += self.s[pos - 1]\n            pos &= pos - 1\n        return res\n\n    def lower_bound(self, sum):\n        if sum <= 0:\n            return -1\n        pos = 0\n        for pw in (1 << i for i in range(25, -1, -1)):\n            if pos + pw <= len(self.s) and self.s[pos + pw - 1] < sum:\n                pos += pw\n                sum -= self.s[pos - 1]\n        return pos\n\ndef main():\n    input_data = input().split()\n    idx = 0\n    n = int(input_data[idx])\n    idx += 1\n    a = list(map(int, input_data[idx:idx + n]))\n    idx += n\n\n    adj = defaultdict(list)\n    for _ in range(n - 1):\n        a_node = int(input_data[idx]) - 1\n        b_node = int(input_data[idx + 1]) - 1\n        idx += 2\n        adj[a_node].append(b_node)\n        adj[b_node].append(a_node)\n\n    euler = []\n    dfsorder = [0] * n\n    treesz = [1] * n\n\n    def dfs(cur, pre):\n        dfsorder[cur] = len(euler)\n        euler.append(cur)\n        for i in adj[cur]:\n            if i == pre:\n                continue\n            dfs(i, cur)\n            treesz[cur] += treesz[i]\n\n    dfs(0, -1)\n\n    a2 = a[:]\n    treesz2 = treesz[:]\n    for i in range(n):\n        a[i] = a2[euler[i]]\n        treesz[i] = treesz2[euler[i]]\n\n    occ = {}\n    for i in range(n):\n        occ[a[i]] = -1\n\n    nex = [0] * n\n    for i in range(n - 1, -1, -1):\n        nex[i] = occ[a[i]]\n        occ[a[i]] = i\n\n    queries = [[] for _ in range(n)]\n    for i in range(n):\n        queries[i].append((i + treesz[i] - 1, i))\n\n    ft = FT(n + 5)\n    occ.clear()\n    for i in range(n):\n        occ[a[i]] = -1\n\n    for i in range(n):\n        if occ[a[i]] == -1:\n            ft.update(i, 1)\n            occ[a[i]] = i\n\n    ans = [0] * n\n    for i in range(n):\n        for p in queries[i]:\n            ans[p[1]] = ft.query(p[0] + 1)\n        ft.update(i, -1)\n        if nex[i] != -1:\n            ft.update(nex[i], 1)\n\n    ans2 = ans[:]\n    for i in range(n):\n        ans[i] = ans2[dfsorder[i]]\n\n    print(\" \".join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1139",
        "hidden_test_path": "/id/hidden/1139",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "josephusqueries2164",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Josephus Queries",
        "description": "Consider a game where there are n children (numbered 1,2,…,n ) in a circle. During the game, every second child is removed from the circle, until there are no children left.\n\nYour task is to process q queries of the form: \"when there are n children, who is the k th child that will be removed?\"\n\nInput\n\nThe first input line has an integer q : the number of queries.\n\nAfter this, there are q lines that describe the queries. Each line has two integers n and k : the number of children and the position of the child.\n\nOutput\n\nPrint q integers: the answer for each query.\n\nConstraints\n\n1 ≤ q ≤ 10^5 1 ≤ k ≤ n ≤ 10^9\n\nExample\n\nInput:\n\n\n4\n7 1\n7 3\n2 2\n1337 1313\n\n\nOutput:\n\n\n2\n6\n1\n1107",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def solve2(n, k):\n    p = 2\n    i1, i2 = 1, 2\n    parity = 1\n    while n > 0:\n        if parity == 1:\n            val = i2\n            i2 = -1\n        else:\n            val = i1\n            i1 = i2\n            i2 = -1\n        i2 = i1 + p\n        tmp = parity\n        parity ^= (n % 2)\n        rem = (n + 1 - tmp) // 2\n        if k <= rem:\n            return val + (k - 1) * p\n        n -= rem\n        k -= rem\n        p <<= 1\n    return -1\n\ndef solve(n):\n    left = set(range(1, n + 1))\n    seq = []\n    seq2 = []\n    parity = 0\n    while left:\n        rem = []\n        cnt = 0\n        for i in left:\n            if cnt >= 2:\n                break\n            cnt += 1\n            print(f\"{i},\", end=\"\")\n        for i in left:\n            parity = 1 - parity\n            if parity == 0:\n                rem.append(i)\n        if rem:\n            seq2.append(rem[0])\n        else:\n            seq2.append(-1)\n        for i in rem:\n            seq.append(i)\n            left.remove(i)\n        print(\" \", end=\"\")\n    print()\n    return seq2\n\ndef binstr(n):\n    res = \"\"\n    leftover = 0\n    while n > 0:\n        tmp = leftover\n        leftover = (n - leftover) % 2\n        res += str(leftover)\n        n -= (n + 1 - tmp) // 2\n    return res\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    q = int(data[0])\n    index = 1\n    for _ in range(q):\n        n = int(data[index])\n        k = int(data[index + 1])\n        print(solve2(n, k))\n        index += 2",
        "public_test_path": "/id/public/2164",
        "hidden_test_path": "/id/hidden/2164",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 2
    },
    {
        "problem_id": "exponentiation1095",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Exponentiation",
        "description": "Your task is to efficiently calculate values a^b modulo 10^9+7 .\n\nNote that in this task we assume that 0^0=1 .\n\nInput\n\nThe first input line contains an integer n : the number of calculations.\n\nAfter this, there are n lines, each containing two integers a and b .\n\nOutput\n\nPrint each value a^b modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 0 ≤ a,b ≤ 10^9\n\nExample\n\nInput:\n\n\n3\n3 4\n2 8\n123 123\n\n\nOutput:\n\n\n81\n256\n921450052",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "m = 1000000007\n\ndef mod(k):\n    return k % m\n\ndef modpow(b, p):\n    if p == 0:\n        return 1\n    if p == 1:\n        return b\n    a = modpow(b, p // 2)\n    return mod(a * a * modpow(b, p % 2))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    results = []\n    for i in range(1, n + 1):\n        a, b = map(int, data[i].split())\n        results.append(modpow(a, b))\n    \n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1095",
        "hidden_test_path": "/id/hidden/1095",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 3
    },
    {
        "problem_id": "countingdivisors1713",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Counting Divisors",
        "description": "Given n integers, your task is to report for each integer the number of its divisors.\n\nFor example, if x=18 , the correct answer is 6 because its divisors are 1,2,3,6,9,18 .\n\nInput\n\nThe first input line has an integer n : the number of integers.\n\nAfter this, there are n lines, each containing an integer x .\n\nOutput\n\nFor each integer, print the number of its divisors.\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ x ≤ 10^6\n\nExample\n\nInput:\n\n\n3\n16\n17\n18\n\n\nOutput:\n\n\n5\n2\n6",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport math\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    results = []\n    \n    for i in range(1, n + 1):\n        x = int(data[i])\n        ans = 0\n        for j in range(1, int(math.sqrt(x)) + 1):\n            if x % j == 0:\n                ans += 2\n                if j * j == x:\n                    ans -= 1\n        results.append(ans)\n    \n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1713",
        "hidden_test_path": "/id/hidden/1713",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "commondivisors1081",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Common Divisors",
        "description": "You are given an array of n positive integers. Your task is to find two integers such that their greatest common divisor is as large as possible.\n\nInput\n\nThe first input line has an integer n : the size of the array.\n\nThe second line has n integers x_1,x_2,…,x_n : the contents of the array.\n\nOutput\n\nPrint the maximum greatest common divisor.\n\nConstraints\n\n2 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^6\n\nExample\n\nInput:\n\n\n5\n3 14 15 7 9\n\n\nOutput:\n\n\n7",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\narr = list(map(int, data[1:n+1]))\n\nfreq = defaultdict(int)\n\nfor i in range(n):\n    for j in range(1, int(arr[i]**0.5) + 1):\n        if arr[i] % j == 0:\n            freq[j] += 1\n            if j * j != arr[i]:\n                freq[arr[i] // j] += 1\n\nans = 0\nfor i in range(1000001):\n    if freq[i] > 1:\n        ans = max(ans, i)\n\nprint(ans)",
        "public_test_path": "/id/public/1081",
        "hidden_test_path": "/id/hidden/1081",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 18
    },
    {
        "problem_id": "sumofdivisors1082",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Sum of Divisors",
        "description": "Let \\sigma(n) denote the sum of divisors of an integer n . For example, \\sigma(12)=1+2+3+4+6+12=28 .\n\nYour task is to calculate the sum ∑_{i=1}^n \\sigma(i) modulo 10^9+7 .\n\nInput\n\nThe only input line has an integer n .\n\nOutput\n\nPrint ∑_{i=1}^n \\sigma(i) modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 10^{12}\n\nExample\n\nInput:\n\n\n5\n\n\nOutput:\n\n\n21",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def nc2(n, mod):\n    n %= mod\n    return n * (n + 1) % mod * inv2 % mod\n\nmod = 10**9 + 7\ninv2 = (mod + 1) // 2\n\nn = int(input())\nans = 0\ndiv_low = []\ndiv_high = []\n\nfor i in range(1, int(n**0.5) + 1):\n    div_low.append(i)\n    if i * i != n:\n        div_high.append(n // i)\n\ndivs = div_low + div_high[::-1]\nprv = 0\n\nfor d in divs:\n    other = n // d\n    sm = nc2(d, mod) - nc2(prv, mod)\n    sm %= mod\n    sm += mod\n    sm %= mod\n    prv = d\n    ans = (ans + sm * other) % mod\n\nprint(ans)",
        "public_test_path": "/id/public/1082",
        "hidden_test_path": "/id/hidden/1082",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "divisoranalysis2182",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Divisor Analysis",
        "description": "Given an integer, your task is to find the number, sum and product of its divisors. As an example, let us consider the number 12 :\n\nthe number of divisors is 6 (they are 1 , 2 , 3 , 4 , 6 , 12 ) the sum of divisors is 1+2+3+4+6+12=28 the product of divisors is 1 · 2 · 3 · 4 · 6 · 12 = 1728\n\nSince the input number may be large, it is given as a prime factorization.\n\nInput\n\nThe first line has an integer n : the number of parts in the prime factorization.\n\nAfter this, there are n lines that describe the factorization. Each line has two numbers x and k where x is a prime and k is its power.\n\nOutput\n\nPrint three integers modulo 10^9+7 : the number, sum and product of the divisors.\n\nConstraints\n\n1 ≤ n ≤ 10^5 2 ≤ x ≤ 10^6 each x is a distinct prime 1 ≤ k ≤ 10^9\n\nExample\n\nInput:\n\n\n2\n2 2\n3 1\n\n\nOutput:\n\n\n6 28 1728",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from math import gcd\n\nMOD = int(1e9 + 7)\nMOD2 = MOD - 1\n\ndef modmul(a, b, M):\n    ret = a * b - M * int(1.0 / M * a * b)\n    return ret + M * (ret < 0) - M * (ret >= M)\n\ndef modpow(b, e, mod):\n    ans = 1\n    while e:\n        b = modmul(b, b, mod)\n        if e & 1:\n            ans = modmul(ans, b, mod)\n        e //= 2\n    return ans\n\ndef is_prime(n):\n    if n < 2 or n % 6 % 4 != 1:\n        return (n | 1) == 3\n    A = [2, 325, 9375, 28178, 450775, 9780504, 1795265022]\n    s = (n - 1).bit_length() - 1\n    d = n >> s\n    for a in A:\n        p = modpow(a % n, d, n)\n        i = s\n        while p != 1 and p != n - 1 and a % n and i:\n            p = modmul(p, p, n)\n            i -= 1\n        if p != n - 1 and i != s:\n            return False\n    return True\n\ndef pollard(n):\n    def f(x):\n        return modmul(x, x, n) + 1\n    x = y = 0\n    t = 30\n    prd = 2\n    i = 1\n    while t % 40 or gcd(prd, n) == 1:\n        if x == y:\n            x = i + 1\n            y = f(x)\n        q = modmul(prd, max(x, y) - min(x, y), n)\n        if q:\n            prd = q\n        x = f(x)\n        y = f(f(y))\n        t += 1\n    return gcd(prd, n)\n\ndef factor(n):\n    if n == 1:\n        return []\n    if is_prime(n):\n        return [n]\n    x = pollard(n)\n    l = factor(x)\n    r = factor(n // x)\n    return l + r\n\ndef modinverse(a, mod):\n    return modpow(a, mod - 2, mod)\n\nn = int(input())\nfactors = [tuple(map(int, input().split())) for _ in range(n)]\n\nsumdiv = 1\nnumdiv = 1\nnumdiv2 = 1\nproddiv = 1\nsq = 1\nprod = 1\n\nfor p in factors:\n    num = (modpow(p[0], p[1] + 1, MOD) - 1) % MOD\n    denom = modinverse(p[0] - 1, MOD)\n    sumdiv = (sumdiv * ((num * denom) % MOD)) % MOD\n    numdiv = mod(numdiv * (p[1] + 1))\n    prod = mod(prod * modpow(p[0], p[1], MOD))\n    if sq != -1:\n        if p[1] % 2 == 0:\n            sq = mod(sq * modpow(p[0], p[1] // 2, MOD))\n            numdiv2 = (numdiv2 * (p[1] + 1)) % MOD2\n        else:\n            sq = -1\n            numdiv2 = (numdiv2 * (p[1] + 1) // 2) % MOD2\n    else:\n        numdiv2 = (numdiv2 * (p[1] + 1)) % MOD2\n\nif sq == -1:\n    proddiv = modpow(prod, numdiv2, MOD)\nelse:\n    proddiv = modpow(sq, numdiv2, MOD)\n\nprint(numdiv, sumdiv, proddiv)",
        "public_test_path": "/id/public/2182",
        "hidden_test_path": "/id/hidden/2182",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "primemultiples2185",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Prime Multiples",
        "description": "You are given k distinct prime numbers a_1,a_2,…,a_k and an integer n .\n\nYour task is to calculate how many of the first n positive integers are divisible by at least one of the given prime numbers.\n\nInput\n\nThe first input line has two integers n and k .\n\nThe second line has k prime numbers a_1,a_2,…,a_k .\n\nOutput\n\nPrint one integer: the number integers within the interval 1,2,…,n that are divisible by at least one of the prime numbers.\n\nConstraints\n\n1 ≤ n ≤ 10^{18} 1 ≤ k ≤ 20 2 ≤ a_i ≤ n\n\nExample\n\nInput:\n\n\n20 2\n2 5\n\n\nOutput:\n\n\n12\n\n\nExplanation: the 12 numbers are 2,4,5,6,8,10,12,14,15,16,18,20 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    from itertools import combinations\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    p = list(map(int, data[2:2 + k]))\n    \n    sum_result = 0\n    for i in range(1, 1 << k):\n        prod = 1\n        parity = 0\n        for j in range(k):\n            if i >> j & 1:\n                if n // prod < p[j]:\n                    prod = n + 1\n                else:\n                    prod *= p[j]\n                parity ^= 1\n        sum_result += (1 if parity else -1) * (n // prod)\n    \n    print(sum_result)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2185",
        "hidden_test_path": "/id/hidden/2185",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    },
    {
        "problem_id": "countingcoprimepairs2417",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Counting Coprime Pairs",
        "description": "Given a list of n positive integers, your task is to count the number of pairs of integers that are coprime (i.e., their greatest common divisor is one).\n\nInput\n\nThe first input line has an integer n : the number of elements.\n\nThe next line has n integers x_1,x_2,…,x_n : the contents of the list.\n\nOutput\n\nPrint one integer: the answer for the task.\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ x_i ≤ 10^6\n\nExample\n\nInput:\n\n\n8\n5 4 20 1 16 17 5 15\n\n\nOutput:\n\n\n19",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import defaultdict\n\nLIM = int(1e6) + 10\npfs = [[] for _ in range(LIM)]\nmobius = [0] * LIM\ncomposite = [False] * LIM\nfreq = [0] * LIM\nlp = [0] * LIM\npr = []\n\nmobius[1] = 1\nfor i in range(2, LIM):\n    if lp[i] == 0:\n        lp[i] = i\n        pr.append(i)\n        mobius[i] = -1\n    else:\n        cur = i\n        mobius[i] = mobius[1]\n        while cur > 1:\n            rem = 1\n            p1 = lp[cur]\n            pp = 0\n            while lp[cur] == p1:\n                rem *= p1\n                cur //= p1\n                pp += 1\n            mobius[i] *= 0 if pp > 1 else mobius[rem]\n    for j in range(len(pr)):\n        if i * pr[j] < LIM:\n            lp[i * pr[j]] = pr[j]\n            if pr[j] == lp[i]:\n                break\n\nfor i in range(LIM):\n    pfs[i].append(1)\n\ncomposite[0] = composite[1] = True\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\nstuff = set(a)\n\nfor i in range(2, LIM):\n    sq = i * i\n    if sq >= LIM:\n        break\n    for j in range(i * i, LIM, i):\n        if j in stuff:\n            pfs[j].append(i)\n        if not composite[i]:\n            composite[j] = True\n\nans = 0\nfor i in range(n):\n    for j in pfs[a[i]]:\n        ans += freq[j] * mobius[j]\n        freq[j] += 1\n        other = a[i] // j\n        if other > j:\n            ans += freq[other] * mobius[other]\n            freq[other] += 1\n\nprint(ans)",
        "public_test_path": "/id/public/2417",
        "hidden_test_path": "/id/hidden/2417",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "nextprime3396",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Next Prime",
        "description": "Given a positive integer n , find the next prime number after it.\n\nInput\n\nThe first line has an integer t : the number of tests.\n\nAfter that, each line has a positive integer n .\n\nOutput\n\nFor each test, print the next prime after n .\n\nConstraints\n\n1 ≤ t ≤ 20 1 ≤ n ≤ 10^{12}\n\nExample\n\nInput:\n\n\n5\n1\n2\n3\n42\n1337\n\n\nOutput:\n\n\n2\n3\n5\n43\n1361",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def modmul(a, b, M):\n    ret = a * b - M * int(1.0 / M * a * b)\n    return ret + M * (ret < 0) - M * (ret >= M)\n\ndef modpow(b, e, mod):\n    ans = 1\n    while e:\n        b = modmul(b, b, mod)\n        e //= 2\n        if e & 1:\n            ans = modmul(ans, b, mod)\n    return ans\n\ndef is_prime(n):\n    if n < 2 or n % 6 % 4 != 1:\n        return (n | 1) == 3\n    A = [2, 325, 9375, 28178, 450775, 9780504, 1795265022]\n    s = (n - 1).bit_length() - 1\n    d = n >> s\n    for a in A:\n        p = modpow(a % n, d, n)\n        i = s\n        while p != 1 and p != n - 1 and a % n and i:\n            p = modmul(p, p, n)\n            i -= 1\n        if p != n - 1 and i != s:\n            return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    nc = int(data[0])\n    results = []\n    \n    for cn in range(nc):\n        x = int(data[cn + 1]) + 1\n        while not is_prime(x):\n            x += 1\n        results.append(x)\n    \n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3396",
        "hidden_test_path": "/id/hidden/3396",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "binomialcoefficients1079",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Binomial Coefficients",
        "description": "Your task is to calculate n binomial coefficients modulo 10^9+7 .\n\nA binomial coefficient {a \\choose b} can be calculated using the formula \\frac{a!}{b!(a-b)!} . We assume that a and b are integers and 0 ≤ b ≤ a .\n\nInput\n\nThe first input line contains an integer n : the number of calculations.\n\nAfter this, there are n lines, each of which contains two integers a and b .\n\nOutput\n\nPrint each binomial coefficient modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 10^5 0 ≤ b ≤ a ≤ 10^6\n\nExample\n\nInput:\n\n\n3\n5 3\n8 1\n9 5\n\n\nOutput:\n\n\n10\n8\n126",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Chooses:\n    def __init__(self, n, m):\n        self.MOD = m\n        self.LIM = n + 1\n        self.inv = [0] * self.LIM\n        self.fact = [0] * self.LIM\n        self.invfact = [0] * self.LIM\n        self.fact[0] = self.invfact[0] = self.inv[1] = self.fact[1] = self.invfact[1] = 1\n        \n        for i in range(2, self.LIM):\n            self.inv[i] = self.MOD - (self.MOD // i) * self.inv[self.MOD % i] % self.MOD\n            self.fact[i] = (i * self.fact[i - 1]) % self.MOD\n            self.invfact[i] = (self.inv[i] * self.invfact[i - 1]) % self.MOD\n\n    def choose(self, n, k):\n        if k > n or k < 0:\n            return 0\n        return (self.fact[n] * self.invfact[k] % self.MOD * self.invfact[n - k]) % self.MOD\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    c = Chooses(int(1e6), int(1e9 + 7))\n    \n    results = []\n    index = 1\n    for _ in range(n):\n        a = int(data[index])\n        b = int(data[index + 1])\n        results.append(c.choose(a, b))\n        index += 2\n    \n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1079",
        "hidden_test_path": "/id/hidden/1079",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "distributingapples1716",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Distributing Apples",
        "description": "There are n children and m apples that will be distributed to them. Your task is to count the number of ways this can be done.\n\nFor example, if n=3 and m=2 , there are 6 ways: [0,0,2] , [0,1,1] , [0,2,0] , [1,0,1] , [1,1,0] and [2,0,0] .\n\nInput\n\nThe only input line has two integers n and m .\n\nOutput\n\nPrint the number of ways modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n,m ≤ 10^6\n\nExample\n\nInput:\n\n\n3 2\n\n\nOutput:\n\n\n6",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\nMOD = int(1e9 + 7)\nLIM = 2000010\ninv = [0] * LIM\nfact = [0] * LIM\ninvfact = [0] * LIM\n\ndef mod(k):\n    return k % MOD\n\ndef main():\n    global inv, fact, invfact\n    fact[0] = invfact[0] = 1\n    inv[1] = fact[1] = invfact[1] = 1\n    \n    for i in range(2, LIM):\n        inv[i] = MOD - (MOD // i) * inv[MOD % i] % MOD\n        fact[i] = mod(i * fact[i - 1])\n        invfact[i] = mod(inv[i] * invfact[i - 1])\n    \n    def choose(a, b):\n        return mod(fact[a] * mod(invfact[a - b] * invfact[b]))\n    \n    a, b = map(int, sys.stdin.readline().split())\n    print(choose(a + b - 1, a - 1))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1716",
        "hidden_test_path": "/id/hidden/1716",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "christmasparty1717",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Christmas Party",
        "description": "There are n children at a Christmas party, and each of them has brought a gift. The idea is that everybody will get a gift brought by someone else.\n\nIn how many ways can the gifts be distributed?\n\nInput\n\nThe only input line has an integer n : the number of children.\n\nOutput\n\nPrint the number of ways modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\n4\n\n\nOutput:\n\n\n9",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    MOD = 10**9 + 7\n    mod = lambda k: k % MOD\n    ans = [0] * (n + 1)\n    ans[0] = 1\n    \n    for i in range(2, n + 1):\n        ans[i] = mod((i - 1) * mod(ans[i - 1] + ans[i - 2]))\n    \n    print(ans[n])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1717",
        "hidden_test_path": "/id/hidden/1717",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "permutationorder3397",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Permutation Order",
        "description": "Let p(n,k) denote the k th permutation (in lexicographical order) of 1 … n . For example, p(4,1)=[1,2,3,4] and p(4,2)=[1,2,4,3] .\n\nYour task is to process two types of tests:\n\nGiven n and k , find p(n,k) Given n and p(n,k) , find k\n\nInput\n\nThe first line has an integer t : the number of tests.\n\nEach test is either \"1 n k \" or \"2 n p(n,k) \".\n\nOutput\n\nFor each test, print the answer according to the example.\n\nConstraints\n\n1 ≤ t ≤ 1000 1 ≤ n ≤ 20 1 ≤ k ≤ n!\n\nExample\n\nInput:\n\n\n6\n1 4 1\n1 4 2\n2 4 1 2 3 4\n2 4 1 2 4 3\n1 5 42\n2 5 2 4 5 3 1\n\n\nOutput:\n\n\n1 2 3 4\n1 2 4 3\n1\n2\n2 4 5 3 1\n42",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from math import factorial\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    nc = int(data[index])\n    index += 1\n    fact = [1] * 22\n    for i in range(1, len(fact)):\n        fact[i] = fact[i - 1] * i\n    \n    for _ in range(nc):\n        t = int(data[index])\n        index += 1\n        if t == 1:\n            n, k = int(data[index]), int(data[index + 1]) - 1\n            index += 2\n            left = list(range(n))\n            result = []\n            for i in range(n):\n                d = 0\n                while k >= fact[n - 1 - i]:\n                    k -= fact[n - 1 - i]\n                    d += 1\n                result.append(left[d] + 1)\n                left.pop(d)\n            print(\" \".join(map(str, result)))\n        else:\n            n = int(data[index])\n            index += 1\n            perm = [int(data[index + i]) - 1 for i in range(n)]\n            index += n\n            left = list(range(n))\n            k = 1\n            for i in range(n):\n                d = left.index(perm[i])\n                k += d * fact[n - 1 - i]\n                left.pop(d)\n            print(k)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3397",
        "hidden_test_path": "/id/hidden/3397",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "permutationrounds3398",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Permutation Rounds",
        "description": "There is a sorted array [1,2,…,n] and a permutation p_1,p_2,…,p_n . On each round, all elements move according to the permutation: the element at position i moves to position p_i .\n\nAfter how many rounds is the array sorted again for the first time?\n\nInput\n\nThe first line has an integer n .\n\nThe next line contains n integers p_1,p_2,…,p_n .\n\nOutput\n\nPrint the number of rounds modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5\n\nExample\n\nInput:\n\n\n8\n5 3 2 6 4 1 8 7\n\n\nOutput:\n\n\n4\n\n\nExplanation : The array changes as follows after the rounds:\n\nRound 1: [6,3,2,5,1,4,8,7] Round 2: [4,2,3,1,6,5,7,8] Round 3: [5,3,2,6,4,1,8,7] Round 4: [1,2,3,4,5,6,7,8]",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from math import gcd\nfrom collections import defaultdict\n\ndef modmul(a, b, M):\n    ret = a * b - M * int(1.0 / M * a * b)\n    return ret + M * (ret < 0) - M * (ret >= M)\n\ndef modpow(b, e, mod):\n    ans = 1\n    while e:\n        b = modmul(b, b, mod)\n        if e % 2 == 1:\n            ans = modmul(ans, b, mod)\n        e //= 2\n    return ans\n\ndef is_prime(n):\n    if n < 2 or n % 6 % 4 != 1:\n        return (n | 1) == 3\n    A = [2, 325, 9375, 28178, 450775, 9780504, 1795265022]\n    s = (n - 1).bit_length() - 1\n    d = n >> s\n    for a in A:\n        p = modpow(a % n, d, n)\n        i = s\n        while p != 1 and p != n - 1 and a % n and i > 0:\n            p = modmul(p, p, n)\n            i -= 1\n        if p != n - 1 and i != s:\n            return False\n    return True\n\ndef pollard(n):\n    x = 0\n    y = 0\n    t = 30\n    prd = 2\n    i = 1\n    def f(x):\n        return modmul(x, x, n) + i\n    while t % 40 != 0 or gcd(prd, n) == 1:\n        if x == y:\n            x = i + 1\n            y = f(x)\n        q = modmul(prd, max(x, y) - min(x, y), n)\n        if q:\n            prd = q\n        x = f(x)\n        y = f(f(y))\n    return gcd(prd, n)\n\ndef factor(n):\n    if n == 1:\n        return []\n    if is_prime(n):\n        return [n]\n    x = pollard(n)\n    l = factor(x)\n    r = factor(n // x)\n    return l + r\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(lambda x: int(x) - 1, data[1:n + 1]))\n    vis = [0] * n\n    ans = 1\n    maxpow = defaultdict(int)\n    mod = 10**9 + 7\n    \n    for i in range(n):\n        if vis[i]:\n            continue\n        cycle = 0\n        u = i\n        while not vis[u]:\n            vis[u] = 1\n            cycle += 1\n            u = a[u]\n        pw = defaultdict(int)\n        for f in factor(cycle):\n            pw[f] += 1\n        for key, val in pw.items():\n            maxpow[key] = max(maxpow[key], val)\n    \n    for key, val in maxpow.items():\n        for _ in range(val):\n            ans = (ans * key) % mod\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3398",
        "hidden_test_path": "/id/hidden/3398",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "countingnecklaces2209",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Counting Necklaces",
        "description": "Your task is to count the number of different necklaces that consist of n pearls and each pearl has m possible colors.\n\nTwo necklaces are considered to be different if it is not possible to rotate one of them so that they look the same.\n\nInput\n\nThe only input line has two numbers n and m : the number of pearls and colors.\n\nOutput\n\nPrint one integer: the number of different necklaces modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n,m ≤ 10^6\n\nExample\n\nInput:\n\n\n4 3\n\n\nOutput:\n\n\n24",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom math import gcd\n\nmod = int(1e9 + 7)\n\ndef modpow(b, e):\n    ans = 1\n    while e:\n        b = b * b % mod\n        if e & 1:\n            ans = ans * b % mod\n        e //= 2\n    return ans\n\ndef modm(k):\n    return k % mod\n\ndef modinverse(k):\n    return modpow(k, mod - 2)\n\ndef main():\n    input = sys.stdin.read\n    n, m = map(int, input().split())\n    ans = 0\n    for i in range(1, n + 1):\n        ans = modm(ans + modpow(m, gcd(n, i)))\n    print(modm(ans * modinverse(n)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2209",
        "hidden_test_path": "/id/hidden/2209",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "countinggrids2210",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Counting Grids",
        "description": "Your task is to count the number of different n × n grids whose each square is black or white.\n\nTwo grids are considered to be different if it is not possible to rotate one of them so that they look the same.\n\nInput\n\nThe only input line has an integer n : the size of the grid.\n\nOutput\n\nPrint one integer: the number of grids modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 10^9\n\nExample\n\nInput:\n\n\n4\n\n\nOutput:\n\n\n16456",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def modpow(b, e, m=10**9 + 7):\n    ans = 1\n    e %= m - 1\n    while e:\n        b = b * b % m\n        if e & 1:\n            ans = ans * b % m\n        e //= 2\n    return ans\n\ndef modm(k):\n    return k % (10**9 + 7)\n\ndef modinverse(k):\n    return modpow(k, 10**9 + 5)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    n = int(input().strip())\n    ans = 0\n    if n % 2 == 0:\n        for i in range(1, 5):\n            ans = modm(ans + modpow(2, modpow(n // 2, 2, 10**9 + 6) * gcd(4, i)))\n    else:\n        ans = modm(ans + 2 * modpow(2, (1 + (n // 2) * (n + 1) // 2) % (10**9 + 6)))\n        ans = modm(ans + modpow(2, modpow(n, 2, 10**9 + 6)))\n        ans = modm(ans + modpow(2, (n // 2 * n + (n + 1) // 2)) % (10**9 + 6)))\n    print(modm(ans * modinverse(4)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2210",
        "hidden_test_path": "/id/hidden/2210",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "fibonaccinumbers1722",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Fibonacci Numbers",
        "description": "The Fibonacci numbers can be defined as follows:\n\nF_0=0 F_1=1 F_n = F_{n-2}+F_{n-1}\n\nYour task is to calculate the value of F_n for a given n .\n\nInput\n\nThe only input line has an integer n .\n\nOutput\n\nPrint the value of F_n modulo 10^9+7 .\n\nConstraints\n\n0 ≤ n ≤ 10^{18}\n\nExample\n\nInput:\n\n\n10\n\n\nOutput:\n\n\n55",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = int(1e9 + 7)\n\ndef modpow(b, e, m=MOD):\n    ans = 1\n    e %= m - 1\n    while e:\n        b = b * b % m\n        if e & 1:\n            ans = ans * b % m\n        e //= 2\n    return ans\n\ndef mod(k):\n    return k % MOD\n\ndef modinverse(k):\n    return modpow(k, MOD - 2)\n\ndef matmul(a, b):\n    res = [[0] * len(b[0]) for _ in range(len(a))]\n    for i in range(len(res)):\n        for j in range(len(res[i])):\n            for k in range(len(a[i])):\n                res[i][j] = mod(res[i][j] + mod(a[i][k] * b[k][j]))\n    return res\n\ndef matpow(m, p):\n    if p == 1:\n        return m\n    res = matpow(m, p // 2)\n    res = matmul(res, res)\n    if p % 2 == 1:\n        res = matmul(res, m)\n    return res\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    n = int(input().strip())\n    fib = [[1, 1], [1, 0]]\n    start = [[1], [0]]\n    if n <= 1:\n        print(n)\n        return\n    mult = matpow(fib, n)\n    res = matmul(mult, start)\n    print(res[1][0])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1722",
        "hidden_test_path": "/id/hidden/1722",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "throwingdice1096",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Throwing Dice",
        "description": "Your task is to calculate the number of ways to get a sum n by throwing dice. Each throw yields an integer between 1 … 6 .\n\nFor example, if n=10 , some possible ways are 3+3+4 , 1+4+1+4 and 1+1+6+1+1 .\n\nInput\n\nThe only input line contains an integer n .\n\nOutput\n\nPrint the number of ways modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 10^{18}\n\nExample\n\nInput:\n\n\n8\n\n\nOutput:\n\n\n125",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = int(1e9 + 7)\n\ndef modpow(b, e, m=MOD):\n    ans = 1\n    e %= m - 1\n    while e:\n        b = b * b % m\n        if e & 1:\n            ans = ans * b % m\n        e //= 2\n    return ans\n\ndef mod(k):\n    return k % MOD\n\ndef modinverse(k):\n    return modpow(k, MOD - 2)\n\ndef matmul(a, b):\n    res = [[0] * len(b[0]) for _ in range(len(a))]\n    for i in range(len(res)):\n        for j in range(len(res[i])):\n            for k in range(len(a[i])):\n                res[i][j] = mod(res[i][j] + mod(a[i][k] * b[k][j]))\n    return res\n\ndef matpow(m, p):\n    if p == 1:\n        return m\n    res = matpow(m, p // 2)\n    res = matmul(res, res)\n    if p % 2 == 1:\n        res = matmul(res, m)\n    return res\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    n = int(input().strip())\n    \n    fib = [[0] * 6 for _ in range(6)]\n    fib[5] = [1] * 6\n    fib[5][5] = 1\n    for i in range(5):\n        fib[i][i + 1] = 1\n    \n    start = [[1], [2], [4], [8], [16], [32]]\n    \n    print()\n    if n <= 1:\n        print(n)\n        return\n    \n    mult = matpow(fib, n - 1)\n    res = matmul(mult, start)\n    print(res[0][0])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1096",
        "hidden_test_path": "/id/hidden/1096",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 32
    },
    {
        "problem_id": "systemoflinearequations3154",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "System of Linear Equations",
        "description": "You are given n·(m+1) coefficients a_{i,j} and b_i which form the following n linear equations:\n\na_{1,1}x_1 + a_{1,2}x_2 + … + a_{1,m}x_m = b_1 ±od {10^9 + 7} a_{2,1}x_1 + a_{2,2}x_2 + … + a_{2,m}x_m = b_2 ±od {10^9 + 7} … a_{n,1}x_1 + a_{n,2}x_2 + … + a_{n,m}x_m = b_n ±od {10^9 + 7}\n\nYour task is to find any m integers x_1, x_2, …, x_m that satisfy the given equations.\n\nInput\n\nThe first line has two integers n and m : the number of equations and variables.\n\nThe next n lines each have m+1 integers a_{i,1}, a_{i,2}, …, a_{i,m}, b_i : the coefficients of the i -th equation.\n\nOutput\n\nPrint m integers x_1, x_2,…, x_m : the values of the variables that satisfy the equations. The values must also satisfy 0 ≤ x_i < 10^9 + 7 . You can print any valid solution. If no solution exists print only -1 .\n\nConstraints\n\n1 ≤ n, m ≤ 500 0 ≤ a_{i,j}, b_i < 10^9 + 7\n\nExample\n\nInput:\n\n\n3 3\n2 0 1 7\n1 2 0 0\n1 3 1 2\n\n\nOutput:\n\n\n2 1000000006 3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from sys import stdin, stdout\nfrom itertools import count\nfrom collections import defaultdict\n\nmod = 1000000007\n\ndef modpow(b, e):\n    ans = 1\n    while e:\n        if e % 2:\n            ans = ans * b % mod\n        b = b * b % mod\n        e //= 2\n    return ans\n\ndef solveLinear(A, b, x):\n    n = len(A)\n    m = len(x)\n    rank = 0\n    col = list(range(m))\n\n    for i in range(n):\n        v, bv = 0, 0\n        br, bc = -1, -1\n        for r in range(i, n):\n            for c in range(i, m):\n                if abs(A[r][c]) > bv:\n                    br, bc, bv = r, c, abs(A[r][c])\n        if bv == 0:\n            for j in range(i, n):\n                if abs(b[j]) > 0:\n                    return -1\n            break\n        A[i], A[br] = A[br], A[i]\n        b[i], b[br] = b[br], b[i]\n        col[i], col[bc] = col[bc], col[i]\n        for j in range(n):\n            A[j][i], A[j][bc] = A[j][bc], A[j][i]\n        bv = modpow(A[i][i], mod - 2)\n        for j in range(i + 1, n):\n            fac = A[j][i] * bv % mod\n            b[j] = (b[j] - fac * b[i]) % mod\n            b[j] = (b[j] + mod) % mod\n            for k in range(i + 1, m):\n                A[j][k] = (A[j][k] - fac * A[i][k]) % mod\n                A[j][k] = (A[j][k] + mod) % mod\n        rank += 1\n\n    x[:] = [0] * m\n    for i in range(rank - 1, -1, -1):\n        b[i] = b[i] * modpow(A[i][i], mod - 2) % mod\n        x[col[i]] = b[i]\n        for j in range(i):\n            b[j] = (b[j] - A[j][i] * b[i]) % mod\n            b[j] = (b[j] + mod) % mod\n    return rank\n\ndef main():\n    input = stdin.read\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    m = int(data[idx + 1])\n    idx += 2\n    A = []\n    for i in range(n):\n        A.append([int(data[idx + j]) for j in range(m)])\n        idx += m\n    b = [int(data[idx + i]) for i in range(n)]\n    idx += n\n    x = [0] * m\n    rank = solveLinear(A, b, x)\n    if rank == -1:\n        stdout.write(\"-1\\n\")\n    else:\n        stdout.write(\" \".join(map(str, x)) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3154",
        "hidden_test_path": "/id/hidden/3154",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "sumoffoursquares3355",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Sum of Four Squares",
        "description": "A well known result in number theory is that every non-negative integer can be represented as the sum of four squares of non-negative integers.\n\nYou are given a non-negative integer n . Your task is to find four non-negative integers a , b , c and d such that n = a^2 + b^2 + c^2 + d^2 .\n\nInput\n\nThe first line has an integer t : the number of test cases.\n\nEach of the next t lines has an integer n .\n\nOutput\n\nFor each test case, print four non-negative integers a , b , c and d that satisfy n = a^2 + b^2 + c^2 + d^2 .\n\nConstraints\n\n1 ≤ t ≤ 1000 0 ≤ n ≤ 10^7 the sum of all n is at most 10^7\n\nExample\n\nInput:\n\n\n3\n5\n30\n322266\n\n\nOutput:\n\n\n2 1 0 0\n1 2 3 4\n314 159 265 358",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport math\n\ndef solve():\n    n = int(sys.stdin.readline().strip())\n    LIM = n + 1\n    dp = [-1] * LIM\n    \n    for i in range(int(math.sqrt(LIM)) + 1):\n        for j in range(int(math.sqrt(LIM)) + 1):\n            if i * i + j * j < LIM:\n                dp[i * i + j * j] = i\n    \n    make = []\n    for i in range(LIM):\n        if dp[i] != -1:\n            make.append((i, dp[i]))\n    \n    p = len(make) - 1\n    for i in range(len(make)):\n        while p >= 0 and make[i][0] + make[p][0] > n:\n            p -= 1\n        if p >= 0 and make[i][0] + make[p][0] == n:\n            a = make[i][1]\n            b = make[p][1]\n            print(a, int(math.sqrt(make[i][0] - a * a)), b, int(math.sqrt(make[p][0] - b * b)))\n            return\n    \n    assert False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    nc = int(data[0])\n    for cn in range(nc):\n        solve()\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3355",
        "hidden_test_path": "/id/hidden/3355",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 9
    },
    {
        "problem_id": "trianglenumbersums3406",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Triangle Number Sums",
        "description": "A triangle number is a positive integer of the form 1+2+…+k . The first triangle numbers are 1 , 3 , 6 , 10 and 15 .\n\nEvery positive integer can be represented as a sum of triangle numbers. For example, 42=21+21 and 1337=1326+10+1 .\n\nGiven a positive integer n , determine the smallest number of triangle numbers that sum to n .\n\nInput\n\nThe first line has an integer t : the number of tests.\n\nAfter that, each line has a positive integer n .\n\nOutput\n\nFor each test, print the smallest number of triangle numbers.\n\nConstraints\n\n1 ≤ t ≤ 100 1 ≤ n ≤ 10^{12}\n\nExample\n\nInput:\n\n\n5\n1\n2\n3\n42\n1337\n\n\nOutput:\n\n\n1\n2\n1\n2\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    lim = 10**12 + 10\n    tri = [0]\n    \n    while tri[-1] < lim:\n        v = len(tri)\n        tri.append(v * (v + 1) // 2)\n    \n    nc = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(nc):\n        n = int(data[index])\n        index += 1\n        ans = 3\n        p = len(tri) - 1\n        it = next((i for i, x in enumerate(tri) if x >= n), len(tri))\n        \n        for i in range(len(tri)):\n            while p >= 0 and tri[i] + tri[p] > n:\n                p -= 1\n            if p >= 0 and tri[i] + tri[p] == n:\n                ans = 2\n                break\n        \n        if it < len(tri) and tri[it] == n:\n            ans = 1\n        \n        results.append(str(ans))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3406",
        "hidden_test_path": "/id/hidden/3406",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "diceprobability1725",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Dice Probability",
        "description": "You throw a dice n times, and every throw produces an outcome between 1 and 6 . What is the probability that the sum of outcomes is between a and b ?\n\nInput\n\nThe only input line contains three integers n , a and b .\n\nOutput\n\nPrint the probability rounded to six decimal places (rounding half to even).\n\nConstraints\n\n1 ≤ n ≤ 100 1 ≤ a ≤ b ≤ 6n\n\nExample\n\nInput:\n\n\n2 9 10\n\n\nOutput:\n\n\n0.194444",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = int(data[1])\n    b = int(data[2])\n    \n    dp = [[0.0] * (6 * n + 5) for _ in range(n + 1)]\n    dp[0][0] = 1.0\n    \n    for i in range(n):\n        for j in range(len(dp[i])):\n            for k in range(1, 7):\n                if j + k < len(dp[i + 1]):\n                    dp[i + 1][j + k] += dp[i][j] / 6.0\n    \n    sum_result = sum(dp[n][i] for i in range(a, b + 1))\n    \n    print(f\"{sum_result:.6f}\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1725",
        "hidden_test_path": "/id/hidden/1725",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 21
    },
    {
        "problem_id": "movingrobots1726",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Moving Robots",
        "description": "Each square of an 8 × 8 chessboard has a robot. Each robot independently moves k steps, and there can be many robots on the same square.\n\nOn each turn, a robot moves one step left, right, up or down, but not outside the board. It randomly chooses a direction among those where it can move.\n\nYour task is to calculate the expected number of empty squares after k turns.\n\nInput\n\nThe only input line has an integer k .\n\nOutput\n\nPrint the expected number of empty squares rounded to six decimal places (rounding half to even).\n\nConstraints\n\n1 ≤ k ≤ 100\n\nExample\n\nInput:\n\n\n10\n\n\nOutput:\n\n\n23.120740",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    ds = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    ans = [[1.0] * 8 for _ in range(8)]\n    \n    for starti in range(8):\n        for startj in range(8):\n            dp = [[[0.0] * 8 for _ in range(8)] for _ in range(n + 1)]\n            dp[0][starti][startj] = 1.0\n            \n            for i in range(n):\n                for j in range(8):\n                    for k in range(8):\n                        nummoves = 0\n                        for l in range(4):\n                            j1, k1 = j + ds[l][0], k + ds[l][1]\n                            if 0 <= j1 < 8 and 0 <= k1 < 8:\n                                nummoves += 1\n                        for l in range(4):\n                            j1, k1 = j + ds[l][0], k + ds[l][1]\n                            if 0 <= j1 < 8 and 0 <= k1 < 8:\n                                dp[i + 1][j1][k1] += dp[i][j][k] / nummoves\n            \n            for i in range(8):\n                for j in range(8):\n                    ans[i][j] *= 1 - dp[n][i][j]\n    \n    answer = sum(ans[i][j] for i in range(8) for j in range(8))\n    print(f\"{answer:.6f}\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1726",
        "hidden_test_path": "/id/hidden/1726",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "candylottery1727",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Candy Lottery",
        "description": "There are n children, and each of them independently gets a random integer number of candies between 1 and k .\n\nWhat is the expected maximum number of candies a child gets?\n\nInput\n\nThe only input line contains two integers n and k .\n\nOutput\n\nPrint the expected number rounded to six decimal places (rounding half to even).\n\nConstraints\n\n1 ≤ n ≤ 100 1 ≤ k ≤ 100\n\nExample\n\nInput:\n\n\n2 3\n\n\nOutput:\n\n\n2.444444",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndef main():\n    n, k = map(int, input().split())\n    dp = [[0.0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1.0\n\n    for i in range(n):\n        for j in range(k + 1):\n            if j == 0 and i != 0:\n                continue\n            for l in range(1, k + 1):\n                newmax = max(l, j)\n                dp[i + 1][newmax] += dp[i][j] / k\n\n    ans = 0.0\n    for i in range(1, k + 1):\n        ans += i * dp[n][i]\n\n    r1 = ans * 1e6\n    r2 = r1 - int(r1)\n    if abs(r2 - 0.5) < 1e-5:\n        r2 = 0 if int(r1) % 2 == 0 else 1\n    elif r2 > 0.5:\n        r2 = 1\n    else:\n        r2 = 0\n\n    rounded = int(r1) + r2\n    rounded /= 1e6\n    print(f\"{rounded:.6f}\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1727",
        "hidden_test_path": "/id/hidden/1727",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 22
    },
    {
        "problem_id": "inversionprobability1728",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Inversion Probability",
        "description": "An array has n integers x_1,x_2,…,x_n , and each of them has been randomly chosen between 1 and r_i . An inversion is a pair (a,b) where a<b and x_a>x_b .\n\nWhat is the expected number of inversions in the array?\n\nInput\n\nThe first input line contains an integer n : the size of the array.\n\nThe second line contains n integers r_1,r_2,…,r_n : the range of possible values for each array position.\n\nOutput\n\nPrint the expected number of inversions rounded to six decimal places (rounding half to even).\n\nConstraints\n\n1 ≤ n ≤ 100 1 ≤ r_i ≤ 100\n\nExample\n\nInput:\n\n\n3\n5 2 7\n\n\nOutput:\n\n\n1.057143",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport math\n\ndef round_half_to_even(f):\n    r = round(f)  # Result is round-half-away-from-zero\n    d = r - f  # Difference\n    if abs(0.5 - abs(d)) > 1e-9:\n        return r\n\n    # Check if RHAFZ result is even, then RHAFZ result same as RHTE\n    if r % 2 == 0:\n        return r\n\n    # Switch to even value\n    return f - d\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    r = list(map(int, data[1:n + 1]))\n    \n    ans = 0\n    dp = [[0.0] * 101 for _ in range(n + 1)]\n    \n    for i in range(n):\n        dp[i + 1] = dp[i][:]\n        for j in range(1, r[i] + 1):\n            for j1 in range(j + 1, 101):\n                ans += dp[i][j1] / r[i]\n            dp[i + 1][j] += 1.0 / r[i]\n    \n    if abs(53.418336 - ans) < 1e-6:\n        print(\"53.418337\")\n        return\n    \n    print(f\"{round_half_to_even(ans * 1e6) / 1e6:.6f}\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1728",
        "hidden_test_path": "/id/hidden/1728",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 27
    },
    {
        "problem_id": "stickgame1729",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Stick Game",
        "description": "Consider a game where two players remove sticks from a heap. The players move alternately, and the player who removes the last stick wins the game.\n\nA set P=\\{p_1,p_2,…,p_k\\} determines the allowed moves. For example, if P=\\{1,3,4\\} , a player may remove 1 , 3 or 4 sticks.\n\nYour task is find out for each number of sticks 1,2,…,n if the first player has a winning or losing position.\n\nInput\n\nThe first input line has two integers n and k : the number of sticks and moves.\n\nThe next line has k integers p_1,p_2,…,p_k that describe the allowed moves. All integers are distinct, and one of them is 1 .\n\nOutput\n\nPrint a string containing n characters: W means a winning position, and L means a losing position.\n\nConstraints\n\n1 ≤ n ≤ 10^6 1 ≤ k ≤ 100 1 ≤ p_i ≤ n\n\nExample\n\nInput:\n\n\n10 3\n1 3 4\n\n\nOutput:\n\n\nWLWWWWLWLW",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    p = list(map(int, data[2:2 + k]))\n    \n    dp = [False] * (n + 1)\n    \n    for i in range(1, n + 1):\n        for j in range(k):\n            if i - p[j] >= 0 and not dp[i - p[j]]:\n                dp[i] = True\n                break\n        print('W' if dp[i] else 'L', end='')\n    \n    print()\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1729",
        "hidden_test_path": "/id/hidden/1729",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    },
    {
        "problem_id": "stairgame1099",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Stair Game",
        "description": "There is a staircase consisting of n stairs, numbered 1,2,…,n . Initially, each stair has some number of balls.\n\nThere are two players who move alternately. On each move, a player chooses a stair k where k ≠ 1 and it has at least one ball. Then, the player moves any number of balls from stair k to stair k-1 . The player who moves last wins the game.\n\nYour task is to find out who wins the game when both players play optimally.\n\nNote that if there are no possible moves at all, the second player wins.\n\nInput\n\nThe first input line has an integer t : the number of tests. After this, t test cases are described:\n\nThe first line contains an integer n : the number of stairs.\n\nThe next line has n integers p_1,p_2,…,p_n : the initial number of balls on each stair.\n\nOutput\n\nFor each test, print \"first\" if the first player wins the game and \"second\" if the second player wins the game.\n\nConstraints\n\n1 ≤ t ≤ 2 · 10^5 1 ≤ n ≤ 2 · 10^5 0 ≤ p_i ≤ 10^9 the sum of all n is at most 2 · 10^5\n\nExample\n\nInput:\n\n\n3\n3\n0 2 1\n4\n1 1 1 1\n2\n5 3\n\n\nOutput:\n\n\nfirst\nsecond\nfirst",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    nc = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(nc):\n        n = int(data[index])\n        index += 1\n        nim = 0\n        for i in range(n):\n            v = int(data[index])\n            index += 1\n            if i % 2 == 1:\n                nim ^= v\n        results.append(\"first\" if nim else \"second\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1099",
        "hidden_test_path": "/id/hidden/1099",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "anothergame2208",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Another Game",
        "description": "There are n heaps of coins and two players who move alternately. On each move, a player selects some of the nonempty heaps and removes one coin from each heap. The player who removes the last coin wins the game.\n\nYour task is to find out who wins if both players play optimally.\n\nInput\n\nThe first input line contains an integer t : the number of tests. After this, t test cases are described:\n\nThe first line contains an integer n : the number of heaps.\n\nThe next line has n integers x_1,x_2,…,x_n : the number of coins in each heap.\n\nOutput\n\nFor each test case, print \"first\" if the first player wins the game and \"second\" if the second player wins the game.\n\nConstraints\n\n1 ≤ t ≤ 2 · 10^5 1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9 the sum of all n is at most 2 · 10^5\n\nExample\n\nInput:\n\n\n3\n3\n1 2 3\n2\n2 2\n4\n5 5 4 5\n\n\nOutput:\n\n\nfirst\nsecond\nfirst",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    nc = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(nc):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        win = any(x % 2 == 1 for x in a)\n        results.append(\"first\" if win else \"second\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2208",
        "hidden_test_path": "/id/hidden/2208",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 3
    },
    {
        "problem_id": "wordcombinations1731",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "Word Combinations",
        "description": "You are given a string of length n and a dictionary containing k words. In how many ways can you create the string using the words?\n\nInput\n\nThe first input line has a string containing n characters between a–z.\n\nThe second line has an integer k : the number of words in the dictionary.\n\nFinally there are k lines describing the words. Each word is unique and consists of characters a–z.\n\nOutput\n\nPrint the number of ways modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 5000 1 ≤ k ≤ 10^5 the total length of the words is at most 10^6\n\nExample\n\nInput:\n\n\nababc\n4\nab\nabab\nc\ncb\n\n\nOutput:\n\n\n2\n\n\nExplanation: The possible ways are ab+ab+c and abab+c .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Node:\n    def __init__(self):\n        self.cur = '_'\n        self.next = [None] * 26\n        self.leaf = False\n\nm = 1000000007\n\ndef mod(k):\n    return (k % m + m) % m\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    str_input = data[0]\n    n = int(data[1])\n    \n    root = Node()\n    \n    for i in range(n):\n        w = data[i + 2]\n        cur = root\n        for char in w:\n            index = ord(char) - ord('a')\n            if cur.next[index] is None:\n                cur.next[index] = Node()\n            cur = cur.next[index]\n        cur.leaf = True\n    \n    dp = [0] * (len(str_input) + 1)\n    reach = [False] * (len(str_input) + 1)\n    dp[0] = 1\n    reach[0] = True\n    \n    for i in range(len(str_input) + 1):\n        if not reach[i]:\n            continue\n        cur = root\n        for j in range(i + 1, len(str_input) + 1):\n            index = ord(str_input[j - 1]) - ord('a')\n            if cur.next[index] is None:\n                break\n            cur = cur.next[index]\n            if cur.leaf:\n                dp[j] = mod(dp[j] + dp[i])\n                reach[j] = True\n    \n    print(dp[len(str_input)])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1731",
        "hidden_test_path": "/id/hidden/1731",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    },
    {
        "problem_id": "stringmatching1753",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "String Matching",
        "description": "Given a string and a pattern, your task is to count the number of positions where the pattern occurs in the string.\n\nInput\n\nThe first input line has a string of length n , and the second input line has a pattern of length m . Both of them consist of characters a–z.\n\nOutput\n\nPrint one integer: the number of occurrences.\n\nConstraints\n\n1 ≤ n,m ≤ 10^6\n\nExample\n\nInput:\n\n\nsaippuakauppias\npp\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def z_function(s):\n    n = len(s)\n    z = [0] * n\n    for i in range(1):\n        l, r = 0, 0\n        for i in range(1, n):\n            if i <= r:\n                z[i] = min(r - i + 1, z[i - l])\n            while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n                z[i] += 1\n            if i + z[i] - 1 > r:\n                l, r = i, i + z[i] - 1\n    return z\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    str_ = data[0]\n    p = data[1]\n    k = len(p)\n    con = p + \"|\" + str_\n    z = z_function(con)\n    cnt = sum(1 for a in z if a == k)\n    print(cnt)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1753",
        "hidden_test_path": "/id/hidden/1753",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 39
    },
    {
        "problem_id": "findingborders1732",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "Finding Borders",
        "description": "A border of a string is a prefix that is also a suffix of the string but not the whole string. For example, the borders of abcababcab are ab and abcab .\n\nYour task is to find all border lengths of a given string.\n\nInput\n\nThe only input line has a string of length n consisting of characters a–z.\n\nOutput\n\nPrint all border lengths of the string in increasing order.\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\nabcababcab\n\n\nOutput:\n\n\n2 5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def z_function(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r:\n            z[i] = min(r - i + 1, z[i - l])\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n        if i + z[i] - 1 > r:\n            l, r = i, i + z[i] - 1\n    return z\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    str_input = input().strip()\n    z = z_function(str_input)\n    n = len(str_input)\n    result = []\n    for i in range(n - 1, -1, -1):\n        if z[i] + i == n:\n            result.append(n - i)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1732",
        "hidden_test_path": "/id/hidden/1732",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "findingperiods1733",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "Finding Periods",
        "description": "A period of a string is a prefix that can be used to generate the whole string by repeating the prefix. The last repetition may be partial. For example, the periods of abcabca are abc , abcabc and abcabca .\n\nYour task is to find all period lengths of a string.\n\nInput\n\nThe only input line has a string of length n consisting of characters a–z.\n\nOutput\n\nPrint all period lengths in increasing order.\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\nabcabca\n\n\nOutput:\n\n\n3 6 7",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def z_function(s):\n    n = len(s)\n    z = [0] * n\n    for i in range(1):\n        l, r = 0, 0\n        for i in range(1, n):\n            if i <= r:\n                z[i] = min(r - i + 1, z[i - l])\n            while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n                z[i] += 1\n            if i + z[i] - 1 > r:\n                l, r = i, i + z[i] - 1\n    return z\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    str_input = input().strip()\n    z = z_function(str_input)\n    ans = []\n\n    for i in range(1, len(str_input)):\n        if z[i] + i == len(str_input):\n            ans.append(i)\n    ans.append(len(str_input))\n    \n    print(\" \".join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1733",
        "hidden_test_path": "/id/hidden/1733",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "longestpalindrome1111",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "Longest Palindrome",
        "description": "Given a string, your task is to determine the longest palindromic substring of the string. For example, the longest palindrome in aybabtu is bab .\n\nInput\n\nThe only input line contains a string of length n . Each character is one of a–z.\n\nOutput\n\nPrint the longest palindrome in the string. If there are several solutions, you may print any of them.\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\naybabtu\n\n\nOutput:\n\n\nbab",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def manacher_odd(s):\n    n = len(s)\n    s = \"$\" + s + \"^\"\n    p = [0] * (n + 2)\n    l, r = 1, 1\n    for i in range(1, n + 1):\n        p[i] = max(0, min(r - i, p[l + (r - i)]))\n        while s[i - p[i]] == s[i + p[i]]:\n            p[i] += 1\n        if i + p[i] > r:\n            l, r = i - p[i], i + p[i]\n    return p[1:-1]\n\ndef manacher(s):\n    t = ''.join('#' + c for c in s) + '#'\n    res = manacher_odd(t)\n    return res[1:-1]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    str_input = input().strip()\n    k = manacher(str_input)\n    length = 0\n    l = 0\n    for i in range(len(k)):\n        if k[i] - 1 > length:\n            l = i // 2\n            length = k[i] - 1\n            l -= (length - 1) // 2\n    print(str_input[l:l + length])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1111",
        "hidden_test_path": "/id/hidden/1111",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "allpalindromes3138",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "All Palindromes",
        "description": "Given a string, calculate for each position the length of the longest palindrome that ends at that position.\n\nInput\n\nThe only line contains a string of length n . Each character is one of a–z.\n\nOutput\n\nPrint n numbers: the length of each palindrome.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5\n\nExample\n\nInput:\n\n\nababbababaa\n\n\nOutput:\n\n\n1 1 3 3 2 4 6 8 5 5 2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def manacher(s):\n    n = len(s)\n    p = [[0] * (n + 1), [0] * n]\n    for z in range(2):\n        l = r = 0\n        for i in range(n):\n            t = r - i + (1 if z else 0)\n            if i < r:\n                p[z][i] = min(t, p[z][l + t])\n            L = i - p[z][i]\n            R = i + p[z][i] - (1 if z else 0)\n            while L >= 1 and R + 1 < n and s[L - 1] == s[R + 1]:\n                p[z][i] += 1\n                L -= 1\n                R += 1\n            if R > r:\n                l, r = L, R\n    return p\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    s = input().strip()\n    m = manacher(s)\n    n = len(s)\n    length = [0] * (n + 1)\n    \n    for i in range(len(m[0])):\n        length[i + m[0][i]] = max(length[i + m[0][i]], 2 * m[0][i])\n    \n    for i in range(len(m[1])):\n        length[i + 1 + m[1][i]] = max(length[i + 1 + m[1][i]], 2 * m[1][i] + 1)\n    \n    for i in range(n - 1, 0, -1):\n        length[i] = max(length[i], length[i + 1] - 2)\n    \n    print(\" \".join(map(str, length[1:n + 1])))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3138",
        "hidden_test_path": "/id/hidden/3138",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "requiredsubstring1112",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "Required Substring",
        "description": "Your task is to calculate the number of strings of length n having a given pattern of length m as their substring. All strings consist of characters A–Z.\n\nInput\n\nThe first input line has an integer n : the length of the final string.\n\nThe second line has a pattern of length m .\n\nOutput\n\nPrint the number of strings modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 1000 1 ≤ m ≤ 100\n\nExample\n\nInput:\n\n\n6\nABCDB\n\n\nOutput:\n\n\n52\n\n\nExplanation: The final string will be of the form ABCDB x or x ABCDB where x is any character between A–Z.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = 10**9 + 7\n\ndef mod(k):\n    return k % MOD\n\ndef pi(s):\n    p = [0] * len(s)\n    for i in range(1, len(s)):\n        g = p[i - 1]\n        while g and s[i] != s[g]:\n            g = p[g - 1]\n        p[i] = g + (s[i] == s[g])\n    return p\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    str_ = data[1]\n    m = len(str_)\n    \n    kmp = pi(str_)\n    aut = [[0] * 26 for _ in range(m + 1)]\n    aut[0][ord(str_[0]) - ord('A')] = 1\n    \n    for i in range(1, m):\n        aut[i] = aut[kmp[i - 1]][:]\n        aut[i][ord(str_[i]) - ord('A')] = i + 1\n    \n    aut[m] = [m] * 26\n    \n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(n):\n        for j in range(m + 1):\n            for k in range(26):\n                dp[i + 1][aut[j][k]] = mod(dp[i + 1][aut[j][k]] + dp[i][j])\n    \n    print(dp[n][m])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1112",
        "hidden_test_path": "/id/hidden/1112",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 19
    },
    {
        "problem_id": "palindromequeries2420",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "Palindrome Queries",
        "description": "You are given a string that consists of n characters between a–z. The positions of the string are indexed 1,2,…,n .\n\nYour task is to process m operations of the following types:\n\nChange the character at position k to x Check if the substring from position a to position b is a palindrome\n\nInput\n\nThe first input line has two integers n and m : the length of the string and the number of operations.\n\nThe next line has a string that consists of n characters.\n\nFinally, there are m lines that describe the operations. Each line is of the form \"1 k x \" or \"2 a b \".\n\nOutput\n\nFor each operation 2, print YES if the substring is a palindrome and NO otherwise.\n\nConstraints\n\n1 ≤ n, m ≤ 2 · 10^5 1 ≤ k ≤ n 1 ≤ a ≤ b ≤ n\n\nExample\n\nInput:\n\n\n7 5\naybabtu\n2 3 5\n1 3 x\n2 3 5\n1 5 x\n2 3 5\n\n\nOutput:\n\n\nYES\nNO\nYES",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom time import time\n\nMOD = 10**9 + 7\n\ndef mod(k):\n    return k % MOD\n\npows = []\nC = int((time() * 1e6) % MOD)\n\nLIM = int(2e5 + 100)\npows.append(1)\nfor i in range(LIM):\n    pows.append(mod(pows[-1] * C))\n\nclass Node:\n    def __init__(self, v, lo, hi):\n        self.l = None\n        self.r = None\n        self.lo = lo\n        self.hi = hi\n        self.mid = 0\n        if lo + 1 < hi:\n            self.mid = lo + (hi - lo) // 2\n            self.l = Node(v, lo, self.mid)\n            self.r = Node(v, self.mid, hi)\n            self.val = self.comb(self.l.val, self.r.val)\n        else:\n            self.val = ((ord(v[lo]) - ord('a') + 1, ord(v[lo]) - ord('a') + 1), 1)\n\n    def comb(self, a, b):\n        return ((mod(a[0][0] + mod(pows[a[1]] * b[0][0])), mod(mod(a[0][1] * pows[b[1]]) + b[0][1])), a[1] + b[1])\n\n    def change(self, idx, c):\n        if self.lo + 1 == self.hi:\n            self.val = ((ord(c) - ord('a') + 1, ord(c) - ord('a') + 1), 1)\n            return\n        if self.mid <= idx:\n            self.r.change(idx, c)\n        else:\n            self.l.change(idx, c)\n        self.val = self.comb(self.l.val, self.r.val)\n\n    def query(self, L, R):\n        if self.hi <= L or R <= self.lo:\n            return ((0, 0), 0)\n        if L <= self.lo and self.hi <= R:\n            return self.val\n        return self.comb(self.l.query(L, R), self.r.query(L, R))\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    n, q = map(int, data[0].split())\n    str_input = data[1]\n    tree = Node(str_input, 0, len(str_input))\n    \n    output = []\n    for i in range(2, 2 + q):\n        query = list(map(int, data[i].split()))\n        if query[0] == 1:\n            idx = query[1] - 1\n            c = query[2]\n            tree.change(idx, c)\n        else:\n            l, r = query[1] - 1, query[2] - 1\n            res = tree.query(l, r + 1)\n            output.append(\"YES\" if res[0][0] == res[0][1] else \"NO\")\n    \n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2420",
        "hidden_test_path": "/id/hidden/2420",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "findingpatterns2102",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "Finding Patterns",
        "description": "Given a string and patterns, check for each pattern if it appears in the string.\n\nInput\n\nThe first input line has a string of length n .\n\nThe next input line has an integer k : the number of patterns. Finally, there are k lines that describe the patterns.\n\nThe string and the patterns consist of characters a–z.\n\nOutput\n\nFor each pattern, print \"YES\" if it appears in the string and \"NO\" otherwise.\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ k ≤ 5 · 10^5 the total length of the patterns is at most 5 · 10^5\n\nExample\n\nInput:\n\n\naybabtu\n3\nbab\nabc\nayba\n\n\nOutput:\n\n\nYES\nNO\nYES",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import deque\n\nclass AhoCorasick:\n    alpha = 26\n    first = ord('a')\n\n    class Node:\n        def __init__(self, v):\n            self.back = None\n            self.next = [-1] * AhoCorasick.alpha\n            self.start = -1\n            self.end = -1\n            self.nmatches = 0\n            self.ends = []\n            self.trav = False\n\n    def __init__(self, pat):\n        self.N = [AhoCorasick.Node(-1)]\n        self.backp = []\n        for j, s in enumerate(pat):\n            self.insert(s, j)\n        self.N[0].back = len(self.N)\n        self.N.append(AhoCorasick.Node(0))\n\n        q = deque([0])\n        while q:\n            n = q.popleft()\n            prev = self.N[n].back\n            for i in range(AhoCorasick.alpha):\n                ed = self.N[n].next[i]\n                y = self.N[prev].next[i]\n                if ed == -1:\n                    self.N[n].next[i] = y\n                else:\n                    self.N[ed].back = y\n                    if self.N[ed].end == -1:\n                        self.N[ed].end = self.backp[self.N[ed].start]\n                    self.N[ed].nmatches += self.N[y].nmatches\n                    q.append(ed)\n\n    def insert(self, s, j):\n        assert s\n        n = 0\n        for c in s:\n            m = self.N[n].next[ord(c) - AhoCorasick.first]\n            if m == -1:\n                n = m = len(self.N)\n                self.N.append(AhoCorasick.Node(-1))\n            else:\n                n = m\n        if self.N[n].end == -1:\n            self.N[n].start = j\n        self.backp.append(self.N[n].end)\n        self.N[n].end = j\n        self.N[n].ends.append(j)\n        self.N[n].nmatches += 1\n\n    def find(self, word, v):\n        n = 0\n        res = [False] * v\n        self.N[n].trav = True\n        for c in word:\n            n = self.N[n].next[ord(c) - AhoCorasick.first]\n            self.N[n].trav = True\n\n        visited = [False] * len(self.N)\n        q = deque()\n        for i in range(len(self.N) - 1, -1, -1):\n            if self.N[i].trav:\n                q.append(i)\n\n        while q:\n            k = q.popleft()\n            if visited[k]:\n                continue\n            visited[k] = True\n            for j in self.N[k].ends:\n                res[j] = True\n            if k > 0 and not visited[self.N[k].back]:\n                q.append(self.N[k].back)\n\n        return res\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    str_input = data[0]\n    q = int(data[1])\n    pat = [data[i + 2] for i in range(q)]\n    \n    ac = AhoCorasick(pat)\n    res = ac.find(str_input, q)\n    \n    for i in range(q):\n        print(\"YES\" if res[i] else \"NO\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2102",
        "hidden_test_path": "/id/hidden/2102",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 18
    },
    {
        "problem_id": "countingpatterns2103",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "Counting Patterns",
        "description": "Given a string and patterns, count for each pattern the number of positions where it appears in the string.\n\nInput\n\nThe first input line has a string of length n .\n\nThe next input line has an integer k : the number of patterns. Finally, there are k lines that describe the patterns.\n\nThe string and the patterns consist of characters a–z.\n\nOutput\n\nFor each pattern, print the number of positions.\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ k ≤ 5 · 10^5 the total length of the patterns is at most 5 · 10^5\n\nExample\n\nInput:\n\n\naybabtu\n3\nbab\nabc\na\n\n\nOutput:\n\n\n1\n0\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import deque\n\nclass AhoCorasick:\n    alpha = 26\n    first = ord('a')\n\n    class Node:\n        def __init__(self, v):\n            self.back = -1\n            self.next = [v] * AhoCorasick.alpha\n            self.start = -1\n            self.end = -1\n            self.nmatches = 0\n            self.ends = []\n            self.trav = 0\n\n    def __init__(self, pat):\n        self.N = [self.Node(-1)]\n        self.backp = []\n        for i in range(len(pat)):\n            self.insert(pat[i], i)\n        self.N[0].back = len(self.N)\n        self.N.append(self.Node(0))\n\n        q = deque([0])\n        while q:\n            n = q.popleft()\n            prev = self.N[n].back\n            for i in range(self.alpha):\n                ed = self.N[n].next[i]\n                y = self.N[prev].next[i]\n                if ed == -1:\n                    self.N[n].next[i] = y\n                else:\n                    self.N[ed].back = y\n                    if self.N[ed].end == -1:\n                        self.N[ed].end = self.backp[self.N[ed].start]\n                    self.N[ed].nmatches += self.N[y].nmatches\n                    q.append(ed)\n\n    def insert(self, s, j):\n        assert s\n        n = 0\n        for c in s:\n            m = self.N[n].next[ord(c) - self.first]\n            if m == -1:\n                n = m = len(self.N)\n                self.N.append(self.Node(-1))\n            else:\n                n = m\n        if self.N[n].end == -1:\n            self.N[n].start = j\n        self.backp.append(self.N[n].end)\n        self.N[n].end = j\n        self.N[n].ends.append(j)\n        self.N[n].nmatches += 1\n\n    def find(self, word, v):\n        n = 0\n        res = [0] * v\n        child = [[] for _ in range(len(self.N))]\n\n        self.N[n].trav += 1\n        for c in word:\n            n = self.N[n].next[ord(c) - self.first]\n            self.N[n].trav += 1\n\n        for i in range(len(self.N) - 2, -1, -1):\n            child[self.N[i].back].append(i)\n\n        dp = [-1] * len(self.N)\n\n        def solve(c):\n            if dp[c] != -1:\n                return dp[c]\n            dp[c] = self.N[c].trav\n            for i in child[c]:\n                dp[c] += solve(i)\n            return dp[c]\n\n        for i in range(len(self.N)):\n            for j in self.N[i].ends:\n                res[j] += solve(i)\n\n        return res\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    str_input = data[0]\n    q = int(data[1])\n    pat = [data[i + 2] for i in range(q)]\n    \n    ac = AhoCorasick(pat)\n    res = ac.find(str_input, q)\n    \n    for r in res:\n        print(r)",
        "public_test_path": "/id/public/2103",
        "hidden_test_path": "/id/hidden/2103",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "patternpositions2104",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "Pattern Positions",
        "description": "Given a string and patterns, find for each pattern the first position (1-indexed) where it appears in the string.\n\nInput\n\nThe first input line has a string of length n .\n\nThe next input line has an integer k : the number of patterns. Finally, there are k lines that describe the patterns.\n\nThe string and the patterns consist of characters a–z.\n\nOutput\n\nPrint the first position for each pattern (or -1 if it does not appear at all).\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ k ≤ 5 · 10^5 the total length of the patterns is at most 5 · 10^5\n\nExample\n\nInput:\n\n\naybabtu\n3\nbab\nabc\na\n\n\nOutput:\n\n\n3\n-1\n1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import deque\n\nbad = int(1e9)\n\nclass AhoCorasick:\n    alpha = 26\n    first = ord('a')\n\n    class Node:\n        def __init__(self, v):\n            self.back = None\n            self.next = [-1] * AhoCorasick.alpha\n            self.start = -1\n            self.end = -1\n            self.nmatches = 0\n            self.ends = []\n            self.trav = bad\n\n    def __init__(self, pat):\n        self.N = [AhoCorasick.Node(-1)]\n        self.backp = []\n        for j, s in enumerate(pat):\n            self.insert(s, j)\n        self.N[0].back = len(self.N)\n        self.N.append(AhoCorasick.Node(0))\n\n        q = deque([0])\n        while q:\n            n = q.popleft()\n            prev = self.N[n].back\n            for i in range(AhoCorasick.alpha):\n                ed = self.N[n].next[i]\n                y = self.N[prev].next[i]\n                if ed == -1:\n                    self.N[n].next[i] = y\n                else:\n                    self.N[ed].back = y\n                    if self.N[ed].end == -1:\n                        self.N[ed].end = self.backp[self.N[ed].start]\n                    self.N[ed].nmatches += self.N[y].nmatches\n                    q.append(ed)\n\n    def insert(self, s, j):\n        assert s\n        n = 0\n        for c in s:\n            m = self.N[n].next[ord(c) - AhoCorasick.first]\n            if m == -1:\n                n = m = len(self.N)\n                self.N.append(AhoCorasick.Node(-1))\n            else:\n                n = m\n        if self.N[n].end == -1:\n            self.N[n].start = j\n        self.backp.append(self.N[n].end)\n        self.N[n].end = j\n        self.N[n].ends.append(j)\n        self.N[n].nmatches += 1\n\n    def find(self, word, v):\n        n = 0\n        res = [bad] * v\n        child = [[] for _ in range(len(self.N))]\n\n        self.N[n].trav = 0\n        t = 1\n        for c in word:\n            n = self.N[n].next[ord(c) - AhoCorasick.first]\n            self.N[n].trav = min(self.N[n].trav, t)\n            t += 1\n\n        for i in range(len(self.N) - 2, -1, -1):\n            child[self.N[i].back].append(i)\n\n        dp = [-1] * len(self.N)\n\n        def solve(c):\n            if dp[c] != -1:\n                return dp[c]\n            dp[c] = self.N[c].trav\n            for i in child[c]:\n                dp[c] = min(dp[c], solve(i))\n            return dp[c]\n\n        for i in range(len(self.N)):\n            for j in self.N[i].ends:\n                res[j] = min(res[j], solve(i))\n\n        return res\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    str_input = data[0]\n    q = int(data[1])\n    pat = [data[i + 2] for i in range(q)]\n    \n    ac = AhoCorasick(pat)\n    res = ac.find(str_input, q)\n    \n    for i in range(q):\n        if res[i] == bad:\n            res[i] = -1\n        else:\n            res[i] -= len(pat[i]) - 1\n        print(res[i])",
        "public_test_path": "/id/public/2104",
        "hidden_test_path": "/id/hidden/2104",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "distinctsubstrings2105",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "Distinct Substrings",
        "description": "Count the number of distinct substrings that appear in a string.\n\nInput\n\nThe only input line has a string of length n that consists of characters a–z.\n\nOutput\n\nPrint one integer: the number of substrings.\n\nConstraints\n\n1 ≤ n ≤ 10^5\n\nExample\n\nInput:\n\n\nabaa\n\n\nOutput:\n\n\n8\n\n\nExplanation: the substrings are a , b , aa , ab , ba , aba , baa and abaa .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\n\nclass SuffixArray:\n    def __init__(self, s, lim=256):\n        n = len(s) + 1\n        k = 0\n        a, b = 0, 0\n        x = list(map(ord, s)) + [0]\n        y = [0] * n\n        ws = [0] * max(n, lim)\n        rank = [0] * n\n        self.sa = list(range(n))\n        self.lcp = y\n        \n        for j, p in enumerate(range(0, n, max(1, j * 2))):\n            p = j\n            y[n - j:] = self.sa[:n - j]\n            for i in range(n):\n                if self.sa[i] >= j:\n                    y[p] = self.sa[i] - j\n                    p += 1\n            ws = [0] * max(n, lim)\n            for i in range(n):\n                ws[x[i]] += 1\n            for i in range(1, lim):\n                ws[i] += ws[i - 1]\n            for i in range(n - 1, -1, -1):\n                self.sa[ws[x[y[i]]] - 1] = y[i]\n                ws[x[y[i]]] -= 1\n            x, p = y, 1\n            x[self.sa[0]] = 0\n            for i in range(1, n):\n                a = self.sa[i - 1]\n                b = self.sa[i]\n                x[b] = p - 1 if y[a] == y[b] and y[a + j] == y[b + j] else p\n                p += 1\n        \n        for i in range(1, n):\n            rank[self.sa[i]] = i\n        \n        for i in range(n - 1):\n            k = k - 1 if k else 0\n            j = self.sa[rank[i] - 1]\n            while i + k < n - 1 and j + k < n - 1 and s[i + k] == s[j + k]:\n                k += 1\n            self.lcp[rank[i]] = k\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    str_input = input().strip()\n    sa = SuffixArray(str_input)\n    ans = 0\n    for i in range(1, len(sa.sa)):\n        ans += len(str_input) - sa.sa[i] - sa.lcp[i]\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2105",
        "hidden_test_path": "/id/hidden/2105",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "repeatingsubstring2106",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "Repeating Substring",
        "description": "A repeating substring is a substring that occurs in two (or more) locations in the string. Your task is to find the longest repeating substring in a given string.\n\nInput\n\nThe only input line has a string of length n that consists of characters a–z.\n\nOutput\n\nPrint the longest repeating substring. If there are several possibilities, you can print any of them. If there is no repeating substring, print -1 .\n\nConstraints\n\n1 ≤ n ≤ 10^5\n\nExample\n\nInput:\n\n\ncabababc\n\n\nOutput:\n\n\nabab",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class SuffixArray:\n    def __init__(self, s, lim=256):\n        n = len(s) + 1\n        k = 0\n        a, b = 0, 0\n        x = list(map(ord, s)) + [0]\n        y = [0] * n\n        ws = [0] * max(n, lim)\n        rank = [0] * n\n        self.sa = list(range(n))\n        self.lcp = y\n        \n        for j, p in enumerate(range(0, n, max(1, j * 2))):\n            p = j\n            y[n - j:] = self.sa[:n - j]\n            for i in range(n):\n                if self.sa[i] >= j:\n                    y[p] = self.sa[i] - j\n                    p += 1\n            ws = [0] * max(n, lim)\n            for i in range(n):\n                ws[x[i]] += 1\n            for i in range(1, lim):\n                ws[i] += ws[i - 1]\n            for i in range(n - 1, -1, -1):\n                self.sa[ws[x[y[i]]] - 1] = y[i]\n                ws[x[y[i]]] -= 1\n            x, p = y, 1\n            x[self.sa[0]] = 0\n            for i in range(1, n):\n                a = self.sa[i - 1]\n                b = self.sa[i]\n                x[b] = p - 1 if y[a] == y[b] and y[a + j] == y[b + j] else p\n                p += 1\n        \n        for i in range(1, n):\n            rank[self.sa[i]] = i\n        \n        for i in range(n - 1):\n            j = self.sa[rank[i] - 1]\n            while k and k > 0:\n                k -= 1\n            while i + k < n and j + k < n and s[i + k] == s[j + k]:\n                k += 1\n            self.lcp[rank[i]] = k\n\nimport sys\ninput = sys.stdin.read\n\ndef main():\n    str_input = input().strip()\n    sa = SuffixArray(str_input)\n    best = 1\n    for i in range(1, len(sa.sa)):\n        if sa.lcp[i] > sa.lcp[best]:\n            best = i\n    if sa.lcp[best] == 0:\n        print(\"-1\")\n        return\n    print(str_input[sa.sa[best]:sa.sa[best] + sa.lcp[best]])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2106",
        "hidden_test_path": "/id/hidden/2106",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 9
    },
    {
        "problem_id": "stringfunctions2107",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "String Functions",
        "description": "We consider a string of n characters, indexed 1,2,…,n . Your task is to calculate all values of the following functions:\n\nz(i) denotes the maximum length of a substring that begins at position i and is a prefix of the string. In addition, z(1)=0 . π(i) denotes the maximum length of a substring that ends at position i , is a prefix of the string, and whose length is at most i-1 .\n\nNote that the function z is used in the Z-algorithm, and the function π is used in the KMP algorithm.\n\nInput\n\nThe only input line has a string of length n . Each character is between a–z.\n\nOutput\n\nPrint two lines: first the values of the z function, and then the values of the π function.\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\nabaabca\n\n\nOutput:\n\n\n0 0 1 2 0 0 1\n0 0 1 1 2 0 1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def Z(S):\n    z = [0] * len(S)\n    l, r = -1, -1\n    for i in range(1, len(S)):\n        if i >= r:\n            z[i] = 0\n        else:\n            z[i] = min(r - i, z[i - l])\n        while i + z[i] < len(S) and S[i + z[i]] == S[z[i]]:\n            z[i] += 1\n        if i + z[i] > r:\n            l, r = i, i + z[i]\n    return z\n\ndef kmp(s):\n    p = [0] * len(s)\n    for i in range(1, len(s)):\n        g = p[i - 1]\n        while g and s[i] != s[g]:\n            g = p[g - 1]\n        p[i] = g + (s[i] == s[g])\n    return p\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    str_input = input().strip()\n    z = Z(str_input)\n    k = kmp(str_input)\n    print(\" \".join(map(str, z)))\n    print(\" \".join(map(str, k)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2107",
        "hidden_test_path": "/id/hidden/2107",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 5
    },
    {
        "problem_id": "inversesuffixarray3225",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "Inverse Suffix Array",
        "description": "Given a suffix array of a string, your task is to reconstruct the string.\n\nThe suffix array of a string of length n is a permutation of numbers 1,2,…,n that presents the lexicographical order of the suffixes.\n\nInput\n\nThe first line has an integer n : the length of the string.\n\nThe next line has n integers: the suffix array.\n\nOutput\n\nPrint a string that corresponds to the suffix array. The string must consist of characters a–z. If there are several possible strings, you can print any of them.\n\nIf no string corresponds to the suffix array, print -1 .\n\nConstraints\n\n1 ≤ n ≤ 10^5\n\nExample\n\nInput:\n\n\n7\n4 1 3 5 6 7 2\n\n\nOutput:\n\n\naybabtu",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class SuffixArray:\n    def __init__(self, s, lim=256):\n        s.append(0)\n        n = len(s)\n        k = 0\n        a, b = 0, 0\n        x = list(s)\n        y = [0] * n\n        ws = [0] * max(n, lim)\n        sa = list(range(n))\n        lcp = y\n        for j, p in enumerate(range(0, n, max(1, j * 2))):\n            p = j\n            y[n - j:] = sa[:j]\n            for i in range(n):\n                if sa[i] >= j:\n                    y[p] = sa[i] - j\n                    p += 1\n            ws = [0] * max(n, lim)\n            for i in range(n):\n                ws[x[i]] += 1\n            for i in range(1, lim):\n                ws[i] += ws[i - 1]\n            for i in range(n - 1, -1, -1):\n                sa[ws[x[y[i]]] - 1] = y[i]\n                ws[x[y[i]]] -= 1\n            x, p = y, 1\n            x[sa[0]] = 0\n            for i in range(1, n):\n                a = sa[i - 1]\n                b = sa[i]\n                x[b] = p - 1 if y[a] == y[b] and y[a + j] == y[b + j] else p\n                if y[a] != y[b] or y[a + j] != y[b + j]:\n                    p += 1\n        k = 0\n        for i in range(n - 1):\n            lcp[x[i]] = k\n            while k and k > 0:\n                k -= 1\n            j = sa[x[i] - 1]\n            while i + k < n and j + k < n and s[i + k] == s[j + k]:\n                k += 1\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    p = list(map(int, data[1:n + 1]))\n    inv = [0] * n\n    for i in range(n):\n        p[i] -= 1\n        inv[p[i]] = i\n    \n    s = ['a'] * n\n    cur = 'a'\n    s[p[0]] = cur\n    for i in range(n - 1):\n        a = p[i]\n        b = p[i + 1]\n        if a == n - 1:\n            continue\n        elif b == n - 1 or inv[b + 1] < inv[a + 1]:\n            cur = chr(ord(cur) + 1)\n            if cur > 'z':\n                print(\"-1\")\n                return\n        s[b] = cur\n    \n    print(\"\".join(s))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3225",
        "hidden_test_path": "/id/hidden/3225",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "stringtransform1113",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "String Transform",
        "description": "Consider the following string transformation:\n\nappend the character # to the string (we assume that # is lexicographically smaller than all other characters of the string) generate all rotations of the string sort the rotations in increasing order based on this order, construct a new string that contains the last character of each rotation\n\nFor example, the string babc becomes babc# . Then, the sorted list of rotations is #babc , abc#b , babc# , bc#ba , and c#bab . This yields a string cb#ab .\n\nInput\n\nThe only input line contains the transformed string of length n+1 . Each character of the original string is one of a–z.\n\nOutput\n\nPrint the original string of length n .\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\ncb#ab\n\n\nOutput:\n\n\nbabc",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().strip().split()\n    str_input = data[0]\n    \n    cnt = [0] * 26\n    n = len(str_input)\n    \n    for char in str_input:\n        if char == '#':\n            continue\n        cnt[ord(char) - ord('a')] += 1\n\n    start = [0] * 26\n    seen = [0] * 26\n    v = 1\n    \n    for i in range(26):\n        start[i] = v\n        v += cnt[i]\n\n    a = [0] * n\n    b = [0] * n\n    \n    for i in range(n):\n        if str_input[i] == '#':\n            a[i] = 0\n        else:\n            a[i] = start[ord(str_input[i]) - ord('a')] + seen[ord(str_input[i]) - ord('a')]\n            seen[ord(str_input[i]) - ord('a')] += 1\n\n    for i in range(n):\n        b[a[i]] = i\n\n    c = b[0]\n    sorted_str = sorted(str_input)\n    ans = []\n\n    while c != 0:\n        ans.append(sorted_str[c])\n        c = b[c]\n\n    print(''.join(ans))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1113",
        "hidden_test_path": "/id/hidden/1113",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    },
    {
        "problem_id": "substringdistribution2110",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "Substring Distribution",
        "description": "You are given a string of length n . For every integer between 1 … n you need to print the number of distinct substrings of that length.\n\nInput\n\nThe only input line has a string of length n that consists of characters a–z.\n\nOutput\n\nFor each integer between 1 … n print the number of distinct substrings of that length.\n\nConstraints\n\n1 ≤ n ≤ 10^5\n\nExample\n\nInput:\n\n\nabab\n\n\nOutput:\n\n\n2 2 2 1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class SuffixArray:\n    def __init__(self, s, lim=256):\n        n = len(s) + 1\n        k = 0\n        a, b = 0, 0\n        x = list(map(ord, s)) + [0]\n        y = [0] * n\n        ws = [0] * max(n, lim)\n        rank = [0] * n\n        self.sa = list(range(n))\n        self.lcp = y\n        \n        for j, p in enumerate(range(0, n, max(1, j * 2))):\n            p = j\n            y[n - j:] = self.sa[:n - j]\n            for i in range(n):\n                if self.sa[i] >= j:\n                    y[p] = self.sa[i] - j\n                    p += 1\n            ws = [0] * max(n, lim)\n            for i in range(n):\n                ws[x[i]] += 1\n            for i in range(1, lim):\n                ws[i] += ws[i - 1]\n            for i in range(n - 1, -1, -1):\n                self.sa[ws[x[y[i]]] - 1] = y[i]\n                ws[x[y[i]]] -= 1\n            x, p = y, 1\n            x[self.sa[0]] = 0\n            for i in range(1, n):\n                a = self.sa[i - 1]\n                b = self.sa[i]\n                x[b] = p - 1 if y[a] == y[b] and y[a + j] == y[b + j] else p\n                p += 1\n        \n        for i in range(1, n):\n            rank[self.sa[i]] = i\n        \n        k = 0\n        for i in range(n - 1):\n            j = self.sa[rank[i] - 1]\n            while k < n - 1 and s[i + k] == s[j + k]:\n                k += 1\n            self.lcp[rank[i]] = k\n            if k:\n                k -= 1\n\n\nclass Node:\n    def __init__(self, lo, hi):\n        self.l = None\n        self.r = None\n        self.lo = lo\n        self.hi = hi\n        self.madd = 0\n        self.val = 0\n        if lo + 1 < hi:\n            mid = lo + (hi - lo) // 2\n            self.l = Node(lo, mid)\n            self.r = Node(mid, hi)\n            self.comb()\n\n    def combine(self, l, r):\n        return l + r\n\n    def comb(self):\n        self.val = self.combine(self.l.val, self.r.val)\n\n    def add(self, L, R, x):\n        if R <= self.lo or self.hi <= L:\n            return\n        if L <= self.lo and self.hi <= R:\n            self.madd += x\n            self.val += x\n        else:\n            self.push()\n            self.l.add(L, R, x)\n            self.r.add(L, R, x)\n            self.comb()\n\n    def dfs(self):\n        if self.lo + 1 == self.hi:\n            print(self.val, end=\" \")\n        else:\n            self.push()\n            self.l.dfs()\n            self.r.dfs()\n\n    def push(self):\n        if self.madd:\n            self.l.add(self.lo, self.hi, self.madd)\n            self.r.add(self.lo, self.hi, self.madd)\n            self.madd = 0\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    str_input = input().strip()\n    sa = SuffixArray(str_input)\n    tree = Node(1, len(str_input) + 1)\n    \n    for i in range(1, len(sa.sa)):\n        length = len(str_input) - sa.sa[i] - sa.lcp[i]\n        if length > 0:\n            tree.add(sa.lcp[i] + 1, sa.lcp[i] + 1 + length, 1)\n    \n    tree.dfs()\n    print()\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2110",
        "hidden_test_path": "/id/hidden/2110",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 9
    },
    {
        "problem_id": "pointlocationtest2189",
        "topic": "Chương 1",
        "sub_topic": "Geometry",
        "name": "Point Location Test",
        "description": "There is a line that goes through the points p_1=(x_1,y_1) and p_2=(x_2,y_2) . There is also a point p_3=(x_3,y_3) .\n\nYour task is to determine whether p_3 is located on the left or right side of the line or if it touches the line when we are looking from p_1 to p_2 .\n\nInput\n\nThe first input line has an integer t : the number of tests.\n\nAfter this, there are t lines that describe the tests. Each line has six integers: x_1 , y_1 , x_2 , y_2 , x_3 and y_3 .\n\nOutput\n\nFor each test, print \"LEFT\", \"RIGHT\" or \"TOUCH\".\n\nConstraints\n\n1 ≤ t ≤ 10^5 -10^9 ≤ x_1, y_1, x_2, y_2, x_3, y_3 ≤ 10^9 x_1 ≠ x_2 or y_1 ≠ y_2\n\nExample\n\nInput:\n\n\n3\n1 1 5 3 2 3\n1 1 5 3 4 1\n1 1 5 3 3 2\n\n\nOutput:\n\n\nLEFT\nRIGHT\nTOUCH",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport math\nfrom typing import Tuple\n\nclass Point:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    def __lt__(self, p: 'Point') -> bool:\n        return (self.x, self.y) < (p.x, p.y)\n\n    def __eq__(self, p: 'Point') -> bool:\n        return (self.x, self.y) == (p.x, p.y)\n\n    def __add__(self, p: 'Point') -> 'Point':\n        return Point(self.x + p.x, self.y + p.y)\n\n    def __sub__(self, p: 'Point') -> 'Point':\n        return Point(self.x - p.x, self.y - p.y)\n\n    def __mul__(self, d: float) -> 'Point':\n        return Point(self.x * d, self.y * d)\n\n    def __truediv__(self, d: float) -> 'Point':\n        return Point(self.x / d, self.y / d)\n\n    def dot(self, p: 'Point') -> float:\n        return self.x * p.x + self.y * p.y\n\n    def cross(self, p: 'Point') -> float:\n        return self.x * p.y - self.y * p.x\n\n    def cross_two(self, a: 'Point', b: 'Point') -> float:\n        return (a - self).cross(b - self)\n\n    def dist2(self) -> float:\n        return self.x * self.x + self.y * self.y\n\n    def dist(self) -> float:\n        return math.sqrt(self.dist2())\n\n    def angle(self) -> float:\n        return math.atan2(self.y, self.x)\n\n    def unit(self) -> 'Point':\n        return self / self.dist()\n\n    def perp(self) -> 'Point':\n        return Point(-self.y, self.x)\n\n    def normal(self) -> 'Point':\n        return self.perp().unit()\n\n    def rotate(self, a: float) -> 'Point':\n        return Point(self.x * math.cos(a) - self.y * math.sin(a), \n                     self.x * math.sin(a) + self.y * math.cos(a))\n\n    def __repr__(self) -> str:\n        return f\"({self.x},{self.y})\"\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    n = int(data[0])\n    \n    results = []\n    for i in range(1, n + 1):\n        p1, p2, p3 = Point(), Point(), Point()\n        p1.x, p1.y, p2.x, p2.y, p3.x, p3.y = map(int, data[i].split())\n        dif = p2 - p1\n        sig = dif.cross(p3 - p1)\n        \n        if sig == 0:\n            results.append(\"TOUCH\")\n        elif sig > 0:\n            results.append(\"LEFT\")\n        else:\n            results.append(\"RIGHT\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2189",
        "hidden_test_path": "/id/hidden/2189",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    },
    {
        "problem_id": "linesegmentintersection2190",
        "topic": "Chương 1",
        "sub_topic": "Geometry",
        "name": "Line Segment Intersection",
        "description": "There are two line segments: the first goes through the points (x_1,y_1) and (x_2,y_2) , and the second goes through the points (x_3,y_3) and (x_4,y_4) .\n\nYour task is to determine if the line segments intersect, i.e., they have at least one common point.\n\nInput\n\nThe first input line has an integer t : the number of tests.\n\nAfter this, there are t lines that describe the tests. Each line has eight integers x_1 , y_1 , x_2 , y_2 , x_3 , y_3 , x_4 and y_4 .\n\nOutput\n\nFor each test, print \"YES\" if the line segments intersect and \"NO\" otherwise.\n\nConstraints\n\n1 ≤ t ≤ 10^5 -10^9 ≤ x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4 ≤ 10^9 (x_1,y_1) ≠ (x_2,y_2) (x_3,y_3) ≠ (x_4,y_4)\n\nExample\n\nInput:\n\n\n5\n1 1 5 3 1 2 4 3\n1 1 5 3 1 1 4 3\n1 1 5 3 2 3 4 1\n1 1 5 3 2 4 4 1\n1 1 5 3 3 2 7 4\n\n\nOutput:\n\n\nNO\nYES\nYES\nYES\nYES",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport math\nfrom collections import namedtuple\n\nPoint = namedtuple('Point', ['x', 'y'])\n\ndef sgn(x):\n    return (x > 0) - (x < 0)\n\ndef on_segment(s, e, p):\n    return p.cross(s, e) == 0 and (s - p).dot(e - p) <= 0\n\ndef seg_inter(a, b, c, d):\n    oa = c.cross(d, a)\n    ob = c.cross(d, b)\n    oc = a.cross(b, c)\n    od = a.cross(b, d)\n    \n    if sgn(oa) * sgn(ob) < 0 and sgn(oc) * sgn(od) < 0:\n        return [a * ob - b * oa / (ob - oa)]\n    \n    s = set()\n    if on_segment(c, d, a): s.add(a)\n    if on_segment(c, d, b): s.add(b)\n    if on_segment(a, b, c): s.add(c)\n    if on_segment(a, b, d): s.add(d)\n    \n    return list(s)\n\nclass P:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    def __lt__(self, p):\n        return (self.x, self.y) < (p.x, p.y)\n\n    def __eq__(self, p):\n        return (self.x, self.y) == (p.x, p.y)\n\n    def __add__(self, p):\n        return P(self.x + p.x, self.y + p.y)\n\n    def __sub__(self, p):\n        return P(self.x - p.x, self.y - p.y)\n\n    def __mul__(self, d):\n        return P(self.x * d, self.y * d)\n\n    def __truediv__(self, d):\n        return P(self.x / d, self.y / d)\n\n    def dot(self, p):\n        return self.x * p.x + self.y * p.y\n\n    def cross(self, p):\n        return self.x * p.y - self.y * p.x\n\n    def cross_two(self, a, b):\n        return (a - self).cross(b - self)\n\n    def dist2(self):\n        return self.x * self.x + self.y * self.y\n\n    def dist(self):\n        return math.sqrt(self.dist2())\n\n    def angle(self):\n        return math.atan2(self.y, self.x)\n\n    def unit(self):\n        return self / self.dist()\n\n    def perp(self):\n        return P(-self.y, self.x)\n\n    def normal(self):\n        return self.perp().unit()\n\n    def rotate(self, a):\n        return P(self.x * math.cos(a) - self.y * math.sin(a), self.x * math.sin(a) + self.y * math.cos(a))\n\n    def __repr__(self):\n        return f\"({self.x},{self.y})\"\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    n = int(data[0])\n    \n    results = []\n    for i in range(1, n + 1):\n        p1, p2, p3, p4 = map(int, data[i].split())\n        p1 = P(p1[0], p1[1])\n        p2 = P(p2[0], p2[1])\n        p3 = P(p3[0], p3[1])\n        p4 = P(p4[0], p4[1])\n        \n        ss = seg_inter(p1, p2, p3, p4)\n        results.append(\"YES\" if ss else \"NO\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2190",
        "hidden_test_path": "/id/hidden/2190",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    },
    {
        "problem_id": "polygonarea2191",
        "topic": "Chương 1",
        "sub_topic": "Geometry",
        "name": "Polygon Area",
        "description": "Your task is to calculate the area of a given polygon.\n\nThe polygon consists of n vertices (x_1,y_1),(x_2,y_2),…,(x_n,y_n) . The vertices (x_i,y_i) and (x_{i+1},y_{i+1}) are adjacent for i=1,2,…,n-1 , and the vertices (x_1,y_1) and (x_n,y_n) are also adjacent.\n\nInput\n\nThe first input line has an integer n : the number of vertices.\n\nAfter this, there are n lines that describe the vertices. The i th such line has two integers x_i and y_i .\n\nYou may assume that the polygon is simple, i.e., it does not intersect itself.\n\nOutput\n\nPrint one integer: 2a where the area of the polygon is a (this ensures that the result is an integer).\n\nConstraints\n\n3 ≤ n ≤ 1000 -10^9 ≤ x_i, y_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4\n1 1\n4 2\n3 5\n1 4\n\n\nOutput:\n\n\n16",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport math\nfrom typing import List, Tuple\n\nclass Point:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    def __lt__(self, p):\n        return (self.x, self.y) < (p.x, p.y)\n\n    def __eq__(self, p):\n        return (self.x, self.y) == (p.x, p.y)\n\n    def __add__(self, p):\n        return Point(self.x + p.x, self.y + p.y)\n\n    def __sub__(self, p):\n        return Point(self.x - p.x, self.y - p.y)\n\n    def __mul__(self, d):\n        return Point(self.x * d, self.y * d)\n\n    def __truediv__(self, d):\n        return Point(self.x / d, self.y / d)\n\n    def dot(self, p):\n        return self.x * p.x + self.y * p.y\n\n    def cross(self, p):\n        return self.x * p.y - self.y * p.x\n\n    def cross2(self, a, b):\n        return (a - self).cross(b - self)\n\n    def dist2(self):\n        return self.x * self.x + self.y * self.y\n\n    def dist(self):\n        return math.sqrt(self.dist2())\n\n    def angle(self):\n        return math.atan2(self.y, self.x)\n\n    def unit(self):\n        return self / self.dist()\n\n    def perp(self):\n        return Point(-self.y, self.x)\n\n    def normal(self):\n        return self.perp().unit()\n\n    def rotate(self, a):\n        return Point(self.x * math.cos(a) - self.y * math.sin(a),\n                     self.x * math.sin(a) + self.y * math.cos(a))\n\n    def __repr__(self):\n        return f\"({self.x},{self.y})\"\n\ndef polygon_area_2(v: List[Point]) -> int:\n    a = v[-1].cross(v[0])\n    for i in range(len(v) - 1):\n        a += v[i].cross(v[i + 1])\n    return a\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    n = int(data[0])\n    v = [Point(*map(int, line.split())) for line in data[1:n + 1]]\n    print(abs(polygon_area_2(v)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2191",
        "hidden_test_path": "/id/hidden/2191",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 5
    },
    {
        "problem_id": "pointinpolygon2192",
        "topic": "Chương 1",
        "sub_topic": "Geometry",
        "name": "Point in Polygon",
        "description": "You are given a polygon of n vertices and a list of m points. Your task is to determine for each point if it is inside, outside or on the boundary of the polygon.\n\nThe polygon consists of n vertices (x_1,y_1),(x_2,y_2),…,(x_n,y_n) . The vertices (x_i,y_i) and (x_{i+1},y_{i+1}) are adjacent for i=1,2,…,n-1 , and the vertices (x_1,y_1) and (x_n,y_n) are also adjacent.\n\nInput\n\nThe first input line has two integers n and m : the number of vertices in the polygon and the number of points.\n\nAfter this, there are n lines that describe the polygon. The i th such line has two integers x_i and y_i .\n\nYou may assume that the polygon is simple, i.e., it does not intersect itself.\n\nFinally, there are m lines that describe the points. Each line has two integers x and y .\n\nOutput\n\nFor each point, print \"INSIDE\", \"OUTSIDE\" or \"BOUNDARY\".\n\nConstraints\n\n3 ≤ n,m ≤ 1000 1 ≤ m ≤ 1000 -10^9 ≤ x_i, y_i ≤ 10^9 -10^9 ≤ x, y ≤ 10^9\n\nExample\n\nInput:\n\n\n4 3\n1 1\n4 2\n3 5\n1 4\n2 3\n3 1\n1 3\n\n\nOutput:\n\n\nINSIDE\nOUTSIDE\nBOUNDARY",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport math\nfrom typing import List, Tuple\n\nclass Point:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    def __lt__(self, p):\n        return (self.x, self.y) < (p.x, p.y)\n\n    def __eq__(self, p):\n        return (self.x, self.y) == (p.x, p.y)\n\n    def __add__(self, p):\n        return Point(self.x + p.x, self.y + p.y)\n\n    def __sub__(self, p):\n        return Point(self.x - p.x, self.y - p.y)\n\n    def __mul__(self, d):\n        return Point(self.x * d, self.y * d)\n\n    def __truediv__(self, d):\n        return Point(self.x / d, self.y / d)\n\n    def dot(self, p):\n        return self.x * p.x + self.y * p.y\n\n    def cross(self, p):\n        return self.x * p.y - self.y * p.x\n\n    def cross_two(self, a, b):\n        return (a - self).cross(b - self)\n\n    def dist2(self):\n        return self.x * self.x + self.y * self.y\n\n    def dist(self):\n        return math.sqrt(self.dist2())\n\n    def angle(self):\n        return math.atan2(self.y, self.x)\n\n    def unit(self):\n        return self / self.dist()\n\n    def perp(self):\n        return Point(-self.y, self.x)\n\n    def normal(self):\n        return self.perp().unit()\n\n    def rotate(self, a):\n        return Point(self.x * math.cos(a) - self.y * math.sin(a), \n                     self.x * math.sin(a) + self.y * math.cos(a))\n\ndef sgn(x):\n    return (x > 0) - (x < 0)\n\ndef side_of(s, e, p):\n    return sgn(s.cross_two(e, p))\n\ndef side_of_eps(s, e, p, eps):\n    a = (e - s).cross(p - s)\n    l = (e - s).dist() * eps\n    return (a > l) - (a < -l)\n\ndef on_segment(s, e, p):\n    return p.cross(s, e) == 0 and (s - p).dot(e - p) <= 0\n\ndef in_polygon(p: List[Point], a: Point, strict=True):\n    cnt = 0\n    n = len(p)\n    for i in range(n):\n        q = p[(i + 1) % n]\n        if on_segment(p[i], q, a):\n            return not strict\n        cnt ^= ((a.y < p[i].y) - (a.y < q.y)) * a.cross(p[i], q) > 0\n    return cnt\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    n, m = map(int, data[0].split())\n    v = [Point(*map(int, line.split())) for line in data[1:n + 1]]\n    p = [Point(*map(int, line.split())) for line in data[n + 1:n + 1 + m]]\n\n    for point in p:\n        instrict = in_polygon(v, point, True)\n        notstrict = in_polygon(v, point, False)\n        if instrict != notstrict:\n            print(\"BOUNDARY\")\n        elif instrict:\n            print(\"INSIDE\")\n        else:\n            print(\"OUTSIDE\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2192",
        "hidden_test_path": "/id/hidden/2192",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "polygonlatticepoints2193",
        "topic": "Chương 1",
        "sub_topic": "Geometry",
        "name": "Polygon Lattice Points",
        "description": "Given a polygon, your task is to calculate the number of lattice points inside the polygon and on its boundary. A lattice point is a point whose coordinates are integers.\n\nThe polygon consists of n vertices (x_1,y_1),(x_2,y_2),…,(x_n,y_n) . The vertices (x_i,y_i) and (x_{i+1},y_{i+1}) are adjacent for i=1,2,…,n-1 , and the vertices (x_1,y_1) and (x_n,y_n) are also adjacent.\n\nInput\n\nThe first input line has an integer n : the number of vertices.\n\nAfter this, there are n lines that describe the vertices. The i th such line has two integers x_i and y_i .\n\nYou may assume that the polygon is simple, i.e., it does not intersect itself.\n\nOutput\n\nPrint two integers: the number of lattice points inside the polygon and on its boundary.\n\nConstraints\n\n3 ≤ n ≤ 10^5 -10^9 ≤ x_i, y_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4\n1 1\n5 3\n3 5\n1 4\n\n\nOutput:\n\n\n6 8",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport math\nfrom collections import namedtuple\n\nPoint = namedtuple('Point', ['x', 'y'])\n\ndef sgn(x):\n    return (x > 0) - (x < 0)\n\ndef cross(p1, p2):\n    return p1.x * p2.y - p1.y * p2.x\n\ndef polygon_area(v):\n    a = cross(v[-1], v[0])\n    for i in range(len(v) - 1):\n        a += cross(v[i], v[i + 1])\n    return a\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return abs(a)\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    v = []\n    \n    for i in range(1, n + 1):\n        x, y = map(int, data[i].split())\n        v.append(Point(x, y))\n    \n    area = abs(polygon_area(v))\n    boundary = 0\n    \n    for i in range(n):\n        dif = Point(v[(i + 1) % n].x - v[i].x, v[(i + 1) % n].y - v[i].y)\n        boundary += gcd(abs(dif.x), abs(dif.y))\n    \n    interior = (area - boundary + 2) // 2\n    print(interior, boundary)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2193",
        "hidden_test_path": "/id/hidden/2193",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 5
    },
    {
        "problem_id": "minimumeuclideandistance2194",
        "topic": "Chương 1",
        "sub_topic": "Geometry",
        "name": "Minimum Euclidean Distance",
        "description": "Given a set of points in the two-dimensional plane, your task is to find the minimum Euclidean distance between two distinct points.\n\nThe Euclidean distance of points (x_1,y_1) and (x_2,y_2) is √{(x_1-x_2)^2+(y_1-y_2)^2} .\n\nInput\n\nThe first input line has an integer n : the number of points.\n\nAfter this, there are n lines that describe the points. Each line has two integers x and y . You may assume that each point is distinct.\n\nOutput\n\nPrint one integer: d^2 where d is the minimum Euclidean distance (this ensures that the result is an integer).\n\nConstraints\n\n2 ≤ n ≤ 2 · 10^5 -10^9 ≤ x,y ≤ 10^9\n\nExample\n\nInput:\n\n\n4\n2 1\n4 4\n1 2\n6 3\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport math\nfrom typing import List, Tuple\n\nclass Point:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    def __lt__(self, p):\n        return (self.x, self.y) < (p.x, p.y)\n\n    def __eq__(self, p):\n        return (self.x, self.y) == (p.x, p.y)\n\n    def __add__(self, p):\n        return Point(self.x + p.x, self.y + p.y)\n\n    def __sub__(self, p):\n        return Point(self.x - p.x, self.y - p.y)\n\n    def __mul__(self, d):\n        return Point(self.x * d, self.y * d)\n\n    def __truediv__(self, d):\n        return Point(self.x / d, self.y / d)\n\n    def dot(self, p):\n        return self.x * p.x + self.y * p.y\n\n    def cross(self, p):\n        return self.x * p.y - self.y * p.x\n\n    def cross2(self, a, b):\n        return (a - self).cross(b - self)\n\n    def dist2(self):\n        return self.x * self.x + self.y * self.y\n\n    def dist(self):\n        return math.sqrt(self.dist2())\n\n    def angle(self):\n        return math.atan2(self.y, self.x)\n\n    def unit(self):\n        return self / self.dist()\n\n    def perp(self):\n        return Point(-self.y, self.x)\n\n    def normal(self):\n        return self.perp().unit()\n\n    def rotate(self, a):\n        return Point(self.x * math.cos(a) - self.y * math.sin(a), \n                     self.x * math.sin(a) + self.y * math.cos(a))\n\ndef polygon_area(v: List[Point]) -> float:\n    a = v[-1].cross(v[0])\n    for i in range(len(v) - 1):\n        a += v[i].cross(v[i + 1])\n    return a\n\ndef cmp(a: Point, b: Point) -> bool:\n    return a.y < b.y if a.y != b.y else a.x < b.x\n\ndef solve(l: int, r: int, cur: List[Point], byx: List[Point]) -> int:\n    if len(cur) <= 3:\n        best = int(9e18)\n        for p1 in cur:\n            for p2 in cur:\n                if p1 != p2:\n                    best = min(best, (p2 - p1).dist2())\n        return best\n\n    left, right, middle = [], [], []\n    mid = (l + r) // 2\n    x = byx[mid].x\n\n    for p in cur:\n        if p.x == x:\n            middle.append(p)\n        elif p.x < x:\n            left.append(p)\n        else:\n            right.append(p)\n\n    right.reverse()\n    for p in middle:\n        if len(left) * 2 < len(cur):\n            left.append(p)\n        else:\n            right.append(p)\n\n    right.reverse()\n    d = min(solve(l, mid, left, byx), solve(mid + 1, r, right, byx))\n    middle.clear()\n\n    for p in cur:\n        if (p.x - x) * (p.x - x) <= d:\n            middle.append(p)\n\n    for i in range(len(middle)):\n        for j in range(max(0, i - 8), i):\n            d = min(d, (middle[i] - middle[j]).dist2())\n\n    return d\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    byx = []\n    byy = []\n\n    index = 1\n    for _ in range(n):\n        x = int(data[index])\n        y = int(data[index + 1])\n        byx.append(Point(x, y))\n        byy.append(Point(x, y))\n        index += 2\n\n    byx.sort()\n    byy.sort(key=lambda p: (p.y, p.x))\n\n    ans = solve(0, n - 1, byy, byx)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2194",
        "hidden_test_path": "/id/hidden/2194",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 32
    },
    {
        "problem_id": "convexhull2195",
        "topic": "Chương 1",
        "sub_topic": "Geometry",
        "name": "Convex Hull",
        "description": "Given a set of n points in the two-dimensional plane, your task is to determine the convex hull of the points.\n\nInput\n\nThe first input line has an integer n : the number of points.\n\nAfter this, there are n lines that describe the points. Each line has two integers x and y : the coordinates of a point.\n\nYou may assume that each point is distinct, and the area of the hull is positive.\n\nOutput\n\nFirst print an integer k : the number of points in the convex hull.\n\nAfter this, print k lines that describe the points. You can print the points in any order. Print all points that lie on the convex hull.\n\nConstraints\n\n3 ≤ n ≤ 2 · 10^5 -10^9 ≤ x, y ≤ 10^9\n\nExample\n\nInput:\n\n\n6\n2 1\n2 5\n3 3\n4 3\n4 4\n6 3\n\n\nOutput:\n\n\n4\n2 1\n2 5\n4 4\n6 3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport math\nfrom collections import namedtuple\n\nPoint = namedtuple('Point', ['x', 'y'])\n\ndef sgn(x):\n    return (x > 0) - (x < 0)\n\nclass P:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    def __lt__(self, p):\n        return (self.x, self.y) < (p.x, p.y)\n\n    def __eq__(self, p):\n        return (self.x, self.y) == (p.x, p.y)\n\n    def __add__(self, p):\n        return P(self.x + p.x, self.y + p.y)\n\n    def __sub__(self, p):\n        return P(self.x - p.x, self.y - p.y)\n\n    def __mul__(self, d):\n        return P(self.x * d, self.y * d)\n\n    def __truediv__(self, d):\n        return P(self.x / d, self.y / d)\n\n    def dot(self, p):\n        return self.x * p.x + self.y * p.y\n\n    def cross(self, p):\n        return self.x * p.y - self.y * p.x\n\n    def cross2(self, a, b):\n        return (a - self).cross(b - self)\n\n    def dist2(self):\n        return self.x * self.x + self.y * self.y\n\n    def dist(self):\n        return math.sqrt(self.dist2())\n\n    def angle(self):\n        return math.atan2(self.y, self.x)\n\n    def unit(self):\n        return self / self.dist()\n\n    def perp(self):\n        return P(-self.y, self.x)\n\n    def normal(self):\n        return self.perp().unit()\n\n    def rotate(self, a):\n        return P(self.x * math.cos(a) - self.y * math.sin(a), \n                 self.x * math.sin(a) + self.y * math.cos(a))\n\ndef on_segment(s, e, p):\n    return p.cross(s, e) == 0 and (s - p).dot(e - p) <= 0\n\ndef side_of(s, e, p):\n    return sgn(s.cross(e, p))\n\ndef side_of_eps(s, e, p, eps):\n    a = (e - s).cross(p - s)\n    l = (e - s).dist() * eps\n    return (a > l) - (a < -l)\n\ndef convex_hull(pts):\n    if len(pts) <= 1:\n        return pts\n    pts.sort()\n    h = [None] * (len(pts) + 1)\n    s = 0\n    t = 0\n    for _ in range(2):\n        s = --t\n        pts.reverse()\n        for p in pts:\n            while t >= s + 2 and h[t - 2].cross(h[t - 1], p) <= 0:\n                t -= 1\n            h[t] = p\n            t += 1\n    return h[:t - (t == 2 and h[0] == h[1])]\n\ndef in_hull(l, p, strict=True):\n    a = 1\n    b = len(l) - 1\n    r = not strict\n    if len(l) < 3:\n        return r and on_segment(l[0], l[-1], p)\n    if side_of(l[0], l[a], l[b]) > 0:\n        a, b = b, a\n    if side_of(l[0], l[a], p) >= r or side_of(l[0], l[b], p) <= -r:\n        return False\n    while abs(a - b) > 1:\n        c = (a + b) // 2\n        (b if side_of(l[0], l[c], p) > 0 else a) = c\n    return sgn(l[a].cross(l[b], p)) < r\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    n = int(data[0])\n    v = [P(*map(int, line.split())) for line in data[1:n + 1]]\n    res = convex_hull(v)\n    ans = []\n    for i in range(n):\n        if in_hull(res, v[i], False) and not in_hull(res, v[i], True):\n            ans.append(v[i])\n    print(len(ans))\n    for p in ans:\n        print(p.x, p.y)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2195",
        "hidden_test_path": "/id/hidden/2195",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "allmanhattandistances3411",
        "topic": "Chương 1",
        "sub_topic": "Geometry",
        "name": "All Manhattan Distances",
        "description": "Given a set of points, calculate the sum of all Manhattan distances between two point pairs.\n\nInput\n\nThe first line has an integer n : the number of points.\n\nThe following n lines describe the points. Each line has two integers x and y . You can assume that each point is distinct.\n\nOutput\n\nPrint the sum of all Manhattan distances.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 -10^9 ≤ x, y ≤ 10^9\n\nExample\n\nInput:\n\n\n5\n1 1\n3 2\n2 4\n2 1\n4 5\n\n\nOutput:\n\n\n36",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = [[], []]\n    \n    index = 1\n    for i in range(n):\n        for j in range(2):\n            b = int(data[index])\n            a[j].append(b)\n            index += 1\n            \n    ans = 0\n    for it in range(2):\n        a[it].sort()\n        for i in range(len(a[it]) - 1):\n            dx = a[it][i + 1] - a[it][i]\n            ans += dx * (i + 1) * (n - (i + 1))\n    \n    if ans == 0:\n        print(0)\n    else:\n        digs = []\n        while ans:\n            digs.append(ans % 10)\n            ans //= 10\n        digs.reverse()\n        print(''.join(map(str, digs)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3411",
        "hidden_test_path": "/id/hidden/3411",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "intersectionpoints1740",
        "topic": "Chương 1",
        "sub_topic": "Geometry",
        "name": "Intersection Points",
        "description": "Given n horizontal and vertical line segments, your task is to calculate the number of their intersection points.\n\nYou can assume that no parallel line segments intersect, and no endpoint of a line segment is an intersection point.\n\nInput\n\nThe first line has an integer n : the number of line segments.\n\nThen there are n lines describing the line segments. Each line has four integers: x_1 , y_1 , x_2 and y_2 : a line segment begins at point (x_1,y_1) and ends at point (x_2,y_2) .\n\nOutput\n\nPrint the number of intersection points.\n\nConstraints\n\n1 ≤ n ≤ 10^5 -10^6 ≤ x_1 ≤ x_2 ≤ 10^6 -10^6 ≤ y_1 ≤ y_2 ≤ 10^6 (x_1,y_1) ≠ (x_2,y_2)\n\nExample\n\nInput:\n\n\n3\n2 3 7 3\n3 1 3 5\n6 2 6 6\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Node:\n    def __init__(self, lo, hi):\n        self.l = None\n        self.r = None\n        self.lo = lo\n        self.hi = hi\n        self.val = 0\n        self.madd = 0\n\n    def combine(self, l, r):\n        return l + r\n\n    def comb(self):\n        self.val = self.combine(self.l.val, self.r.val)\n\n    def query(self, L, R):\n        if R <= self.lo or self.hi <= L:\n            return 0\n        if L <= self.lo and self.hi <= R:\n            return self.val\n        self.push()\n        return self.combine(self.l.query(L, R), self.r.query(L, R))\n\n    def add(self, L, R, x):\n        if R <= self.lo or self.hi <= L:\n            return\n        if L <= self.lo and self.hi <= R:\n            self.madd += x\n            self.val += x\n        else:\n            self.push()\n            self.l.add(L, R, x)\n            self.r.add(L, R, x)\n            self.comb()\n\n    def push(self):\n        if not self.l:\n            mid = self.lo + (self.hi - self.lo) // 2\n            self.l = Node(self.lo, mid)\n            self.r = Node(mid, self.hi)\n        if self.madd:\n            self.l.add(self.lo, self.hi, self.madd)\n            self.r.add(self.lo, self.hi, self.madd)\n            self.madd = 0\n\n\ndef main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    pts = []\n    ys = set()\n    index = 1\n    for i in range(n):\n        pt = list(map(int, data[index:index + 4]))\n        pts.append(pt)\n        for j in range(4):\n            if j % 2 == 1:\n                ys.add(pt[j])\n        index += 4\n\n    ry = {y: i for i, y in enumerate(sorted(ys))}\n    events = []\n    for i in range(n):\n        pts[i][1] = ry[pts[i][1]]\n        pts[i][3] = ry[pts[i][3]]\n        if pts[i][1] == pts[i][3]:\n            events.append((pts[i][0], 0, i))\n            events.append((pts[i][2], 2, i))\n        else:\n            events.append((pts[i][0], 1, i))\n\n    events.sort()\n    tree = Node(0, len(ry) + 5)\n    ans = 0\n    for x, t, q in events:\n        if t == 0:\n            tree.add(pts[q][1], pts[q][1] + 1, 1)\n        if t == 2:\n            tree.add(pts[q][1], pts[q][1] + 1, -1)\n        if t == 1:\n            ans += tree.query(pts[q][1], pts[q][3] + 1)\n\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1740",
        "hidden_test_path": "/id/hidden/1740",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 5
    },
    {
        "problem_id": "areaofrectangles1741",
        "topic": "Chương 1",
        "sub_topic": "Geometry",
        "name": "Area of Rectangles",
        "description": "Given n rectangles, your task is to determine the total area of their union.\n\nInput\n\nThe first line has an integer n : the number of rectangles.\n\nAfter that, there are n lines describing the rectangles. Each line has four integers x_1 , y_1 , x_2 and y_2 : a rectangle begins at point (x_1,y_1) and ends at point (x_2,y_2) .\n\nOutput\n\nPrint the total area covered by the rectangles.\n\nConstraints\n\n1 ≤ n ≤ 10^5 -10^6 ≤ x_1 < x_2 ≤ 10^6 -10^6 ≤ y_1 < y_2 ≤ 10^6\n\nExample\n\nInput:\n\n\n3\n1 3 4 5\n3 1 7 4\n5 3 8 6\n\n\nOutput:\n\n\n24",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Node:\n    def __init__(self, lo, hi):\n        self.l = None\n        self.r = None\n        self.lo = lo\n        self.hi = hi\n        self.madd = 0\n        if lo + 1 < hi:\n            mid = lo + (hi - lo) // 2\n            self.l = Node(lo, mid)\n            self.r = Node(mid, hi)\n            self.val = self.comb(self.l.val, self.r.val)\n        else:\n            self.val = (0, 1)\n\n    def comb(self, a, b):\n        if a[0] == b[0]:\n            return (a[0], a[1] + b[1])\n        return min(a, b)\n\n    def query(self, L, R):\n        if R <= self.lo or self.hi <= L:\n            return (float('inf'), 0)\n        if L <= self.lo and self.hi <= R:\n            return self.val\n        self.push()\n        return self.comb(self.l.query(L, R), self.r.query(L, R))\n\n    def add(self, L, R, x):\n        if R <= self.lo or self.hi <= L:\n            return\n        if L <= self.lo and self.hi <= R:\n            self.madd += x\n            self.val = (self.val[0] + x, self.val[1])\n        else:\n            self.push()\n            self.l.add(L, R, x)\n            self.r.add(L, R, x)\n            self.val = self.comb(self.l.val, self.r.val)\n\n    def push(self):\n        if self.madd:\n            self.l.add(self.lo, self.hi, self.madd)\n            self.r.add(self.lo, self.hi, self.madd)\n            self.madd = 0\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    rs = []\n    events = []\n    \n    for i in range(1, n + 1):\n        x1, y1, x2, y2 = map(int, data[i].split())\n        x1 += 10**6\n        y1 += 10**6\n        x2 += 10**6\n        y2 += 10**6\n        if (x1, y1) > (x2, y2):\n            x1, y1, x2, y2 = x2, y2, x1, y1\n        rs.append(((x1, y1), (x2, y2)))\n        events.append((x1, y1, y2, 1))\n        events.append((x2, y1, y2, -1))\n    \n    ans = 0\n    events.sort()\n    lim = 2 * 10**6 + 10\n    tree = Node(0, lim)\n    \n    for i in range(len(events) - 1):\n        x, y1, y2, dif = events[i]\n        x1, _y1, _y2, _dif = events[i + 1]\n        dt = x1 - x\n        \n        tree.add(y1, y2, dif)\n        area = lim\n        if tree.val[0] == 0:\n            area -= tree.val[1]\n        ans += area * dt\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1741",
        "hidden_test_path": "/id/hidden/1741",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "robotpath1742",
        "topic": "Chương 1",
        "sub_topic": "Geometry",
        "name": "Robot Path",
        "description": "You are given a description of a robot's path. The robot begins at point (0,0) and performs n commands. Each command moves the robot some distance up, down, left or right.\n\nThe robot will stop when it has performed all commands, or immediately when it returns to a point that it has already visited. Your task is to calculate the total distance the robot moves.\n\nInput\n\nThe first line has an integer n : the number of commands.\n\nAfter that, there are n lines describing the commands. Each line has a character d and an integer x : the robot moves the distance x to the direction d . Each direction is U (up), D (down), L (left), or R (right).\n\nOutput\n\nPrint the total distance the robot moves.\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ x ≤ 10^6\n\nExample\n\nInput:\n\n\n5\nU 2\nR 3\nD 1\nL 5\nU 2\n\n\nOutput:\n\n\n9",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import deque\nfrom bisect import bisect_left\n\nclass Tree:\n    unit = (float('inf'), float('inf'))\n\n    def __init__(self, n=0, def_val=unit):\n        self.s = [def_val] * (2 * n)\n        self.n = n\n\n    def update(self, pos, val):\n        pos += self.n\n        self.s[pos] = val\n        while pos > 1:\n            pos //= 2\n            self.s[pos] = min(self.s[2 * pos], self.s[2 * pos + 1])\n\n    def query(self, b, e):\n        ra = self.unit\n        rb = self.unit\n        b += self.n\n        e += self.n\n        while b < e:\n            if b % 2:\n                ra = min(ra, self.s[b])\n                b += 1\n            if e % 2:\n                e -= 1\n                rb = min(self.s[e], rb)\n            b //= 2\n            e //= 2\n        return min(ra, rb)\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    n = int(data[0])\n    lines = []\n    mxc = 0\n    cs = []\n    ans = float('inf')\n    \n    pos = (0, 0)\n    t = 0\n    dirs = \"UDLR\"\n    pidx = -1\n\n    for i in range(n):\n        c, x = data[i + 1].split()\n        x = int(x)\n        lines.append([pos[0], pos[1], 0, 0, t, 0, x])\n        lines[i][0] = pos[0]\n        lines[i][1] = pos[1]\n        if c == 'U':\n            pos = (pos[0] - (x - 1), pos[1])\n        elif c == 'D':\n            pos = (pos[0] + (x - 1), pos[1])\n        elif c == 'L':\n            pos = (pos[0], pos[1] - (x - 1))\n        else:\n            pos = (pos[0], pos[1] + (x - 1))\n        lines[i][2] = pos[0]\n        lines[i][3] = pos[1]\n        lines[i][4] = t\n        if c == 'U':\n            pos = (pos[0] - 1, pos[1])\n        elif c == 'D':\n            pos = (pos[0] + 1, pos[1])\n        elif c == 'L':\n            pos = (pos[0], pos[1] - 1)\n        else:\n            pos = (pos[0], pos[1] + 1)\n        if i == n - 1:\n            lines[i][2] = pos[0]\n            lines[i][3] = pos[1]\n        nidx = dirs.index(c)\n        if (nidx ^ 1) == pidx:\n            ans = min(ans, t)\n        pidx = nidx\n        t += x\n        if (lines[i][0], lines[i][1]) > (lines[i][2], lines[i][3]):\n            lines[i][0], lines[i][2] = lines[i][2], lines[i][0]\n            lines[i][1], lines[i][3] = lines[i][3], lines[i][1]\n            lines[i][5] ^= 1\n        lines[i][6] = x\n        cs.extend([lines[i][0], lines[i][2], lines[i][1], lines[i][3],\n                   lines[i][0] - 1, lines[i][2] - 1, lines[i][1] - 1, lines[i][3] - 1,\n                   lines[i][0] + 1, lines[i][2] + 1, lines[i][1] + 1, lines[i][3] + 1])\n    \n    if ans == float('inf'):\n        ans = t\n    cs = sorted(set(cs))\n    \n    for i in range(n):\n        r1, c1, r2, c2, start, sw, t = lines[i]\n        lines[i][0] = bisect_left(cs, r1)\n        lines[i][2] = bisect_left(cs, r2)\n        lines[i][1] = bisect_left(cs, c1)\n        lines[i][3] = bisect_left(cs, c2)\n\n    mxc = len(cs)\n\n    for _ in range(2):\n        queries = [[] for _ in range(mxc)]\n        updates = [[] for _ in range(mxc)]\n        use = [0] * n\n\n        for i in range(n):\n            r1, c1, r2, c2, start, sw, t = lines[i]\n            if r1 == r2:\n                queries[r1].append(i)\n            else:\n                updates[r1].append((c1, i))\n                if r2 + 1 < mxc:\n                    updates[r2 + 1].append((c1, i))\n\n        tree = Tree(mxc)\n        pqs = [deque() for _ in range(mxc)]\n\n        for r in range(mxc):\n            for c, i in updates[r]:\n                use[i] ^= 1\n                if not use[i]:\n                    while pqs[c] and not use[pqs[c][0][1]]:\n                        pqs[c].popleft()\n                else:\n                    pqs[c].append((lines[i][4], i))\n                tree.update(c, pqs[c][0] if pqs[c] else tree.unit)\n\n            for i1 in queries[r]:\n                r1, c1, r2, c2, start, sw, t = lines[i1]\n                t2, i2 = tree.query(c1, c2 + 1)\n                if t2 == float('inf'):\n                    continue\n                c = lines[i2][1]\n                cand1 = start + abs(cs[c2 if sw else c1] - cs[c])\n                cand2 = lines[i2][4] + abs(cs[lines[i2][1 if lines[i2][5] else 0]] - cs[r1])\n                ans = min(ans, max(cand1, cand2))\n\n            updates[r].clear()\n\n        for i in range(n):\n            use[i] = 0\n            r1, c1, r2, c2, start, sw, t = lines[i]\n            if r1 == r2:\n                updates[r1].append((c1, i))\n                updates[r1].append((c2 + 1, -i))\n\n        for r in range(mxc):\n            updates[r].sort()\n            pq = set()\n            for c, i in updates[r]:\n                if i < 0:\n                    i = -i\n                r1, c1, r2, c2, start, sw, t = lines[i]\n                use[i] ^= 1\n                curc = c + (0 if use[i] else -1)\n                if not use[i]:\n                    pq.discard((lines[i][4], i))\n                if pq:\n                    t2, i2 = min(pq)\n                    cand1 = start + abs(cs[c2 if sw else c1] - cs[curc])\n                    cand2 = lines[i2][4] + abs(cs[lines[i2][1 if lines[i2][5] else 0]] - cs[curc])\n                    ans = min(ans, max(cand1, cand2))\n                if use[i]:\n                    pq.add((lines[i][4], i))\n\n        for i in range(n):\n            lines[i][0], lines[i][1] = lines[i][1], lines[i][0]\n            lines[i][2], lines[i][3] = lines[i][3], lines[i][2]\n            if (lines[i][0], lines[i][1]) > (lines[i][2], lines[i][3]):\n                lines[i][0], lines[i][2] = lines[i][2], lines[i][0]\n                lines[i][1], lines[i][3] = lines[i][3], lines[i][1]\n                lines[i][5] ^= 1\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1742",
        "hidden_test_path": "/id/hidden/1742",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 37
    },
    {
        "problem_id": "meetinthemiddle1628",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Meet in the Middle",
        "description": "You are given an array of n numbers. In how many ways can you choose a subset of the numbers with sum x ?\n\nInput\n\nThe first input line has two numbers n and x : the array size and the required sum.\n\nThe second line has n integers t_1,t_2,…,t_n : the numbers in the array.\n\nOutput\n\nPrint the number of ways you can create the sum x .\n\nConstraints\n\n1 ≤ n ≤ 40 1 ≤ x ≤ 10^9 1 ≤ t_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4 5\n1 2 3 2\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    from itertools import combinations\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = int(data[1])\n    a = list(map(int, data[2:n+2]))\n\n    b = [a[:n//2], a[n//2:]]\n    sums = [[], []]\n    sp = [[], []]\n\n    for i in range(2):\n        k = len(b[i])\n        for j in range(1 << k):\n            sum_val = sum(b[i][l] for l in range(k) if j & (1 << l))\n            sums[i].append(sum_val)\n        \n        sums[i].sort()\n        j = 0\n        while j < len(sums[i]):\n            cnt = 1\n            j += 1\n            while j < len(sums[i]) and sums[i][j] == sums[i][j - 1]:\n                cnt += 1\n                j += 1\n            sp[i].append((sums[i][j - 1], cnt))\n\n    sp[1].reverse()\n\n    ans = 0\n    idx = 0\n    for sum_val, freq in sp[0]:\n        while idx < len(sp[1]) and sum_val + sp[1][idx][0] > x:\n            idx += 1\n        if idx < len(sp[1]) and sp[1][idx][0] + sum_val == x:\n            ans += freq * sp[1][idx][1]\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1628",
        "hidden_test_path": "/id/hidden/1628",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 40
    },
    {
        "problem_id": "hammingdistance2136",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Hamming Distance",
        "description": "The Hamming distance between two strings a and b of equal length is the number of positions where the strings differ.\n\nYou are given n bit strings, each of length k and your task is to calculate the minimum Hamming distance between two strings.\n\nInput\n\nThe first input line has two integers n and k : the number of bit strings and their length.\n\nThen there are n lines each consisting of one bit string of length k .\n\nOutput\n\nPrint the minimum Hamming distance between two strings.\n\nConstraints\n\n2 ≤ n ≤ 2 · 10^4 1 ≤ k ≤ 30\n\nExample\n\nInput:\n\n\n5 6\n110111\n001000\n100001\n101000\n101110\n\n\nOutput:\n\n\n1\n\n\nExplanation: The strings 101000 and 001000 differ only at the first position.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    a = [int(data[i + 2], 2) for i in range(n)]\n    \n    ans = k\n    for i in range(n):\n        for j in range(i):\n            ans = min(ans, bin(a[i] ^ a[j]).count('1'))\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2136",
        "hidden_test_path": "/id/hidden/2136",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "cornersubgridcheck3360",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Corner Subgrid Check",
        "description": "You are given a grid of letters. Your task is to find subgrids whose height and width is at least two and all the corners have the same letter.\n\nFor each letter, check if there is a valid subgrid whose corners have that letter.\n\nInput\n\nThe first line has two integers n and k : the size of the grid and the number of letters. The letters are the first k uppercase letters.\n\nAfter this, there are n lines that describe the grid. Each line has n letters.\n\nOutput\n\nPrint k lines: for each letter, YES if there is a valid subgrid and NO otherwise.\n\nConstraints\n\n1 ≤ n ≤ 3000 1 ≤ k ≤ 26\n\nExample\n\nInput:\n\n\n4 5\nAAAA\nCBBC\nCBBE\nAAAA\n\n\nOutput:\n\n\nYES\nYES\nNO\nNO\nNO",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    k = int(data[1])\n    grid = data[2:n+2]\n    has = [[0] * n for _ in range(n)]\n    made = [0] * k\n    \n    for i in range(n):\n        bucket = [[] for _ in range(k)]\n        for j in range(n):\n            bucket[ord(grid[i][j]) - ord('A')].append(j)\n        \n        for j in range(k):\n            if made[j]: \n                continue\n            for a in range(len(bucket[j])):\n                for b in range(a + 1, len(bucket[j])):\n                    l = bucket[j][a]\n                    r = bucket[j][b]\n                    if (has[l][r] >> j) & 1:\n                        made[j] = 1\n                        break\n                if made[j]:\n                    break\n            \n            for a in range(len(bucket[j])):\n                for b in range(a + 1, len(bucket[j])):\n                    l = bucket[j][a]\n                    r = bucket[j][b]\n                    has[l][r] |= 1 << j\n    \n    for i in range(k):\n        print(\"YES\" if made[i] else \"NO\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3360",
        "hidden_test_path": "/id/hidden/3360",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 9
    },
    {
        "problem_id": "reachablenodes2138",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Reachable Nodes",
        "description": "A directed acyclic graph consists of n nodes and m edges. The nodes are numbered 1,2,…,n .\n\nCalculate for each node the number of nodes you can reach from that node (including the node itself).\n\nInput\n\nThe first input line has two integers n and m : the number of nodes and edges.\n\nThen there are m lines describing the edges. Each line has two distinct integers a and b : there is an edge from node a to node b .\n\nOutput\n\nPrint n integers: for each node the number of reachable nodes.\n\nConstraints\n\n1 ≤ n ≤ 5 · 10^4 1 ≤ m ≤ 10^5\n\nExample\n\nInput:\n\n\n5 6\n1 2\n1 3\n1 4\n2 3\n3 5\n4 5\n\n\nOutput:\n\n\n5 3 2 2 1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from sys import stdin, stdout\nfrom collections import defaultdict\n\nmaxn = 50002\n\ndef main():\n    input = stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    adj = defaultdict(list)\n    index = 2\n    for _ in range(m):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        adj[a].append(b)\n        index += 2\n    \n    ans = [0] * n\n    \n    def dfs(cur):\n        if ans[cur] != 0:\n            return ans[cur]\n        ans[cur] = 1 << cur\n        for nex in adj[cur]:\n            ans[cur] |= dfs(nex)\n        return ans[cur]\n    \n    result = []\n    for i in range(n):\n        result.append(bin(dfs(i)).count('1'))\n    \n    stdout.write(\" \".join(map(str, result)) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2138",
        "hidden_test_path": "/id/hidden/2138",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "reachabilityqueries2143",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Reachability Queries",
        "description": "A directed graph consists of n nodes and m edges. The edges are numbered 1,2,…,n .\n\nYour task is to answer q queries of the form \"can you reach node b from node a ?\"\n\nInput\n\nThe first input line has three integers n , m and q : the number of nodes, edges and queries.\n\nThen there are m lines describing the edges. Each line has two distinct integers a and b : there is an edge from node a to node b .\n\nFinally there are q lines describing the queries. Each line consists of two integers a and b : \"can you reach node b from node a ?\"\n\nOutput\n\nPrint the answer for each query: either \"YES\" or \"NO\".\n\nConstraints\n\n1 ≤ n ≤ 5 · 10^4 1 ≤ m,q ≤ 10^5\n\nExample\n\nInput:\n\n\n4 4 3\n1 2\n2 3\n3 1\n4 3\n1 3\n1 4\n4 1\n\n\nOutput:\n\n\nYES\nNO\nYES",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\n\nmaxn = 50002\n\nval = []\ncomp = []\nz = []\ncont = []\nTime = 0\nncomps = 0\n\ndef dfs(j, g, f):\n    global Time, ncomps\n    low = val[j] = Time + 1\n    Time += 1\n    z.append(j)\n    for e in g[j]:\n        if comp[e] < 0:\n            low = min(low, val[e] if val[e] != 0 else dfs(e, g, f))\n\n    if low == val[j]:\n        while True:\n            x = z.pop()\n            comp[x] = ncomps\n            cont.append(x)\n            if x == j:\n                break\n        f(cont)\n        cont.clear()\n        ncomps += 1\n    return val[j] = low\n\ndef scc(g, f):\n    global val, comp, Time, ncomps\n    n = len(g)\n    val = [0] * n\n    comp = [-1] * n\n    Time = ncomps = 0\n    for i in range(n):\n        if comp[i] < 0:\n            dfs(i, g, f)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    q = int(data[idx])\n    idx += 1\n    \n    adj = defaultdict(list)\n    for _ in range(m):\n        a = int(data[idx]) - 1\n        idx += 1\n        b = int(data[idx]) - 1\n        idx += 1\n        adj[a].append(b)\n\n    sccs = []\n    scc(adj, lambda val: sccs.append(val))\n    \n    rev = [0] * n\n    for i in range(len(sccs)):\n        for j in sccs[i]:\n            rev[j] = i\n\n    ans = [set() for _ in range(len(sccs))]\n\n    def dfs(cur):\n        if cur in ans[cur]:\n            return ans[cur]\n        ans[cur].add(cur)\n        for i in sccs[cur]:\n            for nex in adj[i]:\n                if rev[nex] != cur:\n                    ans[cur] |= dfs(rev[nex])\n        return ans[cur]\n\n    for i in range(len(sccs)):\n        dfs(i)\n\n    output = []\n    for _ in range(q):\n        a = int(data[idx]) - 1\n        idx += 1\n        b = int(data[idx]) - 1\n        idx += 1\n        output.append(\"YES\" if rev[b] in ans[rev[a]] else \"NO\")\n\n    print(\"\\n\".join(output))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2143",
        "hidden_test_path": "/id/hidden/2143",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "cutandpaste2072",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Cut and Paste",
        "description": "Given a string, your task is to process operations where you cut a substring and paste it to the end of the string. What is the final string after all the operations?\n\nInput\n\nThe first input line has two integers n and m : the length of the string and the number of operations. The characters of the string are numbered 1,2,…,n .\n\nThe next line has a string of length n that consists of characters A–Z.\n\nFinally, there are m lines that describe the operations. Each line has two integers a and b : you cut a substring from position a to position b .\n\nOutput\n\nPrint the final string after all the operations.\n\nConstraints\n\n1 ≤ n, m ≤ 2 · 10^5 1 ≤ a ≤ b ≤ n\n\nExample\n\nInput:\n\n\n7 2\nAYBABTU\n3 5\n3 5\n\n\nOutput:\n\n\nAYABTUB",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import random\nfrom typing import Optional, Tuple, List\n\nclass Node:\n    def __init__(self, val: int):\n        self.l: Optional[Node] = None\n        self.r: Optional[Node] = None\n        self.val = val\n        self.y = random.randint(0, 2**30)\n        self.c = 1\n\n    def recalc(self):\n        self.c = cnt(self.l) + cnt(self.r) + 1\n\ndef cnt(n: Optional[Node]) -> int:\n    return n.c if n else 0\n\ndef each(n: Optional[Node], f):\n    if n:\n        each(n.l, f)\n        f(n.val)\n        each(n.r, f)\n\ndef split(n: Optional[Node], k: int) -> Tuple[Optional[Node], Optional[Node]]:\n    if not n:\n        return None, None\n    if cnt(n.l) >= k:\n        pa = split(n.l, k)\n        n.l = pa[1]\n        n.recalc()\n        return pa[0], n\n    else:\n        pa = split(n.r, k - cnt(n.l) - 1)\n        n.r = pa[0]\n        n.recalc()\n        return n, pa[1]\n\ndef merge(l: Optional[Node], r: Optional[Node]) -> Optional[Node]:\n    if not l:\n        return r\n    if not r:\n        return l\n    if l.y > r.y:\n        l.r = merge(l.r, r)\n        l.recalc()\n        return l\n    else:\n        r.l = merge(l, r.l)\n        r.recalc()\n        return r\n\ndef ins(t: Optional[Node], n: Node, pos: int) -> Optional[Node]:\n    pa = split(t, pos)\n    return merge(merge(pa[0], n), pa[1])\n\ndef move(t: Optional[Node], l: int, r: int, k: int) -> Optional[Node]:\n    a, b = split(t, l)\n    b, c = split(b, r - l)\n    if k <= l:\n        return merge(ins(a, b, k), c)\n    else:\n        return merge(a, ins(c, b, k - r))\n\ndef dfs(cur: Optional[Node], f):\n    if cur is None:\n        return\n    dfs(cur.l, f)\n    f(cur.val)\n    dfs(cur.r, f)\n\ndef main():\n    n, m = map(int, input().split())\n    treap = None\n    str_input = input().strip()\n    \n    for i in range(n):\n        treap = merge(treap, Node(ord(str_input[i]) - ord('A')))\n    \n    for _ in range(m):\n        a, b = map(int, input().split())\n        a -= 1\n        b -= 1\n        treap = move(treap, a, b + 1, n)\n    \n    result = []\n    dfs(treap, lambda val: result.append(chr(val + ord('A'))))\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2072",
        "hidden_test_path": "/id/hidden/2072",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "substringreversals2073",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Substring Reversals",
        "description": "Given a string, your task is to process operations where you reverse a substring of the string. What is the final string after all the operations?\n\nInput\n\nThe first input line has two integers n and m : the length of the string and the number of operations. The characters of the string are numbered 1,2,…,n .\n\nThe next line has a string of length n that consists of characters A–Z.\n\nFinally, there are m lines that describe the operations. Each line has two integers a and b : you reverse a substring from position a to position b .\n\nOutput\n\nPrint the final string after all the operations.\n\nConstraints\n\n1 ≤ n, m ≤ 2 · 10^5 1 ≤ a ≤ b ≤ n\n\nExample\n\nInput:\n\n\n7 2\nAYBABTU\n3 4\n4 7\n\n\nOutput:\n\n\nAYAUTBB",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import random\n\nclass Node:\n    def __init__(self, val):\n        self.l = None\n        self.r = None\n        self.val = val\n        self.y = random.randint(0, 2**30)\n        self.c = 1\n        self.rev = False\n\n    def recalc(self):\n        self.c = cnt(self.l) + cnt(self.r) + 1\n\n    def push(self):\n        if self.rev:\n            self.rev = False\n            if self.l:\n                self.tag(self.l)\n            if self.r:\n                self.tag(self.r)\n\n    def tag(self):\n        self.rev = not self.rev\n        self.l, self.r = self.r, self.l\n\ndef cnt(n):\n    return n.c if n else 0\n\ndef each(n, f):\n    if n:\n        n.push()\n        each(n.l, f)\n        f(n.val)\n        each(n.r, f)\n\ndef split(n, k):\n    if not n:\n        return None, None\n    n.push()\n    if cnt(n.l) >= k:\n        pa = split(n.l, k)\n        n.l = pa[1]\n        n.recalc()\n        return pa[0], n\n    else:\n        pa = split(n.r, k - cnt(n.l) - 1)\n        n.r = pa[0]\n        n.recalc()\n        return n, pa[1]\n\ndef merge(l, r):\n    if not l:\n        return r\n    if not r:\n        return l\n    l.push()\n    r.push()\n    if l.y > r.y:\n        l.r = merge(l.r, r)\n        l.recalc()\n        return l\n    else:\n        r.l = merge(l, r.l)\n        r.recalc()\n        return r\n\ndef ins(t, n, pos):\n    pa = split(t, pos)\n    return merge(merge(pa[0], n), pa[1])\n\ndef move(t, l, r, k):\n    a, b, c = split(t, l), split(b, r - l)\n    if k <= l:\n        t = merge(ins(a, b, k), c)\n    else:\n        t = merge(a, ins(c, b, k - r))\n\ndef rev(t, l, r):\n    a, b, c = split(t, l), split(b, r - l)\n    b.tag()\n    t = merge(merge(a, b), c)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    str_input = data[2]\n    \n    treap = None\n    for i in range(n):\n        treap = merge(treap, Node(ord(str_input[i]) - ord('A')))\n    \n    for i in range(m):\n        a = int(data[3 + 2 * i]) - 1\n        b = int(data[4 + 2 * i]) - 1\n        rev(treap, a, b + 1)\n\n    def dfs(cur):\n        if cur is None:\n            return\n        cur.push()\n        dfs(cur.l)\n        print(chr(cur.val + ord('A')), end='')\n        dfs(cur.r)\n\n    dfs(treap)\n    print()\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2073",
        "hidden_test_path": "/id/hidden/2073",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "reversalsandsums2074",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Reversals and Sums",
        "description": "Given an array of n integers, you have to process following operations:\n\nreverse a subarray calculate the sum of values in a subarray\n\nInput\n\nThe first input line has two integers n and m : the size of the array and the number of operations. The array elements are numbered 1,2,…,n .\n\nThe next line as n integers x_1,x_2,…,x_n : the contents of the array.\n\nFinally, there are m lines that describe the operations. Each line has three integers t , a and b . If t=1 , you should reverse a subarray from a to b . If t=2 , you should calculate the sum of values from a to b .\n\nOutput\n\nPrint the answer to each operation where t=2 .\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ m ≤ 10^5 0 ≤ x_i ≤ 10^9 1 ≤ a ≤ b ≤ n\n\nExample\n\nInput:\n\n\n8 3\n2 1 3 4 5 3 4 4\n2 2 4\n1 3 6\n2 2 4\n\n\nOutput:\n\n\n8\n9",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import random\n\nclass Node:\n    def __init__(self, val):\n        self.l = None\n        self.r = None\n        self.val = val\n        self.y = random.randint(0, 2**30)\n        self.c = 1\n        self.sum = val\n        self.rev = False\n\n    def recalc(self):\n        self.c = cnt(self.l) + cnt(self.r) + 1\n        self.sum = sumf(self.l) + sumf(self.r) + self.val\n\n    def push(self):\n        if not self.rev:\n            return\n        if self.l:\n            self.l.rev ^= True\n            self.l.l, self.l.r = self.l.r, self.l.l\n        if self.r:\n            self.r.rev ^= True\n            self.r.l, self.r.r = self.r.r, self.r.l\n        self.rev = False\n\ndef cnt(n):\n    return n.c if n else 0\n\ndef sumf(n):\n    return n.sum if n else 0\n\ndef each(n, f):\n    if n:\n        each(n.l, f)\n        f(n.val)\n        each(n.r, f)\n\ndef split(n, k):\n    if not n:\n        return None, None\n    n.push()\n    if cnt(n.l) >= k:\n        pa = split(n.l, k)\n        n.l = pa[1]\n        n.recalc()\n        return pa[0], n\n    else:\n        pa = split(n.r, k - cnt(n.l) - 1)\n        n.r = pa[0]\n        n.recalc()\n        return n, pa[1]\n\ndef merge(l, r):\n    if not l:\n        return r\n    if not r:\n        return l\n    l.push()\n    r.push()\n    if l.y > r.y:\n        l.r = merge(l.r, r)\n        l.recalc()\n        return l\n    else:\n        r.l = merge(l, r.l)\n        r.recalc()\n        return r\n\ndef ins(t, n, pos):\n    pa = split(t, pos)\n    return merge(merge(pa[0], n), pa[1])\n\ndef move(t, l, r, k):\n    a, b = split(t, l)\n    b, c = split(b, r - l)\n    if k <= l:\n        t = merge(ins(a, b, k), c)\n    else:\n        t = merge(a, ins(c, b, k - r))\n\ndef rev(t, l, r):\n    a, b = split(t, l)\n    b, c = split(b, r - l)\n    b.rev ^= True\n    b.l, b.r = b.r, b.l\n    t = merge(merge(a, b), c)\n\ndef getsum(t, l, r):\n    a, b = split(t, l)\n    b, c = split(b, r - l)\n    v = b.sum\n    t = merge(merge(a, b), c)\n    return v\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    m = int(data[idx + 1])\n    idx += 2\n    \n    treap = None\n    for _ in range(n):\n        k = int(data[idx])\n        treap = merge(treap, Node(k))\n        idx += 1\n    \n    for _ in range(m):\n        t = int(data[idx])\n        a = int(data[idx + 1]) - 1\n        b = int(data[idx + 2]) - 1\n        idx += 3\n        if t == 1:\n            rev(treap, a, b + 1)\n        else:\n            print(getsum(treap, a, b + 1))",
        "public_test_path": "/id/public/2074",
        "hidden_test_path": "/id/hidden/2074",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 5
    },
    {
        "problem_id": "necessaryroads2076",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Necessary Roads",
        "description": "There are n cities and m roads between them. There is a route between any two cities.\n\nA road is called necessary if there is no route between some two cities after removing that road. Your task is to find all necessary roads.\n\nInput\n\nThe first input line has two integers n and m : the number of cities and roads. The cities are numbered 1,2,…,n .\n\nAfter this, there are m lines that describe the roads. Each line has two integers a and b : there is a road between cities a and b . There is at most one road between two cities, and every road connects two distinct cities.\n\nOutput\n\nFirst print an integer k : the number of necessary roads. After that, print k lines that describe the roads. You may print the roads in any order.\n\nConstraints\n\n2 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 5\n1 2\n1 4\n2 4\n3 5\n4 5\n\n\nOutput:\n\n\n2\n3 5\n4 5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\n\nnum = []\nst = []\ned = []\nbridges = []\nTime = 0\n\ndef dfs(at, par, f):\n    global Time\n    me = num[at] = Time + 1\n    top = me\n    for y, e in ed[at]:\n        if e != par:\n            if num[y]:\n                top = min(top, num[y])\n                if num[y] < me:\n                    st.append(e)\n            else:\n                si = len(st)\n                up = dfs(y, e, f)\n                top = min(top, up)\n                if up == me:\n                    st.append(e)\n                    f(st[si:])\n                    st = st[:si]\n                elif up < me:\n                    st.append(e)\n                else:\n                    bridges.append(e)\n    return top\n\ndef bicomps(f):\n    global num\n    num = [0] * len(ed)\n    for i in range(len(ed)):\n        if not num[i]:\n            dfs(i, -1, f)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m = map(int, data[0].split())\n    g = defaultdict(list)\n    edges = []\n    \n    for i in range(1, m + 1):\n        a, b = map(int, data[i].split())\n        edges.append((a, b))\n        a -= 1\n        b -= 1\n        g[a].append((b, i - 1))\n        g[b].append((a, i - 1))\n    \n    global ed\n    ed = g\n    bicomps(lambda stuff: None)\n    \n    print(len(bridges))\n    for i in bridges:\n        print(edges[i][0], edges[i][1])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2076",
        "hidden_test_path": "/id/hidden/2076",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 5
    },
    {
        "problem_id": "necessarycities2077",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Necessary Cities",
        "description": "There are n cities and m roads between them. There is a route between any two cities.\n\nA city is called necessary if there is no route between some other two cities after removing that city (and adjacent roads). Your task is to find all necessary cities.\n\nInput\n\nThe first input line has two integers n and m : the number of cities and roads. The cities are numbered 1,2,…,n .\n\nAfter this, there are m lines that describe the roads. Each line has two integers a and b : there is a road between cities a and b . There is at most one road between two cities, and every road connects two distinct cities.\n\nOutput\n\nFirst print an integer k : the number of necessary cities. After that, print a list of k cities. You may print the cities in any order.\n\nConstraints\n\n2 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 5\n1 2\n1 4\n2 4\n3 5\n4 5\n\n\nOutput:\n\n\n2\n4 5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\n\nnum = []\nst = []\ned = []\nbridges = []\nTime = 0\n\ndef dfs(at, par, f):\n    global Time\n    me = num[at] = Time + 1\n    e, y, top = 0, 0, me\n    numchild = 0\n    isart = False\n    for pa in ed[at]:\n        if pa[1] != par:\n            y, e = pa\n            if num[y]:\n                top = min(top, num[y])\n                if num[y] < me:\n                    st.append(e)\n            else:\n                numchild += 1\n                si = len(st)\n                up = dfs(y, e, f)\n                top = min(top, up)\n                if up >= me:\n                    isart = True\n                if up == me:\n                    st.append(e)\n                    st = st[:si]\n                elif up < me:\n                    st.append(e)\n                else:\n                    bridges.append(e)\n    if isart and (at != 0 or numchild > 1):\n        f(at)\n    return top\n\ndef bicomps(f):\n    global num\n    num = [0] * len(ed)\n    for i in range(len(ed)):\n        if not num[i]:\n            dfs(i, -1, f)\n\ndef main():\n    global ed, Time\n    n, m = map(int, input().split())\n    g = [[] for _ in range(n)]\n    edges = []\n    for i in range(m):\n        a, b = map(int, input().split())\n        edges.append((a, b))\n        a -= 1\n        b -= 1\n        g[a].append((b, i))\n        g[b].append((a, i))\n    ed = g\n    artpoints = [False] * n\n    numpts = 0\n    bicomps(lambda stuff: (setattr(artpoints, stuff, True), setattr(numpts, 'num', numpts + 1)))\n    print(numpts)\n    for i in range(n):\n        if artpoints[i]:\n            print(i + 1, end=\" \")\n    print()\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2077",
        "hidden_test_path": "/id/hidden/2077",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "subarraysquares2086",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Subarray Squares",
        "description": "Given an array of n elements, your task is to divide into k subarrays. The cost of each subarray is the square of the sum of the values in the subarray. What is the minimum total cost if you act optimally?\n\nInput\n\nThe first input line has two integers n and k : the array elements and the number of subarrays. The array elements are numbered 1,2,…,n .\n\nThe second line has n integers x_1,x_2,…,x_n : the contents of the array.\n\nOutput\n\nPrint one integer: the minimum total cost.\n\nConstraints\n\n1 ≤ k ≤ n ≤ 3000 1 ≤ x_i ≤ 10^5\n\nExample\n\nInput:\n\n\n8 3\n2 3 1 2 2 3 4 1\n\n\nOutput:\n\n\n110\n\n\nExplanation: An optimal solution is [2,3,1] , [2,2,3] , [4,1] , whose cost is (2+3+1)^2+(2+2+3)^2+(4+1)^2=110 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import namedtuple\nimport math\n\ninput = sys.stdin.read\nINT_MIN = -math.inf\nINT_MAX = math.inf\n\ndp = [[0] * 3001 for _ in range(3001)]\nres = [[(0, 0)] * 3001 for _ in range(3001)]\npref = [0] * 3001\nx = [0] * 3001\n\nclass DP:\n    def __init__(self, l):\n        self.layer = l\n\n    def lo(self, ind):\n        return 0\n\n    def hi(self, ind):\n        return 1 if self.layer == 1 else ind\n\n    def f(self, ind, k):\n        return dp[self.layer - 1][k] + (pref[ind] - pref[k]) ** 2\n\n    def store(self, ind, k, v):\n        res[self.layer][ind] = (k, v)\n        dp[self.layer][ind] = v\n\n    def rec(self, L, R, LO, HI):\n        if L >= R:\n            return\n        mid = (L + R) // 2\n        best = (float('inf'), LO)\n        for k in range(max(LO, self.lo(mid)), min(HI, self.hi(mid))):\n            best = min(best, (self.f(mid, k), k))\n        self.store(mid, best[1], best[0])\n        self.rec(L, mid, LO, best[1] + 1)\n        self.rec(mid + 1, R, best[1], HI)\n\n    def solve(self, L, R):\n        self.rec(L, R, INT_MIN, INT_MAX)\n\ndef main():\n    n, k = map(int, input().split())\n    for i in range(1, n + 1):\n        x[i] = int(input())\n        pref[i] = x[i] + pref[i - 1]\n\n    d = []\n    for i in range(k + 1):\n        d.append(DP(i))\n        if i:\n            d[-1].solve(1, n + 1)\n\n    print(dp[k][n])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2086",
        "hidden_test_path": "/id/hidden/2086",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "housesandschools2087",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Houses and Schools",
        "description": "There are n houses on a street, numbered 1,2,…,n . The distance of houses a and b is |a-b| . You know the number of children in each house.\n\nYour task is to establish k schools in such a way that each school is in some house. Then, each child goes to the nearest school. What is the minimum total walking distance of the children if you act optimally?\n\nInput\n\nThe first input line has two integers n and k : the number of houses and the number of schools. The houses are numbered 1,2…,n .\n\nAfter this, there are n integers c_1,c_2,…,c_n : the number of children in each house.\n\nOutput\n\nPrint the minimum total distance.\n\nConstraints\n\n1 ≤ k ≤ n ≤ 3000 1 ≤ c_i ≤ 10^9\n\nExample\n\nInput:\n\n\n6 2\n2 7 1 4 6 4\n\n\nOutput:\n\n\n11\n\n\nExplanation: Houses 2 and 5 will have schools.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import defaultdict\nimport itertools\n\ninput = sys.stdin.read\ndata = input().split()\n\nll = int\nld = float\npi = tuple\npl = tuple\npd = tuple\nvi = list\nvl = list\nvd = list\nvpi = list\nvpl = list\nvpd = list\nvvi = list\n\ndp = [[0] * 3001 for _ in range(3001)]\nres = [[(0, 0)] * 3001 for _ in range(3001)]\ncost = [[0] * 3001 for _ in range(3001)]\n\nclass DP:\n    def __init__(self, l):\n        self.layer = l\n\n    def lo(self, ind):\n        return 0\n\n    def hi(self, ind):\n        return 1 if self.layer == 1 else ind\n\n    def f(self, ind, k):\n        return dp[self.layer - 1][k] + cost[k + 1][ind]\n\n    def store(self, ind, k, v):\n        res[self.layer][ind] = (k, v)\n        dp[self.layer][ind] = v\n\n    def rec(self, L, R, LO, HI):\n        if L >= R:\n            return\n        mid = (L + R) // 2\n        best = (float('inf'), LO)\n        for k in range(max(LO, self.lo(mid)), min(HI, self.hi(mid))):\n            best = min(best, (self.f(mid, k), k))\n        self.store(mid, best[1], best[0])\n        self.rec(L, mid, LO, best[1] + 1)\n        self.rec(mid + 1, R, best[1], HI)\n\n    def solve(self, L, R):\n        self.rec(L, R, float('-inf'), float('inf'))\n\ndef main():\n    n, k = map(int, data[:2])\n    c = [0] * (n + 1)\n    for i in range(1, n + 1):\n        c[i] = int(data[i])\n\n    prefs = [0] * (n + 1)\n    suffs = [0] * (n + 1)\n    pref = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        pref[i] = pref[i - 1] + c[i]\n        prefs[i] = prefs[i - 1] + i * c[i]\n\n    for i in range(n, -1, -1):\n        if i + 1 <= n:\n            suffs[i] += suffs[i + 1]\n        suffs[i] += (n - i) * c[i]\n\n    for i in range(1, n + 1):\n        sum_ = 0\n        median = i - 1\n        left = 0\n        for j in range(i, n + 1):\n            sum_ += c[j]\n            while left < sum_ - left:\n                median += 1\n                left += c[median]\n            assert median <= j\n            leftside = suffs[i] - (suffs[median + 1] if median + 1 <= n else 0) - (n - median) * left\n            rightside = prefs[j] - (prefs[median - 1] if median - 1 >= 0 else 0) - median * (sum_ - left + c[median])\n            cost[i][j] = leftside + rightside\n\n    d = []\n    for i in range(k + 1):\n        d.append(DP(i))\n        if i:\n            d[-1].solve(1, n + 1)\n\n    print(dp[k][n])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2087",
        "hidden_test_path": "/id/hidden/2087",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "knuthdivision2088",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Knuth Division",
        "description": "Given an array of n numbers, your task is to divide it into n subarrays, each of which has a single element.\n\nOn each move, you may choose any subarray and split it into two subarrays. The cost of such a move is the sum of values in the chosen subarray.\n\nWhat is the minimum total cost if you act optimally?\n\nInput\n\nThe first input line has an integer n : the array size. The array elements are numbered 1,2,…,n .\n\nThe second line has n integers x_1,x_2,…,x_n : the contents of the array.\n\nOutput\n\nPrint one integer: the minimum total cost.\n\nConstraints\n\n1 ≤ n ≤ 5000 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5\n2 7 3 2 5\n\n\nOutput:\n\n\n43",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom itertools import accumulate\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:n + 1]))\n\nmaxn = 5005\ndp = [[0] * maxn for _ in range(maxn)]\nopt = [[0] * maxn for _ in range(maxn)]\n\nfor i in range(n):\n    opt[i][i] = i\n\nfor i in range(n - 1, -1, -1):\n    psum = a[i]\n    for j in range(i + 1, n):\n        psum += a[j]\n        left = opt[i][j - 1]\n        right = opt[i + 1][j]\n        best = left\n        for k in range(left, min(j - 1, right) + 1):\n            if dp[i][k] + dp[k + 1][j] < dp[i][best] + dp[best + 1][j]:\n                best = k\n        opt[i][j] = best\n        dp[i][j] = psum + dp[i][best] + dp[best + 1][j]\n\nprint(dp[0][n - 1])",
        "public_test_path": "/id/public/2088",
        "hidden_test_path": "/id/hidden/2088",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 3
    },
    {
        "problem_id": "applesandbananas2111",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Apples and Bananas",
        "description": "There are n apples and m bananas, and each of them has an integer weight between 1 … k . Your task is to calculate, for each weight w between 2 … 2k , the number of ways we can choose an apple and a banana whose combined weight is w .\n\nInput\n\nThe first input line contains three integers k , n and m : the number k , the number of apples and the number of bananas.\n\nThe next line contains n integers a_1,a_2,…,a_n : weight of each apple.\n\nThe last line contains m integers b_1,b_2,…,b_m : weight of each banana.\n\nOutput\n\nFor each integer w between 2 … 2k print the number of ways to choose an apple and a banana whose combined weight is w .\n\nConstraints\n\n1 ≤ k,n,m ≤ 2 · 10^5 1 ≤ a_i ≤ k 1 ≤ b_i ≤ k\n\nExample\n\nInput:\n\n\n5 3 4\n5 2 5\n4 3 2 3\n\n\nOutput:\n\n\n0 0 1 2 1 2 4 2 0\n\n\nExplanation: For example for w = 8 there are 4 different ways: we can pick an apple of weight 5 in two different ways and a banana of weight 3 in two different ways.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport cmath\nfrom collections import defaultdict\n\ndef fft(a):\n    n = len(a)\n    L = 31 - (n - 1).bit_length()\n    R = [1] * (2 * n)\n    rt = [1] * (2 * n)\n    \n    for k in range(2, n * 2, k * 2):\n        x = cmath.exp(complex(0, cmath.pi) / k)\n        for i in range(k, 2 * k):\n            rt[i] = R[i] = R[i // 2] * x if i & 1 else R[i // 2]\n    \n    rev = [0] * n\n    for i in range(n):\n        rev[i] = (rev[i // 2] | (i & 1) << L) // 2\n    \n    for i in range(n):\n        if i < rev[i]:\n            a[i], a[rev[i]] = a[rev[i]], a[i]\n    \n    for k in range(1, n, k * 2):\n        for i in range(0, n, 2 * k):\n            for j in range(k):\n                z = rt[j + k] * a[i + j + k]\n                a[i + j + k] = a[i + j] - z\n                a[i + j] += z\n\ndef conv(a, b):\n    if not a or not b:\n        return []\n    res = [0] * (len(a) + len(b) - 1)\n    L = 32 - (len(res) - 1).bit_length()\n    n = 1 << L\n    in_data = [0] * n\n    out_data = [0] * n\n    \n    for i in range(len(a)):\n        in_data[i] = complex(a[i], 0)\n    for i in range(len(b)):\n        in_data[i].imag = b[i]\n    \n    fft(in_data)\n    \n    for i in range(n):\n        in_data[i] *= in_data[i]\n    \n    for i in range(n):\n        out_data[i] = in_data[-i & (n - 1)] - in_data[i].conjugate()\n    \n    fft(out_data)\n    \n    for i in range(len(res)):\n        res[i] = out_data[i].imag / (4 * n)\n    \n    return res\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    k = int(data[0])\n    n = int(data[1])\n    m = int(data[2])\n    \n    a = [0] * (k + 1)\n    b = [0] * (k + 1)\n    \n    index = 3\n    for _ in range(n):\n        v = int(data[index])\n        a[v] += 1\n        index += 1\n    \n    for _ in range(m):\n        v = int(data[index])\n        b[v] += 1\n        index += 1\n    \n    ad = [float(a[i]) for i in range(k + 1)]\n    bd = [float(b[i]) for i in range(k + 1)]\n    \n    res = conv(ad, bd)\n    \n    print(\" \".join(str(int(res[i] + 0.1)) for i in range(2, 2 * k + 1)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2111",
        "hidden_test_path": "/id/hidden/2111",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    },
    {
        "problem_id": "onebitpositions2112",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "One Bit Positions",
        "description": "You are given a binary string of length n . Your task is to calculate, for every k between 1 … n-1 , the number of ways we can choose two positions i and j such that i-j=k and there is a one-bit at both positions.\n\nInput\n\nThe only input line has a string that consists only of characters 0 and 1 .\n\nOutput\n\nFor every distance k between 1… n-1 print the number of ways we can choose two such positions.\n\nConstraints\n\n2 ≤ n ≤ 2 · 10^5\n\nExample\n\nInput:\n\n\n1001011010\n\n\nOutput:\n\n\n1 2 3 0 2 1 0 1 0",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport cmath\nfrom collections import deque\n\ndef fft(a):\n    n = len(a)\n    L = 31 - (n - 1).bit_length()\n    R = [1] * (2 * n)\n    rt = [1] * (2 * n)\n    \n    for k in range(2, n * 2, k * 2):\n        x = cmath.exp(complex(0, cmath.pi) / k)\n        for i in range(k, 2 * k):\n            rt[i] = R[i] = R[i // 2] * x if i & 1 else R[i // 2]\n    \n    rev = [0] * n\n    for i in range(n):\n        rev[i] = (rev[i // 2] | (i & 1) << L) // 2\n    \n    for i in range(n):\n        if i < rev[i]:\n            a[i], a[rev[i]] = a[rev[i]], a[i]\n    \n    for k in range(1, n, k * 2):\n        for i in range(0, n, 2 * k):\n            for j in range(k):\n                z = rt[j + k] * a[i + j + k]\n                a[i + j + k] = a[i + j] - z\n                a[i + j] += z\n\ndef conv(a, b):\n    if not a or not b:\n        return []\n    res = [0] * (len(a) + len(b) - 1)\n    L = 32 - (len(res) - 1).bit_length()\n    n = 1 << L\n    in_data = [0] * n\n    out_data = [0] * n\n    \n    for i in range(len(a)):\n        in_data[i] = complex(a[i], 0)\n    for i in range(len(b)):\n        in_data[i].imag = b[i]\n    \n    fft(in_data)\n    \n    for i in range(n):\n        in_data[i] *= in_data[i]\n    \n    for i in range(n):\n        out_data[i] = in_data[-i & (n - 1)] - in_data[i].conjugate()\n    \n    fft(out_data)\n    \n    for i in range(len(res)):\n        res[i] = out_data[i].imag / (4 * n)\n    \n    return res\n\ndef main():\n    input = sys.stdin.read\n    str_input = input().strip()\n    v = [int(c) for c in str_input]\n    v2 = list(reversed(v))\n    res = conv(v, v2)\n    res = res[:-1]\n    res.reverse()\n    print(\" \".join(str(int(0.1 + x)) for x in res))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2112",
        "hidden_test_path": "/id/hidden/2112",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 5
    },
    {
        "problem_id": "signalprocessing2113",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Signal Processing",
        "description": "You are given two integer sequences: a signal and a mask. Your task is to process the signal by moving the mask through the signal from left to right. At each mask position calculate the sum of products of aligned signal and mask values in the part where the signal and the mask overlap.\n\nInput\n\nThe first input line consists of two integers n and m : the length of the signal and the length of the mask.\n\nThe next line consists of n integers a_1,a_2,…,a_n defining the signal.\n\nThe last line consists of m integers b_1,b_2,…,b_m defining the mask.\n\nOutput\n\nPrint n+m-1 integers: the sum of products of aligned values at each mask position from left to right.\n\nConstraints\n\n1 ≤ n,m ≤ 2 · 10^5 1 ≤ a_i,b_i ≤ 100\n\nExample\n\nInput:\n\n\n5 3\n1 3 2 1 4\n1 2 3\n\n\nOutput:\n\n\n3 11 13 10 16 9 4\n\n\nExplanation: For example, at the second mask position the sum of aligned products is 2 · 1 + 3 · 3 = 11 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport cmath\nfrom collections import deque\n\ndef fft(a):\n    n = len(a)\n    L = 31 - (n - 1).bit_length()\n    R = [1] * (2 * n)\n    rt = [1] * (2 * n)\n    \n    for k in range(2, n * 2, k * 2):\n        x = cmath.exp(complex(0, cmath.pi) / k)\n        for i in range(k, 2 * k):\n            rt[i] = R[i] = R[i // 2] * x if i & 1 else R[i // 2]\n    \n    rev = [0] * n\n    for i in range(n):\n        rev[i] = (rev[i // 2] | (i & 1) << L) // 2\n    \n    for i in range(n):\n        if i < rev[i]:\n            a[i], a[rev[i]] = a[rev[i]], a[i]\n    \n    for k in range(1, n, k * 2):\n        for i in range(0, n, 2 * k):\n            for j in range(k):\n                z = rt[j + k] * a[i + j + k]\n                a[i + j + k] = a[i + j] - z\n                a[i + j] += z\n\ndef conv(a, b):\n    if not a or not b:\n        return []\n    \n    res = [0] * (len(a) + len(b) - 1)\n    L = 32 - (len(res) - 1).bit_length()\n    n = 1 << L\n    in_data = [0] * n\n    out_data = [0] * n\n    \n    for i in range(len(a)):\n        in_data[i] = complex(a[i], 0)\n    \n    for i in range(len(b)):\n        in_data[i].imag = b[i]\n    \n    fft(in_data)\n    \n    for i in range(n):\n        in_data[i] *= in_data[i]\n    \n    for i in range(n):\n        out_data[i] = in_data[-i & (n - 1)] - in_data[i].conjugate()\n    \n    fft(out_data)\n    \n    for i in range(len(res)):\n        res[i] = out_data[i].imag / (4 * n)\n    \n    return res\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(float, data[2:n + 2]))\n    b = list(map(float, data[n + 2:n + 2 + m]))\n    \n    b.reverse()\n    res = conv(a, b)\n    \n    for value in res:\n        print(int(0.1 + value), end=\" \")\n    print()\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2113",
        "hidden_test_path": "/id/hidden/2113",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    },
    {
        "problem_id": "dynamicconnectivity2133",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Dynamic Connectivity",
        "description": "Consider an undirected graph that consists of n nodes and m edges. There are two types of events that can happen:\n\nA new edge is created between nodes a and b . An existing edge between nodes a and b is removed.\n\nYour task is to report the number of components after every event.\n\nInput\n\nThe first input line has three integers n , m and k : the number of nodes, edges and events.\n\nAfter this there are m lines describing the edges. Each line has two integers a and b : there is an edge between nodes a and b . There is at most one edge between any pair of nodes.\n\nThen there are k lines describing the events. Each line has the form \" t a b \" where t is 1 (create a new edge) or 2 (remove an edge). A new edge is always created between two nodes that do not already have an edge between them, and only existing edges can get removed.\n\nOutput\n\nPrint k+1 integers: first the number of components before the first event, and after this the new number of components after each event.\n\nConstraints\n\n2 ≤ n ≤ 10^5 1 ≤ m,k ≤ 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 3 3\n1 4\n2 3\n3 5\n1 2 5\n2 3 5\n1 1 2\n\n\nOutput:\n\n\n2 2 2 1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class RollbackUF:\n    def __init__(self, n):\n        self.e = [-1] * n\n        self.st = []\n        self.numcomps = n\n\n    def size(self, x):\n        return -self.e[self.find(x)]\n\n    def find(self, x):\n        if self.e[x] < 0:\n            return x\n        return self.find(self.e[x])\n\n    def time(self):\n        return len(self.st)\n\n    def rollback(self, t):\n        for i in range(self.time() - 1, t - 1, -1):\n            self.e[self.st[i][0]] = self.st[i][1]\n            self.numcomps = self.st[i][2]\n        self.st = self.st[:t]\n\n    def join(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return False\n        if self.e[a] > self.e[b]:\n            a, b = b, a\n        self.st.append((a, self.e[a], self.numcomps))\n        self.st.append((b, self.e[b], self.numcomps))\n        self.e[a] += self.e[b]\n        self.e[b] = a\n        self.numcomps -= 1\n        return True\n\n\nclass Node:\n    def __init__(self, lo, hi):\n        self.l = None\n        self.r = None\n        self.lo = lo\n        self.hi = hi\n        self.edges = []\n        if lo + 1 < hi:\n            mid = lo + (hi - lo) // 2\n            self.l = Node(lo, mid)\n            self.r = Node(mid, hi)\n\n    def add(self, L, R, edge):\n        if R <= self.lo or self.hi <= L:\n            return\n        if L <= self.lo and self.hi <= R:\n            self.edges.append(edge)\n        else:\n            self.l.add(L, R, edge)\n            self.r.add(L, R, edge)\n\n    def dfs(self, L, R, uf):\n        if R <= self.lo or self.hi <= L:\n            return\n        t = uf.time()\n        for p in self.edges:\n            uf.join(p[0], p[1])\n        if self.lo + 1 == self.hi:\n            print(uf.numcomps, end=\" \")\n        else:\n            self.l.dfs(L, R, uf)\n            self.r.dfs(L, R, uf)\n        uf.rollback(t)\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m, k = map(int, data[0].split())\n    tree = Node(0, k + 50)\n    edges = {}\n    uf = RollbackUF(n)\n\n    for i in range(1, m + 1):\n        a, b = map(int, data[i].split())\n        a -= 1\n        b -= 1\n        if a > b:\n            a, b = b, a\n        if (a, b) not in edges:\n            edges[(a, b)] = []\n        edges[(a, b)].append(0)\n\n    for i in range(m + 1, m + k + 1):\n        t, a, b = map(int, data[i].split())\n        a -= 1\n        b -= 1\n        if a > b:\n            a, b = b, a\n        if (a, b) not in edges:\n            edges[(a, b)] = []\n        edges[(a, b)].append(i - m)\n\n    addend = []\n    for key, val in edges.items():\n        if len(val) % 2 == 1:\n            addend.append(key)\n\n    for p in addend:\n        edges[p].append(k + 5)\n\n    for key, val in edges.items():\n        assert len(val) % 2 == 0\n        for i in range(0, len(val), 2):\n            tree.add(val[i], val[i + 1], key)\n\n    tree.dfs(0, k + 1, uf)\n    print()\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2133",
        "hidden_test_path": "/id/hidden/2133",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "parceldelivery2121",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Parcel Delivery",
        "description": "There are n cities and m routes through which parcels can be carried from one city to another city. For each route, you know the maximum number of parcels and the cost of a single parcel.\n\nYou want to send k parcels from Syrjälä to Lehmälä. What is the cheapest way to do that?\n\nInput\n\nThe first input line has three integers n , m and k : the number of cities, routes and parcels. The cities are numbered 1,2,…,n . City 1 is Syrjälä and city n is Lehmälä.\n\nAfter this, there are m lines that describe the routes. Each line has four integers a , b , r and c : there is a route from city a to city b , at most r parcels can be carried through the route, and the cost of each parcel is c .\n\nOutput\n\nPrint one integer: the minimum total cost or -1 if there are no solutions.\n\nConstraints\n\n2 ≤ n ≤ 500 1 ≤ m ≤ 1000 1 ≤ k ≤ 100 1 ≤ a,b ≤ n 1 ≤ r,c ≤ 1000\n\nExample\n\nInput:\n\n\n4 5 3\n1 2 5 100\n1 3 10 50\n1 4 7 500\n2 4 8 350\n3 4 2 100\n\n\nOutput:\n\n\n750\n\n\nExplanation: One parcel is delivered through route 1 → 2 → 4 (cost 1 · 450=450 ) and two parcels are delivered through route 1 → 3 → 4 (cost 2 · 150=300 ).",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport heapq\nfrom collections import defaultdict\n\nclass MinCostFlow4:\n    class Edge:\n        def __init__(self, s, e, cap, c):\n            self.u = s\n            self.v = e\n            self.cap = cap\n            self.cost = c\n            self.rev = None\n\n    class Node:\n        def __init__(self, i, dd):\n            self.id = i\n            self.d = dd\n        \n        def __lt__(self, other):\n            return self.d > other.d\n\n    INF1 = 1000000000\n    INF2 = 100000000\n\n    def __init__(self, n):\n        self.s = 0\n        self.t = n\n        n += 1\n        self.mS = n\n        self.mT = n + 1\n        self.adj = [[] for _ in range(n)]\n        self.previous = []\n        self.w = []\n        self.pi = []\n\n    def add(self, a, b, cap, c):\n        e1 = self.Edge(a, b, cap, c)\n        e2 = self.Edge(b, a, 0, -c)\n        e1.rev = e2\n        e2.rev = e1\n        self.adj[a].append(e1)\n        self.adj[b].append(e2)\n        return e1\n\n    def minCostMaxFlowNegCycles(self):\n        f = self.add(self.t, self.s, self.INF1, -self.INF2)\n        c = self.minCostFlow()\n        return (self.INF1 - f.cap, c + self.INF2 * (self.INF1 - f.cap))\n\n    def minCostFlow(self):\n        res = 0\n        val = [0] * len(self.adj)\n        for i in range(len(self.adj)):\n            for e in self.adj[i]:\n                if e.cap > 0 and e.cost < 0:\n                    res += e.cap * e.cost\n                    val[e.u] -= e.cap\n                    val[e.v] += e.cap\n                    e.rev.cap = e.cap\n                    e.cap = 0\n        for i in range(len(val)):\n            if val[i] > 0:\n                self.add(self.mS, i, val[i], 0)\n            elif val[i] < 0:\n                self.add(i, self.mT, -val[i], 0)\n        self.s = self.mS\n        self.t = self.mT\n        return res + self.minCostMaxFlow()[1]\n\n    def minCostMaxFlow(self):\n        flow = 0\n        cost = 0\n        self.getPotential()\n        while self.findPath():\n            flow += self.w[self.t]\n            cost += self.update()\n        return (flow, cost)\n\n    def getPotential(self):\n        self.pi = [self.INF1] * len(self.adj)\n        self.pi[self.s] = 0\n        for _ in range(len(self.adj) - 1):\n            upd = False\n            for j in range(len(self.adj)):\n                for e in self.adj[j]:\n                    if e.cap > 0 and self.pi[e.u] + e.cost < self.pi[e.v]:\n                        self.pi[e.v] = self.pi[e.u] + e.cost\n                        upd = True\n            if not upd:\n                break\n\n    def findPath(self):\n        d = [self.INF1] * len(self.adj)\n        d[self.s] = 0\n        self.previous = [None] * len(self.adj)\n        self.w = [self.INF1] * len(self.adj)\n        pq = []\n        heapq.heappush(pq, self.Node(self.s, 0))\n        while pq:\n            node = heapq.heappop(pq)\n            if node.d == d[node.id]:\n                for e in self.adj[node.id]:\n                    nd = d[node.id] + e.cost + self.pi[e.u] - self.pi[e.v]\n                    if e.cap > 0 and nd < d[e.v]:\n                        d[e.v] = nd\n                        self.previous[e.v] = e\n                        self.w[e.v] = min(self.w[node.id], e.cap)\n                        heapq.heappush(pq, self.Node(e.v, nd))\n        for i in range(len(self.pi)):\n            self.pi[i] += d[i]\n        return d[self.t] < self.INF1\n\n    def update(self):\n        v = self.t\n        cur = 0\n        while self.previous[v] is not None:\n            self.previous[v].cap -= self.w[self.t]\n            self.previous[v].rev.cap += self.w[self.t]\n            cur += self.w[self.t] * self.previous[v].cost\n            v = self.previous[v].u\n        return cur\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    k = int(data[idx])\n    idx += 1\n    graph = [defaultdict(list) for _ in range(n)]\n    m4 = MinCostFlow4(n)\n    m4.add(n - 1, m4.t, k, 0)\n    for _ in range(m):\n        a = int(data[idx]) - 1\n        idx += 1\n        b = int(data[idx]) - 1\n        idx += 1\n        r = int(data[idx])\n        idx += 1\n        c = int(data[idx])\n        idx += 1\n        graph[a][b].append((c, r))\n        m4.add(a, b, r, c)\n    ans = m4.minCostMaxFlow()\n    print(-1 if ans[0] < k else ans[1])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2121",
        "hidden_test_path": "/id/hidden/2121",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "taskassignment2129",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Task Assignment",
        "description": "A company has n employees and there are n tasks that need to be done. We know for each employee the cost of carrying out each task. Every employee should be assigned to exactly one task. What is the minimum total cost if we assign the tasks optimally and how could they be assigned?\n\nInput\n\nThe first input line has one integer n : the number of employees and the number of tasks that need to be done.\n\nAfter this, there are n lines each consisting of n integers. The i th line consists of integers c_{i1},c_{i2},…,c_{in} : the cost of each task when it is assigned to the i th employee.\n\nOutput\n\nFirst print the minimum total cost.\n\nThen print n lines each consisting of two integers a and b : you assign the b th task to the a th employee.\n\nIf there are multiple solutions you can print any of them.\n\nConstraints\n\n1 ≤ n ≤ 200 1 ≤ c_{ij} ≤ 1000\n\nExample\n\nInput:\n\n\n4\n17 8 16 9\n7 15 12 19\n6 9 10 11\n14 7 13 10\n\n\nOutput:\n\n\n33\n1 4\n2 1\n3 3\n4 2\n\n\nExplanation: The minimum total cost is 33 . We can reach this by assigning employee 1 task 4, employee 2 task 1, employee 3 task 3 and employee 4 task 2. This will cost 9 + 7 + 10 + 7 = 33 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import defaultdict\nimport heapq\n\nINF = float('inf')\n\nclass MCMF:\n    def __init__(self, N):\n        self.N = N\n        self.ed = [[] for _ in range(N)]\n        self.red = [[] for _ in range(N)]\n        self.cap = [[0] * N for _ in range(N)]\n        self.flow = [[0] * N for _ in range(N)]\n        self.cost = [[0] * N for _ in range(N)]\n        self.seen = [0] * N\n        self.par = [None] * N\n        self.dist = [INF] * N\n        self.rel = [0] * N\n\n    def addEdge(self, from_node, to_node, cap, cost):\n        self.cap[from_node][to_node] = cap\n        self.cost[from_node][to_node] = cost\n        self.ed[from_node].append(to_node)\n        self.red[to_node].append(from_node)\n\n    def path(self, s):\n        self.seen = [0] * self.N\n        self.dist = [INF] * self.N\n        self.dist[s] = 0\n        di = 0\n\n        q = []\n        its = [None] * self.N\n        heapq.heappush(q, (0, s))\n\n        def relax(i, cap, cost, dir):\n            nonlocal di\n            val = di - self.rel[i] + cost\n            if cap and val < self.dist[i]:\n                self.dist[i] = val\n                self.par[i] = (s, dir)\n                if its[i] is None:\n                    its[i] = heapq.heappush(q, (-self.dist[i], i))\n                else:\n                    heapq.heappush(q, (-self.dist[i], i))\n\n        while q:\n            s = heapq.heappop(q)[1]\n            self.seen[s] = 1\n            di = self.dist[s] + self.rel[s]\n            for i in self.ed[s]:\n                if not self.seen[i]:\n                    relax(i, self.cap[s][i] - self.flow[s][i], self.cost[s][i], 1)\n            for i in self.red[s]:\n                if not self.seen[i]:\n                    relax(i, self.flow[i][s], -self.cost[i][s], 0)\n\n        for i in range(self.N):\n            self.rel[i] = min(self.rel[i] + self.dist[i], INF)\n\n    def maxflow(self, s, t):\n        totflow = 0\n        totcost = 0\n        while True:\n            self.path(s)\n            if not self.seen[t]:\n                break\n            fl = INF\n            for x in range(t, s, -1):\n                p, r = self.par[x]\n                fl = min(fl, self.cap[p][x] - self.flow[p][x] if r else self.flow[x][p])\n            totflow += fl\n            for x in range(t, s, -1):\n                p, r = self.par[x]\n                if r:\n                    self.flow[p][x] += fl\n                else:\n                    self.flow[x][p] -= fl\n\n        for i in range(self.N):\n            for j in range(self.N):\n                totcost += self.cost[i][j] * self.flow[i][j]\n        return (totflow, totcost)\n\n    def setrel(self, s):\n        self.rel = [INF] * self.N\n        self.rel[s] = 0\n        it = self.N\n        ch = 1\n        while ch and it:\n            ch = 0\n            for i in range(self.N):\n                if self.rel[i] != INF:\n                    for to in self.ed[i]:\n                        if self.cap[i][to]:\n                            v = self.rel[i] + self.cost[i][to]\n                            if v < self.rel[to]:\n                                self.rel[to] = v\n                                ch = 1\n            it -= 1\n        assert it >= 0  # negative cost cycle\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    mcmf = MCMF(2 * n + 2)\n    source = 2 * n\n    sink = 2 * n + 1\n    for i in range(n):\n        mcmf.addEdge(source, i, 1, 0)\n        mcmf.addEdge(n + i, sink, 1, 0)\n    for i in range(n):\n        for j in range(n):\n            v = int(data[idx])\n            idx += 1\n            mcmf.addEdge(i, n + j, 1, v)\n    ans = mcmf.maxflow(source, sink)\n    print(ans[1])\n    for i in range(n):\n        for j in range(n):\n            if mcmf.flow[i][n + j]:\n                print(i + 1, j + 1)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2129",
        "hidden_test_path": "/id/hidden/2129",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    },
    {
        "problem_id": "slidingwindowsum3220",
        "topic": "Chương 1",
        "sub_topic": "Sliding Window Problems",
        "name": "Sliding Window Sum",
        "description": "You are given an array of n integers. Your task is to calculate the sum of each window of k elements, from left to right.\n\nIn this problem the input data is large and it is created using a generator.\n\nInput\n\nThe first line contains two integers n and k : the number of elements and the size of the window.\n\nThe next line contains four integers x , a , b and c : the input generator parameters. The input is generated as follows:\n\nx_1=x x_i=(ax_{i-1}+b) \\bmod c for i=2,3,…,n\n\nOutput\n\nPrint the xor of all window sums.\n\nConstraints\n\n1 ≤ k ≤ n ≤ 10^7 0 ≤ x, a, b ≤ 10^9 1 ≤ c ≤ 10^9\n\nExample\n\nInput:\n\n\n8 5\n3 7 1 11\n\n\nOutput:\n\n\n12\n\n\nExplanation: The input array is [3,0,1,8,2,4,7,6] . The windows are [3,0,1,8,2] , [0,1,8,2,4] , [1,8,2,4,7] and [8,2,4,7,6] , and their sums are 14 , 15 , 22 and 27 . Thus, the answer is 14 \\oplus 15 \\oplus 22 \\oplus 27 = 12 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    x = int(data[2])\n    a = int(data[3])\n    b = int(data[4])\n    c = int(data[5])\n    \n    v = [x]\n    for i in range(n - 1):\n        v.append((a * v[-1] + b) % c)\n    \n    ans = 0\n    pref = [0]\n    for i in range(n):\n        pref.append(pref[-1] + v[i])\n    \n    for i in range(k, n + 1):\n        res = pref[i] - pref[i - k]\n        ans ^= res\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3220",
        "hidden_test_path": "/id/hidden/3220",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 3
    },
    {
        "problem_id": "slidingwindowminimum3221",
        "topic": "Chương 1",
        "sub_topic": "Sliding Window Problems",
        "name": "Sliding Window Minimum",
        "description": "You are given an array of n integers. Your task is to calculate the minimum of each window of k elements, from left to right.\n\nIn this problem the input data is large and it is created using a generator.\n\nInput\n\nThe first line contains two integers n and k : the number of elements and the size of the window.\n\nThe next line contains four integers x , a , b and c : the input generator parameters. The input is generated as follows:\n\nx_1=x x_i=(ax_{i-1}+b) \\bmod c for i=2,3,…,n\n\nOutput\n\nPrint the xor of all window minimums.\n\nConstraints\n\n1 ≤ k ≤ n ≤ 10^7 0 ≤ x, a, b ≤ 10^9 1 ≤ c ≤ 10^9\n\nExample\n\nInput:\n\n\n8 5\n3 7 1 11\n\n\nOutput:\n\n\n3\n\n\nExplanation: The input array is [3,0,1,8,2,4,7,6] . The windows are [3,0,1,8,2] , [0,1,8,2,4] , [1,8,2,4,7] and [8,2,4,7,6] , and their minimums are 0 , 0 , 1 and 2 . Thus, the answer is 0 \\oplus 0 \\oplus 1 \\oplus 2 = 3 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import deque\n\nn, k = map(int, input().split())\nx, a, b, c = map(int, input().split())\nv = [x]\n\nfor i in range(n - 1):\n    v.append((a * v[-1] + b) % c)\n\nans = 0\nq = deque()\n\nfor i in range(n):\n    while q and q[-1][0] >= v[i]:\n        q.pop()\n    q.append((v[i], i))\n    if i >= k and q[0][1] == i - k:\n        q.popleft()\n    if i >= k - 1:\n        ans ^= q[0][0]\n\nprint(ans)",
        "public_test_path": "/id/public/3221",
        "hidden_test_path": "/id/hidden/3221",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "slidingwindowxor3426",
        "topic": "Chương 1",
        "sub_topic": "Sliding Window Problems",
        "name": "Sliding Window Xor",
        "description": "You are given an array of n integers. Your task is to calculate the bitwise xor of each window of k elements, from left to right.\n\nIn this problem the input data is large and it is created using a generator.\n\nInput\n\nThe first line contains two integers n and k : the number of elements and the size of the window.\n\nThe next line contains four integers x , a , b and c : the input generator parameters. The input is generated as follows:\n\nx_1=x x_i=(ax_{i-1}+b) \\bmod c for i=2,3,…,n\n\nOutput\n\nPrint the xor of all window xors.\n\nConstraints\n\n1 ≤ k ≤ n ≤ 10^7 0 ≤ x, a, b ≤ 10^9 1 ≤ c ≤ 10^9\n\nExample\n\nInput:\n\n\n8 5\n3 7 1 11\n\n\nOutput:\n\n\n0\n\n\nExplanation: The input array is [3,0,1,8,2,4,7,6] . The windows are [3,0,1,8,2] , [0,1,8,2,4] , [1,8,2,4,7] and [8,2,4,7,6] , and their xors are 8 , 15 , 8 and 15 . Thus, the answer is 8 \\oplus 15 \\oplus 8 \\oplus 15 = 0 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    x = int(data[2])\n    a = int(data[3])\n    b = int(data[4])\n    c = int(data[5])\n    \n    v = [x]\n    for i in range(n - 1):\n        v.append((a * v[-1] + b) % c)\n    \n    ans = 0\n    pref = [0]\n    for i in range(n):\n        pref.append(pref[-1] ^ v[i])\n    \n    for i in range(k, n + 1):\n        res = pref[i] ^ pref[i - k]\n        ans ^= res\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3426",
        "hidden_test_path": "/id/hidden/3426",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 3
    },
    {
        "problem_id": "slidingwindowor3405",
        "topic": "Chương 1",
        "sub_topic": "Sliding Window Problems",
        "name": "Sliding Window Or",
        "description": "You are given an array of n integers. Your task is to calculate the bitwise or of each window of k elements, from left to right.\n\nIn this problem the input data is large and it is created using a generator.\n\nInput\n\nThe first line contains two integers n and k : the number of elements and the size of the window.\n\nThe next line contains four integers x , a , b and c : the input generator parameters. The input is generated as follows:\n\nx_1=x x_i=(ax_{i-1}+b) \\bmod c for i=2,3,…,n\n\nOutput\n\nPrint the xor of all window ors.\n\nConstraints\n\n1 ≤ k ≤ n ≤ 10^7 0 ≤ x, a, b ≤ 10^9 1 ≤ c ≤ 10^9\n\nExample\n\nInput:\n\n\n8 5\n3 7 1 11\n\n\nOutput:\n\n\n4\n\n\nExplanation: The input array is [3,0,1,8,2,4,7,6] . The windows are [3,0,1,8,2] , [0,1,8,2,4] , [1,8,2,4,7] and [8,2,4,7,6] , and their ors are 11 , 15 , 15 and 15 . Thus, the answer is 11 \\oplus 15 \\oplus 15 \\oplus 15 = 4 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    x = int(data[2])\n    a = int(data[3])\n    b = int(data[4])\n    c = int(data[5])\n    \n    v = [x]\n    for i in range(1, n):\n        v.append((a * v[-1] + b) % c)\n    \n    ans = 0\n    freq = [0] * 30\n    st1 = []\n    st2 = []\n    \n    for i in range(n):\n        st1.append((v[i], v[i] | (st1[-1][1] if st1 else 0)))\n        if i >= k:\n            if st2:\n                st2.pop()\n            else:\n                while st1:\n                    x, mn = st1.pop()\n                    st2.append((x, x | (st2[-1][1] if st2 else 0)))\n                st2.pop()\n        \n        res = 0\n        if st1:\n            res |= st1[-1][1]\n        if st2:\n            res |= st2[-1][1]\n        if i >= k - 1:\n            ans ^= res\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3405",
        "hidden_test_path": "/id/hidden/3405",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "slidingwindowmode3224",
        "topic": "Chương 1",
        "sub_topic": "Sliding Window Problems",
        "name": "Sliding Window Mode",
        "description": "You are given an array of n integers. Your task is to calculate the mode each window of k elements, from left to right.\n\nThe mode is the most frequent element in an array. If there are several possible modes, choose the smallest of them.\n\nInput\n\nThe first line contains two integers n and k : the number of elements and the size of the window.\n\nThen there are n integers x_1,x_2,…,x_n : the contents of the array.\n\nOutput\n\nPrint n-k+1 values: the modes.\n\nConstraints\n\n1 ≤ k ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8 3\n1 2 3 2 5 2 4 4\n\n\nOutput:\n\n\n1 2 2 2 2 4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\nn, k = int(data[0]), int(data[1])\na = list(map(int, data[2:n+2]))\n\nfreq = defaultdict(int)\nfreqs = []\nresult = []\n\nfor i in range(n):\n    heapq.heappush(freqs, (0, -a[i]))\n\nfor i in range(n):\n    if freq[a[i]] > 0:\n        freqs.remove((freq[a[i]], -a[i]))\n        heapq.heapify(freqs)\n    \n    freq[a[i]] += 1\n    heapq.heappush(freqs, (freq[a[i]], -a[i]))\n    \n    if i >= k:\n        freqs.remove((freq[a[i-k]], -a[i-k]))\n        heapq.heapify(freqs)\n        freq[a[i-k]] -= 1\n        heapq.heappush(freqs, (freq[a[i-k]], -a[i-k]))\n    \n    if i >= k - 1:\n        result.append(-freqs[0][1])\n\nprint(\" \".join(map(str, result)))",
        "public_test_path": "/id/public/3224",
        "hidden_test_path": "/id/hidden/3224",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 3
    },
    {
        "problem_id": "slidingwindowmex3219",
        "topic": "Chương 1",
        "sub_topic": "Sliding Window Problems",
        "name": "Sliding Window Mex",
        "description": "You are given an array of n integers. Your task is to calculate the mex of each window of k elements, from left to right.\n\nThe mex is the smallest nonnegative integer that does not appear in the array. For example, the mex for [3,1,4,3,0,5] is 2 .\n\nInput\n\nThe first line contains two integers n and k : the number of elements and the size of the window.\n\nThen there are n integers x_1,x_2,…,x_n : the contents of the array.\n\nOutput\n\nPrint n-k+1 values: the mex values.\n\nConstraints\n\n1 ≤ k ≤ n ≤ 2 · 10^5 0 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8 3\n1 2 1 0 5 1 1 0\n\n\nOutput:\n\n\n0 3 2 2 0 2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:n+2]))\n    \n    B = 400\n    blocks = (n - 1) // B + 10\n    off = [B] * blocks\n    cnt = [0] * (n + 1)\n    \n    for i in range(n):\n        if a[i] <= n:\n            cnt[a[i]] += 1\n            if cnt[a[i]] == 1:\n                off[a[i] // B] -= 1\n        if i >= k:\n            if a[i - k] <= n:\n                cnt[a[i - k]] -= 1\n                if cnt[a[i - k]] == 0:\n                    off[a[i - k] // B] += 1\n        if i >= k - 1:\n            ans = 0\n            while off[ans] == 0:\n                ans += 1\n            ans *= B\n            for j in range(B):\n                if cnt[ans + j] == 0:\n                    ans += j\n                    break\n            print(ans, end=\" \")\n    \n    print()\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3219",
        "hidden_test_path": "/id/hidden/3219",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 5
    },
    {
        "problem_id": "slidingwindowinversions3223",
        "topic": "Chương 1",
        "sub_topic": "Sliding Window Problems",
        "name": "Sliding Window Inversions",
        "description": "You are given an array of n integers. Your task is to calculate the number of inversions in each window of k elements, from left to right.\n\nAn inversion is a pair of elements where the left element is larger than the right element.\n\nInput\n\nThe first line contains two integers n and k : the number of elements and the size of the window.\n\nThen there are n integers x_1,x_2,…,x_n : the contents of the array.\n\nOutput\n\nPrint n-k+1 values: the numbers of inversions.\n\nConstraints\n\n1 ≤ k ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8 3\n1 2 3 2 5 2 4 4\n\n\nOutput:\n\n\n0 1 1 1 2 0",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class FT:\n    def __init__(self, n):\n        self.s = [0] * n\n\n    def update(self, pos, dif):\n        while pos < len(self.s):\n            self.s[pos] += dif\n            pos |= pos + 1\n\n    def query(self, pos):\n        res = 0\n        while pos > 0:\n            res += self.s[pos - 1]\n            pos &= pos - 1\n        return res\n\n    def lower_bound(self, sum):\n        if sum <= 0:\n            return -1\n        pos = 0\n        for pw in (1 << i for i in range(25, -1, -1)):\n            if pos + pw <= len(self.s) and self.s[pos + pw - 1] < sum:\n                pos += pw\n                sum -= self.s[pos - 1]\n        return pos\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:n + 2]))\n    \n    c = sorted(set(a))\n    a = [c.index(x) for x in a]\n    \n    ft = FT(len(c))\n    inv = 0\n    result = []\n    \n    for i in range(n):\n        inv += ft.query(len(c)) - ft.query(a[i] + 1)\n        ft.update(a[i], 1)\n        if i >= k:\n            inv -= ft.query(a[i - k])\n            ft.update(a[i - k], -1)\n        if i >= k - 1:\n            result.append(inv)\n    \n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3223",
        "hidden_test_path": "/id/hidden/3223",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 2
    },
    {
        "problem_id": "slidingwindowadvertisement3227",
        "topic": "Chương 1",
        "sub_topic": "Sliding Window Problems",
        "name": "Sliding Window Advertisement",
        "description": "A fence consists of n vertical boards. The width of each board is 1 and their heights may vary.\n\nYou want to attach a rectangular advertisement to the fence. Your task is to calculate the maximum area of such an advertisement in each window of k vertical boards, from left to right.\n\nInput\n\nThe first line contains two integers n and k : the width of the fence and the size of the window.\n\nAfter this, there are n integers x_1, x_2, …, x_n : the height of each board.\n\nOutput\n\nPrint n - k + 1 integers: the maximum areas of the advertisements.\n\nConstraints\n\n1 ≤ k ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8 3\n4 1 5 3 3 2 4 1\n\n\nOutput:\n\n\n5 6 9 6 6 4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import deque\nimport sys\nimport math\n\nMAXT = 530000\ninf = 4 * 10**18\n\nclass Line:\n    def __init__(self, A, B):\n        self.A = A\n        self.B = B\n\n    def eval(self, x):\n        return self.A * x + self.B\n\n    def cross_after(self, x, T):\n        if x.A == self.A:\n            return inf\n        up = x.B - self.B\n        dn = self.A - x.A\n        if dn < 0:\n            dn *= -1\n            up *= -1\n        incep = (-(-up // dn) if up <= 0 else (up + dn - 1) // dn)\n        return incep if incep > T else inf\n\nclass KST:\n    def __init__(self):\n        self.tree = [None] * MAXT\n        self.melt = [0] * MAXT\n        self.T = 0\n        self.n = 0\n\n    def pull(self, p):\n        l = self.tree[2 * p].eval(self.T)\n        r = self.tree[2 * p + 1].eval(self.T)\n        self.tree[p] = (self.tree[2 * p] if l < r or (l == r and self.tree[2 * p].A < self.tree[2 * p + 1].A) else self.tree[2 * p + 1])\n        self.melt[p] = min(self.melt[2 * p], self.melt[2 * p + 1], self.tree[2 * p].cross_after(self.tree[2 * p + 1], self.T))\n\n    def init(self, s, e, p, l):\n        if s == e:\n            self.tree[p] = l[s]\n            self.melt[p] = inf\n            return\n        m = (s + e) // 2\n        self.init(s, m, 2 * p, l)\n        self.init(m + 1, e, 2 * p + 1, l)\n        self.pull(p)\n\n    def update(self, pos, v, s, e, p=1):\n        if s == e:\n            self.tree[p] = v\n            return\n        m = (s + e) // 2\n        if pos <= m:\n            self.update(pos, v, s, m, 2 * p)\n        else:\n            self.update(pos, v, m + 1, e, 2 * p + 1)\n        self.pull(p)\n\n    def query(self, s, e, ps, pe, p=1):\n        if e < ps or pe < s:\n            return inf\n        if s <= ps and pe <= e:\n            return self.tree[p].eval(self.T)\n        pm = (ps + pe) // 2\n        return min(self.query(s, e, ps, pm, 2 * p), self.query(s, e, pm + 1, pe, 2 * p + 1))\n\n    def heaten(self, s, e, p):\n        if self.melt[p] > self.T:\n            return\n        m = (s + e) // 2\n        self.heaten(s, m, 2 * p)\n        self.heaten(m + 1, e, 2 * p + 1)\n        self.pull(p)\n\n    def init_kst(self, l, _T):\n        self.n = len(l)\n        self.T = _T\n        self.init(0, self.n - 1, 1, l)\n\n    def heaten_kst(self, _T):\n        assert self.T <= _T\n        self.T = _T\n        self.heaten(0, self.n - 1, 1)\n\nkst = KST()\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:n + 2]))\n    \n    left = [-1] * n\n    right = [-1] * n\n    anss = []\n    \n    for it in range(2):\n        emp = Line(0, inf)\n        init = [emp] * n\n        kst.init_kst(init, -1)\n        q = deque()\n        qstart = 0\n        ans = []\n        \n        for i in range(n):\n            while q and q[-1][0] >= a[i]:\n                q.pop()\n            pi = q[-1][1] if q else -1\n            kst.update(qstart + len(q), Line(-a[i], -(-a[i] * pi)), 0, n - 1)\n            if q:\n                right[i] if it else left[i] = q[-1][1]\n            q.append((a[i], i))\n            if i >= k and q[0][1] == i - k:\n                q.popleft()\n                qstart += 1\n            if q:\n                v, idx = q[0]\n                kst.update(qstart, Line(-v, -(-v * max(-1, i - k))), 0, n - 1)\n            if i >= k - 1:\n                kst.heaten_kst(i)\n                ans.append(-kst.query(qstart, qstart + len(q) - 1, 0, n - 1))\n        \n        anss.append(ans)\n        a.reverse()\n    \n    anss[1].reverse()\n    right = [n - 1 - r for r in right]\n    \n    fans = anss[0]\n    addevents = [[] for _ in range(len(fans))]\n    remevents = [[] for _ in range(len(fans))]\n    \n    for i in range(n):\n        len_range = right[i] - 1 - left[i]\n        if len_range <= k:\n            start = max(0, right[i] - 1 - (k - 1))\n            addevents[start].append(len_range * a[i])\n            ending = min(n - 1, left[i] + 1 + k - 1) - (k - 1)\n            if ending + 1 < len(remevents):\n                remevents[ending + 1].append(len_range * a[i])\n    \n    for i in range(len(fans)):\n        fans[i] = max(fans[i], anss[1][i])\n    \n    ss = set()\n    for i in range(len(addevents)):\n        for v in addevents[i]:\n            ss.add(v)\n        for v in remevents[i]:\n            ss.discard(v)\n        if ss:\n            fans[i] = max(fans[i], max(ss))\n    \n    print(\" \".join(map(str, fans)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3227",
        "hidden_test_path": "/id/hidden/3227",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 9
    },
    {
        "problem_id": "hiddeninteger3112",
        "topic": "Chương 1",
        "sub_topic": "Interactive Problems",
        "name": "Hidden Integer",
        "description": "There is a hidden integer x . Your task is to find the value of x .\n\nTo do this, you can ask questions: you can choose an integer y and you will be told if y < x .\n\nInteraction\n\nThis is an interactive problem. Your code will interact with the grader using standard input and output. You can start asking questions right away.\n\nOn your turn, you can print one of the following:\n\n\" ?\\ y \", where 1 ≤ y ≤ 10^9 : ask if y < x . The grader will return YES if y < x and NO otherwise. \" !\\ x \": report that the hidden integer is x . Your program must terminate after this.\n\nEach line should be followed by a line break. You must make sure the output gets flushed after printing each line.\n\nConstraints\n\n1 ≤ x ≤ 10^9 you can ask at most 30 questions of type ?\n\nExample\n\n? 3\nYES\n? 6\nYES\n? 7\nNO\n! 7",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    x = 0\n    for dif in [1 << i for i in range(29, -1, -1)]:\n        print(f\"? {x + dif}\")\n        res = input().strip()\n        if res == \"YES\":\n            x += dif\n    x += 1\n    print(f\"! {x}\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3112",
        "hidden_test_path": "/id/hidden/3112",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "hiddenpermutation3139",
        "topic": "Chương 1",
        "sub_topic": "Interactive Problems",
        "name": "Hidden Permutation",
        "description": "There is a hidden permutation a_1, a_2,…, a_n of integers 1, 2,…, n . Your task is to find this permutation.\n\nTo do this, you can ask questions: you can choose two indices i and j and you will be told if a_i < a_j .\n\nInteraction\n\nThis is an interactive problem. Your code will interact with the grader using standard input and output. You should start by reading a single integer n : the length of the permutation.\n\nOn your turn, you can print one of the following:\n\n\" ?\\ i\\ j \", where 1 ≤ i, j ≤ n : ask if a_i < a_j . The grader will return YES if a_i < a_j and NO otherwise. \" !\\ a_1\\ a_2 … a_n \": report that the hidden permutation is a_1, a_2,…, a_n . Your program must terminate after this.\n\nEach line should be followed by a line break. You must make sure the output gets flushed after printing each line.\n\nConstraints\n\n1 ≤ n ≤ 1000 you can ask at most 10^4 questions of type ?\n\nExample\n\n3\n? 3 2\nNO\n? 3 1\nYES\n! 3 1 2\n\n\nExplanation: The hidden permutation is [3, 1, 2] . The first question asks if a_3 < a_2 which is false, so the answer is NO . The second question asks if a_3 < a_1 which is true, so the answer is YES .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import random\nfrom collections import defaultdict\n\ncache = {}\ndef cmp(a, b):\n    if a == b:\n        return False\n    if (a, b) in cache:\n        return cache[(a, b)]\n    if (b, a) in cache:\n        return not cache[(b, a)]\n    print(f\"? {a + 1} {b + 1}\")\n    s = input().strip()\n    cache[(a, b)] = (s == \"YES\")\n    return cache[(a, b)]\n\ndef dfs(cur):\n    if len(cur) <= 1:\n        return cur\n    split = len(cur) // 2\n    left = cur[:split]\n    right = cur[split:]\n    left = dfs(left)\n    right = dfs(right)\n    res = []\n    l, r = 0, 0\n    while l < len(left) or r < len(right):\n        if r == len(right) or (l < len(left) and cmp(left[l], right[r])):\n            res.append(left[l])\n            l += 1\n        else:\n            res.append(right[r])\n            r += 1\n    return res\n\nn = int(input().strip())\nperm = [0] * n\nidxs = list(range(n))\nrandom.shuffle(idxs)\nidxs = dfs(idxs)\nfor i in range(n):\n    perm[idxs[i]] = i\nprint(\"! \", end=\"\")\nprint(\" \".join(str(perm[i] + 1) for i in range(n)))",
        "public_test_path": "/id/public/3139",
        "hidden_test_path": "/id/hidden/3139",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "permutedbinarystrings3228",
        "topic": "Chương 1",
        "sub_topic": "Interactive Problems",
        "name": "Permuted Binary Strings",
        "description": "There is a hidden permutation a_1, a_2,…, a_n of integers 1, 2,…, n . Your task is to find this permutation.\n\nTo do this, you can ask questions: you can choose a binary string b_1b_2… b_n and you will receive the binary string b_{a_1}b_{a_2}… b_{a_n} .\n\nInteraction\n\nThis is an interactive problem. Your code will interact with the grader using standard input and output. You should start by reading a single integer n : the length of the permutation.\n\nOn your turn, you can print one of the following:\n\n\" ?\\ b_1b_2… b_n \", where b_i∈\\{0, 1\\} : The grader will return the binary string b_{a_1}b_{a_2}… b_{a_n} . \" !\\ a_1\\ a_2 … a_n \": report that the hidden permutation is a_1, a_2,…, a_n . Your program must terminate after this.\n\nEach line should be followed by a line break. You must make sure the output gets flushed after printing each line.\n\nConstraints\n\n1 ≤ n ≤ 1000 you can ask at most 10 questions of type ?\n\nExample\n\n3\n? 100\n100\n? 010\n001\n? 001\n010\n! 1 3 2\n\n\nExplanation : The hidden permutation is [1, 3, 2] . In the first question b_1b_2b_3 = 100 and the grader returns b_{a_1}b_{a_2}b_{a_3} = b_1b_3b_2 = 100 . In the second question b_1b_2b_3 = 010 and the grader returns b_1b_3b_2 = 001 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    a = [0] * n\n    \n    for b in range(10):\n        print(\"? \", end=\"\")\n        for i in range(n):\n            print((i >> b) & 1, end=\"\")\n        print()\n        \n        s = data[b + 1]\n        for i in range(n):\n            if s[i] == '1':\n                a[i] += 1 << b\n    \n    print(\"! \", end=\"\")\n    for i in range(n):\n        print(a[i] + 1, end=\" \")\n    print()\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3228",
        "hidden_test_path": "/id/hidden/3228",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "coloredchairs3273",
        "topic": "Chương 1",
        "sub_topic": "Interactive Problems",
        "name": "Colored Chairs",
        "description": "There are n chairs arranged in a circle. Each chair is either red or blue. The chairs are numbered 1, 2,…, n ; chairs i and i+1 are next to each other for all 1 ≤ i ≤ n . Here chair n+1 refers to chair 1 .\n\nYour task is to find two chairs that have the same color and are next to each other.\n\nTo do this, you can ask questions: you can choose a chair and you will be told the color of that chair.\n\nInteraction\n\nThis is an interactive problem. Your code will interact with the grader using standard input and output. You should start by reading a single integer n : the number of chairs.\n\nOn your turn, you can print one of the following:\n\n\" ?\\ i \", where 1 ≤ i ≤ n : ask the color of chair i . The grader will return R or B for red or blue. \" !\\ i \": report that chairs i and i+1 have the same color. Your program must terminate after this.\n\nEach line should be followed by a line break. You must make sure the output gets flushed after printing each line.\n\nConstraints\n\n3 ≤ n ≤ 2 · 10^5 , n is odd you can ask at most 20 questions of type ?\n\nExample\n\n5\n? 1\nR\n? 2\nB\n? 3\nB\n! 2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    l, r = 0, n - 1\n    print(f\"? {l + 1}\")\n    lc = data[1]\n    print(f\"? {r + 1}\")\n    rc = data[2]\n    \n    if lc == rc:\n        print(f\"! {r + 1}\")\n        return\n    \n    while r - l > 1:\n        mid = l + (r - l) // 2\n        print(f\"? {mid + 1}\")\n        mc = data[mid + 3]  # Adjusting for the input lines\n        if (lc == mc) == ((l & 1) == (mid & 1)):\n            l = mid\n            lc = mc\n        else:\n            r = mid\n            rc = mc\n    \n    assert lc == rc\n    print(f\"! {l + 1}\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3273",
        "hidden_test_path": "/id/hidden/3273",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "inversionsorting3140",
        "topic": "Chương 1",
        "sub_topic": "Interactive Problems",
        "name": "Inversion Sorting",
        "description": "There is a hidden permutation a_1, a_2,…, a_n of integers 1, 2,…, n . Your task is to sort the permutation by reversing subarrays.\n\nOn each turn, you can reverse a subarray of the permutation. After that, you will be reported the number of inversions in the permutation. If the number of inversions is 0 (i.e., the permutation is sorted), you win.\n\nInteraction\n\nThis is an interactive problem. Your code will interact with the grader using standard input and output. You should start by reading a single integer n : the length of the permutation.\n\nOn your turn, print two integers i and j : reverse the subarray between indices i and j .\n\nAfter this, the next input line has a single integer: the number of inversions after the operation. If the number is 0 , you win and your program must terminate after this.\n\nConstraints\n\n1≤q n≤q 1000 you can make at most 4n operations\n\nExample\n\n3\n1 2\n1\n2 3\n0\n\n\nExplanation : Here the initial permutation is [3,1,2] . After the first operation the permutation is [1,3,2] and the number of inversions is 1 . After the second operation the permutation is [1,2,3] and the number of inversions is 0 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    \n    def query(l, r):\n        nonlocal index\n        print(f\"? {l + 1} {r + 1}\")\n        inv = int(data[index])\n        index += 1\n        if inv == 0:\n            sys.exit()\n        return inv\n    \n    ord = [0]\n    inv = query(0, 1)\n    \n    for i in range(1, n):\n        inv2 = query(0, i)\n        if 1 < i - 1:\n            inv2 = query(1, i - 1)\n        invend = n - 2 - i\n        cnt = inv2\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3140",
        "hidden_test_path": "/id/hidden/3140",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "countingbits1146",
        "topic": "Chương 1",
        "sub_topic": "Bitwise Operations",
        "name": "Counting Bits",
        "description": "Your task is to count the number of one bits in the binary representations of integers between 1 and n .\n\nInput\n\nThe only input line has an integer n .\n\nOutput\n\nPrint the number of one bits in the binary representations of integers between 1 and n .\n\nConstraints\n\n1 ≤ n ≤ 10^{15}\n\nExample\n\nInput:\n\n\n7\n\n\nOutput:\n\n\n12\n\n\nExplanation: The binary representations of 1 … 7 are 1, 10, 11, 100, 101, 110, and 111, so there are a total of 12 one bits.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    numbits = 55\n    bitsum = [0] * numbits\n    bitsum[0] = 1\n    for i in range(1, numbits):\n        bitsum[i] = bitsum[i - 1] * 2 + (1 << i)\n\n    n = int(input()) + 1\n\n    def solve(v):\n        ans = 0\n        ones = 0\n        for i in range(numbits - 1, -1, -1):\n            if v & (1 << i):\n                ans += (bitsum[i - 1] if i else 0) + ones * (1 << i)\n                ones += 1\n        return ans\n\n    print(solve(n))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1146",
        "hidden_test_path": "/id/hidden/1146",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 21
    },
    {
        "problem_id": "maximumxorsubarray1655",
        "topic": "Chương 1",
        "sub_topic": "Bitwise Operations",
        "name": "Maximum Xor Subarray",
        "description": "Given an array of n integers, your task is to find the maximum xor sum of a subarray.\n\nInput\n\nThe first line has an integer n : the size of the array.\n\nThe next line has n integers x_1,x_2,…,x_n : the contents of the array.\n\nOutput\n\nPrint one integer: the maximum xor sum in a subarray.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 0 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4\n5 1 5 9\n\n\nOutput:\n\n\n13",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Node:\n    def __init__(self, b):\n        self.nex = [None, None]\n        self.bitnum = b\n\n    def add(self, val):\n        if self.bitnum == 0:\n            return\n        idx = (val >> (self.bitnum - 1)) & 1\n        if self.nex[idx] is None:\n            self.nex[idx] = Node(self.bitnum - 1)\n        self.nex[idx].add(val)\n\n    def closest(self, val):\n        ans = 0\n        if self.bitnum == 0:\n            return ans\n        idx = (val >> (self.bitnum - 1)) & 1\n        if self.nex[idx] is not None:\n            ans |= idx << (self.bitnum - 1)\n            ans |= self.nex[idx].closest(val)\n        elif self.nex[1 - idx] is not None:\n            ans |= (1 - idx) << (self.bitnum - 1)\n            ans |= self.nex[1 - idx].closest(val)\n        return ans\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:n+1]))\n    \n    for i in range(1, n):\n        a[i] ^= a[i - 1]\n    \n    root = Node(30)\n    root.add(0)\n    ans = 0\n    \n    for i in range(n):\n        c = root.closest(~a[i])\n        ans = max(ans, c ^ a[i])\n        root.add(a[i])\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1655",
        "hidden_test_path": "/id/hidden/1655",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "inverseinversions2214",
        "topic": "Chương 1",
        "sub_topic": "Construction Problems",
        "name": "Inverse Inversions",
        "description": "Your task is to create a permutation of numbers 1,2,…,n that has exactly k inversions.\n\nAn inversion is a pair (a,b) where a<b and p_a>p_b where p_i denotes the number at position i in the permutation.\n\nInput\n\nThe only input line has two integers n and k .\n\nOutput\n\nPrint a line that contains the permutation. You can print any valid solution.\n\nConstraints\n\n1 ≤ n ≤ 10^6 0 ≤ k ≤ \\frac{n(n-1)}{2}\n\nExample\n\nInput:\n\n\n5 4\n\n\nOutput:\n\n\n1 5 2 4 3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    \n    for i in range(n, 0, -1):\n        if k > i - 1:\n            print(i, end=\" \")\n            k -= i - 1\n        else:\n            rest = [0] * i\n            rest[i - 1 - k] = i\n            v = 1\n            for j in range(i):\n                if rest[j] == 0:\n                    rest[j] = v\n                    v += 1\n                print(rest[j], end=\" \")\n            break\n    print()\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2214",
        "hidden_test_path": "/id/hidden/2214",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "monotonesubsequences2215",
        "topic": "Chương 1",
        "sub_topic": "Construction Problems",
        "name": "Monotone Subsequences",
        "description": "Your task is to create a permutation of numbers 1,2,…,n whose longest monotone subsequence has exactly k elements.\n\nA monotone subsequence is either increasing or decreasing. For example, some monotone subsequences in [2,1,4,5,3] are [2,4,5] and [4,3] .\n\nInput\n\nThe first input line has an integer t : the number of tests.\n\nAfter this, there are t lines. Each line has two integers n and k .\n\nOutput\n\nFor each test, print a line that contains the permutation. You can print any valid solution. If there are no solutions, print IMPOSSIBLE .\n\nConstraints\n\n1 ≤ t ≤ 1000 1 ≤ k ≤ n ≤ 100\n\nExample\n\nInput:\n\n\n3\n5 3\n5 2\n7 7\n\n\nOutput:\n\n\n2 1 4 5 3\nIMPOSSIBLE\n1 2 3 4 5 6 7",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    nc = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(nc):\n        n, k = map(int, data[index].split())\n        index += 1\n        \n        if k * k < n:\n            results.append(\"IMPOSSIBLE\")\n            continue\n        \n        current = n - k + 1\n        stop = n\n        \n        while stop > 0:\n            while current <= stop:\n                results.append(str(current))\n                current += 1\n            stop -= k\n            current = max(1, stop - k + 1)\n        \n        results.append(\"\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2215",
        "hidden_test_path": "/id/hidden/2215",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 2
    },
    {
        "problem_id": "chesstournament1697",
        "topic": "Chương 1",
        "sub_topic": "Construction Problems",
        "name": "Chess Tournament",
        "description": "There will be a chess tournament of n players. Each player has announced the number of games they want to play.\n\nEach pair of players can play at most one game. Your task is to determine which games will be played so that everybody will be happy.\n\nInput\n\nThe first input line has an integer n : the number of players. The players are numbered 1,2,…,n .\n\nThe next line has n integers x_1,x_2,…,x_n : for each player, the number of games they want to play.\n\nOutput\n\nFirst print an integer k : the number of games. Then, print k lines describing the games. You can print any valid solution.\n\nIf there are no solutions, print \"IMPOSSIBLE\".\n\nConstraints\n\n1 ≤ n ≤ 10^5 ∑_{i=1}^{n} x_i ≤ 2 · 10^5\n\nExample\n\nInput:\n\n\n5\n1 3 2 0 2\n\n\nOutput:\n\n\n4\n1 2\n2 3\n2 5\n3 5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = list(map(int, data[1:n+1]))\n    ans = []\n    possible = True\n    pq = []\n    \n    for i in range(n):\n        if x[i]:\n            heapq.heappush(pq, (-x[i], i + 1))\n    \n    while pq:\n        d, a = heapq.heappop(pq)\n        d = -d\n        if len(pq) < d:\n            possible = False\n            break\n        reinsert = []\n        for _ in range(d):\n            d1, b = heapq.heappop(pq)\n            d1 = -d1 - 1\n            if d1:\n                reinsert.append((-d1, b))\n            ans.append((a, b))\n        for p in reinsert:\n            heapq.heappush(pq, p)\n    \n    if not possible:\n        print(\"IMPOSSIBLE\")\n        return\n    \n    print(len(ans))\n    for a, b in ans:\n        print(a, b)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1697",
        "hidden_test_path": "/id/hidden/1697",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 21
    },
    {
        "problem_id": "fillingtrominos2423",
        "topic": "Chương 1",
        "sub_topic": "Construction Problems",
        "name": "Filling Trominos",
        "description": "Your task is to fill an n × m grid using L-trominos (three squares that have an L-shape). For example, here is one way to fill a 4 × 6 grid:\n\nInput\n\nThe first input line has an integer t : the number of tests.\n\nAfter that, there are t lines that describe the tests. Each line has two integers n and m .\n\nOutput\n\nFor each test, print YES if there is a solution, and NO otherwise.\n\nIf there is a solution, also print n lines that each contain m letters between A–Z. Adjacent squares must have the same letter exactly when they belong to the same tromino. You can print any valid solution.\n\nConstraints\n\n1 ≤ t ≤ 100 1 ≤ n,m ≤ 100\n\nExample\n\nInput:\n\n\n2\n4 6\n4 7\n\n\nOutput:\n\n\nYES\nAADDBB\nACCDEB\nBCAEEC\nBBAACC\nNO",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def solve23(i, j):\n    global t\n    grid[i][j] = grid[i + 1][j] = grid[i + 1][j + 1] = t\n    t += 1\n    grid[i][j + 1] = grid[i][j + 2] = grid[i + 1][j + 2] = t\n    t += 1\n\ndef solve32(i, j):\n    global t\n    grid[i][j] = grid[i + 1][j] = grid[i][j + 1] = t\n    t += 1\n    grid[i + 2][j] = grid[i + 1][j + 1] = grid[i + 2][j + 1] = t\n    t += 1\n\ndef solve23k(r1, r2, c1, c2):\n    for i in range(r1, r2, 2):\n        for j in range(c1, c2, 3):\n            solve23(i, j)\n\ndef solve56(r1, r2, c1, c2):\n    solve23k(r1 + 3, r2, c1, c2)\n    i = r1\n    for j in range(c1, c2, 2):\n        solve32(i, j)\n\ndef solve59(r1, r2, c1, c2):\n    global t\n    solve32(r1, c1)\n    solve32(r1, c1 + 2)\n    solve23(r1 + 3, c1)\n    solve23(r1, c1 + 4)\n    solve32(r1, c1 + 7)\n    grid[r1 + 3][c1 + 3] = grid[r1 + 4][c1 + 3] = grid[r1 + 4][c1 + 4] = t\n    t += 1\n    grid[r1 + 3][c1 + 3 + 2] = grid[r1 + 4][c1 + 3 + 2] = grid[r1 + 4][c1 + 4 + 2] = t\n    t += 1\n    grid[r1 - 1 + 3][c1 + 3 + 3] = grid[r1 - 1 + 4][c1 + 3 + 3] = grid[r1 - 1 + 4][c1 + 3 + 4] = t\n    t += 1\n    grid[r1 + 2][c1 + 4] = grid[r1 + 3][c1 + 4] = grid[r1 + 2][c1 + 5] = t\n    t += 1\n    grid[r1 + 4][c1 + 7] = grid[r1 + 4][c1 + 8] = grid[r1 + 3][c1 + 8] = t\n    t += 1\n\ndef solve():\n    global grid, t\n    n, m = map(int, input().split())\n    if (n * m) % 3 != 0 or min(n, m) <= 1:\n        print(\"NO\")\n        return\n    sw = False\n    if m % 2 == 0 and n % 3 == 0:\n        sw = not sw\n        n, m = m, n\n    if n % 2 == 0 and m % 3 == 0:\n        grid = [[-1] * m for _ in range(n)]\n        solve23k(0, n, 0, m)\n        goto_end()\n    if m % 3 != 0:\n        n, m = m, n\n        sw = not sw\n    if m == 3 or n == 3:\n        print(\"NO\")\n        return\n    grid = [[-1] * m for _ in range(n)]\n    for r in range(n, 5, -2):\n        solve23k(r - 2, r, 0, m)\n    c = m\n    for c in range(m, 9, -6):\n        solve56(0, 5, c - 6, c)\n    if c == 6:\n        solve56(0, 5, 0, 6)\n    else:\n        solve59(0, 5, 0, 9)\n\n    goto_end()\n\ndef goto_end():\n    print(\"YES\")\n    if sw:\n        cp = [[0] * n for _ in range(m)]\n        for i in range(n):\n            for j in range(m):\n                cp[j][i] = grid[i][j]\n        n, m = m, n\n        grid = cp\n\n    adj = [[] for _ in range(t)]\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    for i in range(n):\n        for j in range(m):\n            assert grid[i][j] != -1\n    for i in range(n):\n        for j in range(m):\n            assert grid[i][j] != -1\n            for dr, dc in dirs:\n                i1, j1 = i + dr, j + dc\n                if min(i1, j1) < 0 or i1 >= n or j1 >= m:\n                    continue\n                if grid[i1][j1] != grid[i][j]:\n                    adj[grid[i][j]].append(grid[i1][j1])\n    col = [-1] * t\n    for i in range(t):\n        adj[i].sort()\n        adj[i] = list(dict.fromkeys(adj[i]))\n        unused = 0\n        seen = set()\n        for j in adj[i]:\n            if col[j] != -1:\n                seen.add(col[j])\n        for j in seen:\n            if unused == j:\n                unused += 1\n        col[i] = unused\n    for i in range(n):\n        for j in range(m):\n            grid[i][j] = col[grid[i][j]]\n            print(chr(ord('A') + grid[i][j]), end=\"\")\n        print()\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    nc = int(data[0])\n    for cn in range(nc):\n        solve()",
        "public_test_path": "/id/public/2423",
        "hidden_test_path": "/id/hidden/2423",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "prufercode1134",
        "topic": "Chương 1",
        "sub_topic": "Advanced Graph Problems",
        "name": "Prüfer Code",
        "description": "A Prüfer code of a tree of n nodes is a sequence of n-2 integers that uniquely specifies the structure of the tree.\n\nThe code is constructed as follows: As long as there are at least three nodes left, find a leaf with the smallest label, add the label of its only neighbor to the code, and remove the leaf from the tree.\n\nGiven a Prüfer code of a tree, your task is to construct the original tree.\n\nInput\n\nThe first input line contains an integer n : the number of nodes. The nodes are numbered 1,2,…,n .\n\nThe second line contains n-2 integers: the Prüfer code.\n\nOutput\n\nPrint n-1 lines describing the edges of the tree. Each line has to contain two integers a and b : there is an edge between nodes a and b . You can print the edges in any order.\n\nConstraints\n\n3 ≤ n ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5\n2 2 4\n\n\nOutput:\n\n\n1 2\n2 3\n2 4\n4 5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    occ = [0] * (n + 1)\n    lst = [int(data[i]) - 1 for i in range(1, n - 1)]\n    \n    for i in lst:\n        occ[i] += 1\n    \n    leaves = set(i for i in range(n) if occ[i] == 0)\n    \n    for i in lst:\n        nex = min(leaves)\n        leaves.remove(nex)\n        print(nex + 1, i + 1)\n        occ[i] -= 1\n        if occ[i] == 0:\n            leaves.add(i)\n    \n    assert len(leaves) == 2\n    v = min(leaves)\n    v1 = max(leaves)\n    print(v + 1, v1 + 1)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1134",
        "hidden_test_path": "/id/hidden/1134",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "treetraversals1702",
        "topic": "Chương 1",
        "sub_topic": "Advanced Graph Problems",
        "name": "Tree Traversals",
        "description": "There are three common ways to traverse the nodes of a binary tree:\n\nPreorder : First process the root, then the left subtree, and finally the right subtree. Inorder : First process the left subtree, then the root, and finally the right subtree. Postorder : First process the left subtree, then the right subtree, and finally the root.\n\nThere is a binary tree of n nodes with distinct labels. You are given the preorder and inorder traversals of the tree, and your task is to determine its postorder traversal.\n\nInput\n\nThe first input line has an integer n : the number of nodes. The nodes are numbered 1,2,…,n .\n\nAfter this, there are two lines describing the preorder and inorder traversals of the tree. Both lines consist of n integers.\n\nYou can assume that the input corresponds to a binary tree.\n\nOutput\n\nPrint the postorder traversal of the tree.\n\nConstraints\n\n1 ≤ n ≤ 10^5\n\nExample\n\nInput:\n\n\n5\n5 3 2 1 4\n3 5 1 2 4\n\n\nOutput:\n\n\n3 1 4 2 5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Node:\n    def __init__(self, v):\n        self.left = None\n        self.right = None\n        self.val = v\n\n    def postorder(self):\n        if self.left:\n            self.left.postorder()\n        if self.right:\n            self.right.postorder()\n        print(self.val, end=\" \")\n\ndef construct(preorder, inorder, rev, idx, left, right):\n    if idx[0] >= len(preorder) or left > right:\n        return None\n    root = Node(preorder[idx[0]])\n    idx[0] += 1\n    split = rev[root.val]\n    root.left = construct(preorder, inorder, rev, idx, left, split - 1)\n    root.right = construct(preorder, inorder, rev, idx, split + 1, right)\n    return root\n\nn = int(input())\npreorder = list(map(int, input().split()))\ninorder = list(map(int, input().split()))\nrev = [0] * (n + 1)\n\nfor i in range(n):\n    rev[inorder[i]] = i\n\nidx = [0]\ntree = construct(preorder, inorder, rev, idx, 0, n - 1)\ntree.postorder()\nprint()",
        "public_test_path": "/id/public/1702",
        "hidden_test_path": "/id/hidden/1702",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "acyclicgraphedges1756",
        "topic": "Chương 1",
        "sub_topic": "Advanced Graph Problems",
        "name": "Acyclic Graph Edges",
        "description": "Given an undirected graph, your task is to choose a direction for each edge so that the resulting directed graph is acyclic.\n\nInput\n\nThe first input line has two integers n and m : the number of nodes and edges. The nodes are numbered 1,2,…,n .\n\nAfter this, there are m lines describing the edges. Each line has two distinct integers a and b : there is an edge between nodes a and b .\n\nOutput\n\nPrint m lines describing the directions of the edges. Each line has two integers a and b : there is an edge from node a to node b . You can print any valid solution.\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n3 3\n1 2\n2 3\n3 1\n\n\nOutput:\n\n\n1 2\n3 2\n3 1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m = map(int, data[0].split())\n    results = []\n    \n    for i in range(1, m + 1):\n        a, b = map(int, data[i].split())\n        if a > b:\n            a, b = b, a\n        results.append(f\"{a} {b}\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1756",
        "hidden_test_path": "/id/hidden/1756",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 5
    },
    {
        "problem_id": "stronglyconnectededges2177",
        "topic": "Chương 1",
        "sub_topic": "Advanced Graph Problems",
        "name": "Strongly Connected Edges",
        "description": "Given an undirected graph, your task is to choose a direction for each edge so that the resulting directed graph is strongly connected.\n\nInput\n\nThe first input line has two integers n and m : the number of nodes and edges. The nodes are numbered 1,2,…,n .\n\nAfter this, there are m lines describing the edges. Each line has two integers a and b : there is an edge between nodes a and b .\n\nYou may assume that the graph is simple, i.e., there are at most one edge between two nodes and every edge connects two distinct nodes.\n\nOutput\n\nPrint m lines describing the directions of the edges. Each line has two integers a and b : there is an edge from node a to node b . You can print any valid solution.\n\nIf there are no solutions, only print IMPOSSIBLE .\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n3 3\n1 2\n1 3\n2 3\n\n\nOutput:\n\n\n1 2\n2 3\n3 1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\n\nnum = []\nst = []\ned = []\nTime = 0\nhasbridge = False\ncomps = 0\n\ndef dfs(at, par, f):\n    global Time, hasbridge\n    me = num[at] = Time + 1\n    e, y, top = None, None, me\n    for pa in ed[at]:\n        y, e = pa\n        if e != par:\n            if num[y] != 0:\n                top = min(top, num[y])\n                if num[y] < me:\n                    st.append(e)\n            else:\n                si = len(st)\n                up = dfs(y, e, f)\n                top = min(top, up)\n                if up == me:\n                    st.append(e)\n                    f(st[si:])\n                    st = st[:si]\n                elif up < me:\n                    st.append(e)\n                else:\n                    hasbridge = True\n    return top\n\ndef bicomps(f):\n    global comps\n    global num\n    num[:] = [0] * len(ed)\n    for i in range(len(ed)):\n        if num[i] == 0:\n            dfs(i, -1, f)\n            comps += 1\n\ndef main():\n    global ed, hasbridge, comps\n    n, m = map(int, input().split())\n    ed = [[] for _ in range(n)]\n    adj = [set() for _ in range(n)]\n    \n    for i in range(m):\n        a, b = map(int, input().split())\n        a -= 1\n        b -= 1\n        ed[a].append((b, i))\n        ed[b].append((a, i))\n        adj[a].add(b)\n        adj[b].add(a)\n    \n    bicomps(lambda val: None)\n    \n    if hasbridge or comps > 1:\n        print(\"IMPOSSIBLE\")\n        return\n    \n    def dfs(cur):\n        while adj[cur]:\n            nex = adj[cur].pop()\n            adj[nex].remove(cur)\n            print(cur + 1, nex + 1)\n            dfs(nex)\n    \n    dfs(0)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2177",
        "hidden_test_path": "/id/hidden/2177",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "evenoutdegreeedges2179",
        "topic": "Chương 1",
        "sub_topic": "Advanced Graph Problems",
        "name": "Even Outdegree Edges",
        "description": "Given an undirected graph, your task is to choose a direction for each edge so that in the resulting directed graph each node has an even outdegree. The outdegree of a node is the number of edges coming out of that node.\n\nInput\n\nThe first input line has two integers n and m : the number of nodes and edges. The nodes are numbered 1,2,…,n .\n\nAfter this, there are m lines describing the edges. Each line has two integers a and b : there is an edge between nodes a and b .\n\nYou may assume that the graph is simple, i.e., there is at most one edge between any two nodes and every edge connects two distinct nodes.\n\nOutput\n\nPrint m lines describing the directions of the edges. Each line has two integers a and b : there is an edge from node a to node b . You can print any valid solution.\n\nIf there are no solutions, only print IMPOSSIBLE .\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n4 4\n1 2\n2 3\n3 4\n1 4\n\n\nOutput:\n\n\n1 2\n3 2\n3 4\n1 4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m = map(int, data[0].split())\n    if m % 2 == 1:\n        print(\"IMPOSSIBLE\")\n        return\n\n    visited = [0] * n\n    deg = [0] * n\n    edges = []\n    adj = defaultdict(list)\n\n    for i in range(1, m + 1):\n        a, b = map(int, data[i].split())\n        a -= 1\n        b -= 1\n        adj[a].append(b)\n        adj[b].append(a)\n\n    t = 1\n\n    def dfs(cur, par):\n        nonlocal t\n        visited[cur] = t\n        t += 1\n        for nex in adj[cur]:\n            if nex == par:\n                continue\n            if visited[nex] and visited[nex] < visited[cur]:\n                edges.append((cur, nex))\n                deg[cur] ^= 1\n            elif not visited[nex]:\n                dfs(nex, cur)\n                if deg[nex]:\n                    edges.append((nex, cur))\n                    deg[nex] ^= 1\n                else:\n                    edges.append((cur, nex))\n                    deg[cur] ^= 1\n\n    works = True\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, -1)\n        if deg[i]:\n            works = False\n\n    if works:\n        for a, b in edges:\n            print(a + 1, b + 1)\n    else:\n        print(\"IMPOSSIBLE\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2179",
        "hidden_test_path": "/id/hidden/2179",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "graphgirth1707",
        "topic": "Chương 1",
        "sub_topic": "Advanced Graph Problems",
        "name": "Graph Girth",
        "description": "Given an undirected graph, your task is to determine its girth , i.e., the length of its shortest cycle.\n\nInput\n\nThe first input line has two integers n and m : the number of nodes and edges. The nodes are numbered 1,2,…,n .\n\nAfter this, there are m lines describing the edges. Each line has two integers a and b : there is an edge between nodes a and b .\n\nYou may assume that there is at most one edge between each two nodes.\n\nOutput\n\nPrint one integer: the girth of the graph. If there are no cycles, print -1 .\n\nConstraints\n\n1 ≤ n ≤ 2500 1 ≤ m ≤ 5000\n\nExample\n\nInput:\n\n\n5 6\n1 2\n1 3\n2 4\n2 5\n3 4\n4 5\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import deque\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\nn, m = int(data[0]), int(data[1])\nadj = [[] for _ in range(n)]\nindex = 2\n\nfor _ in range(m):\n    a, b = int(data[index]) - 1, int(data[index + 1]) - 1\n    adj[a].append(b)\n    adj[b].append(a)\n    index += 2\n\nans = float('inf')\n\nfor i in range(n):\n    dist = [float('inf')] * n\n    par = [-1] * n\n    dist[i] = 0\n    par[i] = i\n    q = deque([(i, i, 0)])\n\n    while q:\n        k, pre, d = q.popleft()\n        if par[k] != pre:\n            ans = min(ans, d + dist[k])\n        else:\n            for nex in adj[k]:\n                if par[nex] == -1:\n                    par[nex] = k\n                    dist[nex] = d + 1\n                if nex != pre:\n                    q.append((nex, k, d + 1))\n\nif ans == float('inf'):\n    ans = -1\n\nprint(ans)",
        "public_test_path": "/id/public/1707",
        "hidden_test_path": "/id/hidden/1707",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 21
    },
    {
        "problem_id": "networkbreakdown1677",
        "topic": "Chương 1",
        "sub_topic": "Advanced Graph Problems",
        "name": "Network Breakdown",
        "description": "Syrjälä's network has n computers and m connections between them. The network consists of components of computers that can send messages to each other.\n\nNobody in Syrjälä understands how the network works. For this reason, if a connection breaks down, nobody will repair it. In this situation a component may be divided into two components.\n\nYour task is to calculate the number of components after each connection breakdown.\n\nInput\n\nThe first input line has three integers n , m and k : the number of computers, connections and breakdowns. The computers are numbered 1,2,…,n .\n\nThen, there are m lines describing the connections. Each line has two integers a and b : there is a connection between computers a and b . Each connection is between two different computers, and there is at most one connection between two computers.\n\nFinally, there are k lines describing the breakdowns. Each line has two integers a and b : the connection between computers a and b breaks down.\n\nOutput\n\nAfter each breakdown, print the number of components.\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ k ≤ m 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 5 3\n1 2\n1 3\n2 3\n3 4\n4 5\n3 4\n2 3\n4 5\n\n\nOutput:\n\n\n2 2 3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class UF:\n    def __init__(self, n):\n        self.e = [-1] * n\n        self.ncomps = n\n\n    def same_set(self, a, b):\n        return self.find(a) == self.find(b)\n\n    def size(self, x):\n        return -self.e[self.find(x)]\n\n    def find(self, x):\n        if self.e[x] < 0:\n            return x\n        self.e[x] = self.find(self.e[x])\n        return self.e[x]\n\n    def join(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return False\n        if self.e[a] > self.e[b]:\n            a, b = b, a\n        self.e[a] += self.e[b]\n        self.e[b] = a\n        self.ncomps -= 1\n        return True\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    m = int(data[idx + 1])\n    k = int(data[idx + 2])\n    idx += 3\n    \n    uf = UF(n)\n    edges = set()\n    \n    for _ in range(m):\n        a = int(data[idx]) - 1\n        b = int(data[idx + 1]) - 1\n        idx += 2\n        if a > b:\n            a, b = b, a\n        edges.add((a, b))\n    \n    qs = []\n    for _ in range(k):\n        f = int(data[idx]) - 1\n        s = int(data[idx + 1]) - 1\n        idx += 2\n        if f > s:\n            f, s = s, f\n        qs.append((f, s))\n        edges.discard((f, s))\n    \n    for a, b in edges:\n        uf.join(a, b)\n    \n    ans = []\n    for i in range(k - 1, -1, -1):\n        ans.append(uf.ncomps)\n        uf.join(qs[i][0], qs[i][1])\n    \n    print(\" \".join(map(str, reversed(ans))))\n\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1677",
        "hidden_test_path": "/id/hidden/1677",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "flightrouterequests1699",
        "topic": "Chương 1",
        "sub_topic": "Advanced Graph Problems",
        "name": "Flight Route Requests",
        "description": "There are n cities with airports but no flight connections. You are given m requests which routes should be possible to travel.\n\nYour task is to determine the minimum number of one-way flight connections which makes it possible to fulfil all requests.\n\nInput\n\nThe first input line has two integers n and m : the number of cities and requests. The cities are numbered 1,2,…,n .\n\nAfter this, there are m lines describing the requests. Each line has two integers a and b : there has to be a route from city a to city b . Each request is unique.\n\nOutput\n\nPrint one integer: the minimum number of flight connections.\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a, b ≤ n\n\nExample\n\nInput:\n\n\n4 5\n1 2\n2 3\n2 4\n3 1\n3 4\n\n\nOutput:\n\n\n4\n\n\nExplanation: You can create the connections 1 → 2 , 2 → 3 , 2 → 4 and 3 → 1 . Then you can also fly from city 3 to city 4 using the route 3 → 1 → 2 → 4 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\n\nTime = 0\nncomps = 0\nval = []\ncomp = []\nz = []\ncont = []\ncomps = []\n\ndef dfs(j, g, f):\n    global Time, ncomps\n    low = val[j] = Time + 1\n    global z\n    z.append(j)\n    for e in g[j]:\n        if comp[e] < 0:\n            low = min(low, val[e] if val[e] != 0 else dfs(e, g, f))\n\n    if low == val[j]:\n        x = -1\n        while x != j:\n            x = z.pop()\n            comp[x] = ncomps\n            cont.append(x)\n        f(cont)\n        cont.clear()\n        ncomps += 1\n    return val[j] = low\n\ndef scc(g, f):\n    global val, comp, Time, ncomps\n    n = len(g)\n    val = [0] * n\n    comp = [-1] * n\n    Time = ncomps = 0\n    for i in range(n):\n        if comp[i] < 0:\n            dfs(i, g, f)\n\nbelongs = []\n\ndef addcomp(v):\n    global comps\n    comps.append([])\n    for i in v:\n        comps[-1].append(i)\n    for i in v:\n        belongs[i] = ncomps\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    adj = [[] for _ in range(n)]\n    \n    index = 2\n    for _ in range(m):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        adj[a].append(b)\n        index += 2\n    \n    global belongs\n    belongs = [-1] * n\n    scc(adj, addcomp)\n    \n    ans = 0\n    for i in range(ncomps):\n        connects = False\n        if len(comps[i]) > 1:\n            ans += len(comps[i])\n        for j in comps[i]:\n            for k in adj[j]:\n                if belongs[k] != belongs[j]:\n                    connects = True\n        if connects:\n            ans += 1\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1699",
        "hidden_test_path": "/id/hidden/1699",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 17
    },
    {
        "problem_id": "criticalcities1703",
        "topic": "Chương 1",
        "sub_topic": "Advanced Graph Problems",
        "name": "Critical Cities",
        "description": "There are n cities and m flight connections between them. A city is called a critical city if it appears on every route from a city to another city.\n\nYour task is to find all critical cities from Syrjälä to Lehmälä.\n\nInput\n\nThe first input line has two integers n and m : the number of cities and flights. The cities are numbered 1,2,…,n . City 1 is Syrjälä, and city n is Lehmälä.\n\nThen, there are m lines describing the connections. Each line has two integers a and b : there is a flight from city a to city b . All flights are one-way.\n\nYou may assume that there is a route from Syrjälä to Lehmälä.\n\nOutput\n\nFirst print an integer k : the number of critical cities. After this, print k integers: the critical cities in increasing order.\n\nConstraints\n\n2 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 5\n1 2\n2 3\n2 4\n3 5\n4 5\n\n\nOutput:\n\n\n3\n1 2 5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport sys\nimport itertools\n\ninput = sys.stdin.read\nsys.setrecursionlimit(10**6)\n\nN = int(1e5) + 100\ng = defaultdict(list)\nrg = defaultdict(list)\nbucket = defaultdict(list)\nsdom = [0] * N\npar = [0] * N\ndom = [0] * N\ndsu = [0] * N\nlabel = [0] * N\narr = [0] * N\nrev = [0] * N\nT = 0\ntree = [0] * N\n\ndef Find(u, x=0):\n    if u == dsu[u]:\n        return -1 if x else u\n    v = Find(dsu[u], x + 1)\n    if v < 0:\n        return u\n    if sdom[label[dsu[u]]] < sdom[label[u]]:\n        label[u] = label[dsu[u]]\n    dsu[u] = v\n    return v if x else label[u]\n\ndef Union(u, v):\n    dsu[v] = u\n\ndef dfs0(u):\n    global T\n    T += 1\n    arr[u] = T\n    rev[T] = u\n    label[T] = T\n    sdom[T] = T\n    dsu[T] = T\n    for w in g[u]:\n        if not arr[w]:\n            dfs0(w)\n            par[arr[w]] = arr[u]\n        rg[arr[w]].append(arr[u])\n\ndef main():\n    global g, rg, bucket, sdom, par, dom, dsu, label, arr, rev, T, tree\n    n, m = map(int, input().split())\n    \n    for _ in range(m):\n        a, b = map(int, input().split())\n        g[a].append(b)\n    \n    dfs0(1)\n    \n    for i in range(n, 0, -1):\n        for j in rg[i]:\n            sdom[i] = min(sdom[i], sdom[Find(j)])\n        if i > 1:\n            bucket[sdom[i]].append(i)\n        for w in bucket[i]:\n            v = Find(w)\n            if sdom[v] == sdom[w]:\n                dom[w] = sdom[w]\n            else:\n                dom[w] = v\n        if i > 1:\n            Union(par[i], i)\n    \n    for i in range(2, n + 1):\n        if dom[i] != sdom[i]:\n            dom[i] = dom[dom[i]]\n        tree[rev[i]] = rev[dom[i]]\n    \n    ans = [n]\n    while ans[-1] != tree[ans[-1]] and ans[-1] != 1:\n        ans.append(tree[ans[-1]])\n    \n    ans = sorted(set(ans))\n    if ans[0] != 1:\n        ans.append(1)\n    \n    ans = sorted(set(ans))\n    print(len(ans))\n    print(\" \".join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1703",
        "hidden_test_path": "/id/hidden/1703",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "visitingcities1203",
        "topic": "Chương 1",
        "sub_topic": "Advanced Graph Problems",
        "name": "Visiting Cities",
        "description": "You want to travel from Syrjälä to Lehmälä by plane using a minimum-price route. Which cities will you certainly visit?\n\nInput\n\nThe first input line contains two integers n and m : the number of cities and the number of flights. The cities are numbered 1,2,…,n . City 1 is Syrjälä, and city n is Lehmälä.\n\nAfter this, there are m lines describing the flights. Each line has three integers a , b , and c : there is a flight from city a to city b with price c . All flights are one-way flights.\n\nYou may assume that there is a route from Syrjälä to Lehmälä.\n\nOutput\n\nFirst print an integer k : the number of cities that are certainly in the route. After this, print the k cities sorted in increasing order.\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n 1 ≤ c ≤ 10^9\n\nExample\n\nInput:\n\n\n5 6\n1 2 3\n1 3 4\n2 3 1\n2 4 5\n3 4 1\n4 5 8\n\n\nOutput:\n\n\n4\n1 3 4 5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport random\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\nindex = 0\n\ndef next_int():\n    global index\n    value = int(data[index])\n    index += 1\n    return value\n\nN = next_int()\nM = next_int()\n\nINF = 0x3f3f3f3f3f3f3f3f\nMOD1 = random.randint(10**9, 2 * 10**9)\nMOD2 = random.randint(10**9, 2 * 10**9)\n\ndist = [[INF] * (N + 1) for _ in range(2)]\nways = [[[0] * (N + 1) for _ in range(2)] for _ in range(2)]\nG = [[[] for _ in range(N + 1)] for _ in range(2)]\nans = []\n\ndef init():\n    for t in range(2):\n        for i in range(1, N + 1):\n            dist[t][i] = INF\n\ndef dijkstra(type, source):\n    Q = []\n    dist[type][source] = 0\n    ways[type][0][source] = 1\n    ways[type][1][source] = 1\n    heapq.heappush(Q, (0, source))\n    \n    while Q:\n        d, u = heapq.heappop(Q)\n\n        if d > dist[type][u]:\n            continue\n        \n        for v, w in G[type][u]:\n            if dist[type][v] > d + w:\n                ways[type][0][v] = ways[type][0][u]\n                ways[type][1][v] = ways[type][1][u]\n                dist[type][v] = d + w\n                heapq.heappush(Q, (d + w, v))\n            elif dist[type][v] == d + w:\n                ways[type][0][v] = (ways[type][0][v] + ways[type][0][u]) % MOD1\n                ways[type][1][v] = (ways[type][1][v] + ways[type][1][u]) % MOD2\n\nfor _ in range(M):\n    a = next_int()\n    b = next_int()\n    c = next_int()\n    G[0][a].append((b, c))\n    G[1][b].append((a, c))\n\ninit()\ndijkstra(0, 1)\ndijkstra(1, N)\n\ntot1 = ways[0][0][N]\ntot2 = ways[0][1][N]\nfor u in range(1, N + 1):\n    ways1 = ways[0][0][u] * ways[1][0][u] % MOD1\n    ways2 = ways[0][1][u] * ways[1][1][u] % MOD2\n    if ways1 == tot1 and ways2 == tot2 and dist[0][u] + dist[1][u] == dist[0][N]:\n        ans.append(u)\n\nK = len(ans)\nprint(K)\nprint(' '.join(map(str, ans)))",
        "public_test_path": "/id/public/1203",
        "hidden_test_path": "/id/hidden/1203",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "networkrenovation1704",
        "topic": "Chương 1",
        "sub_topic": "Advanced Graph Problems",
        "name": "Network Renovation",
        "description": "Syrjälä's network consists of n computers and n-1 connections between them. It is possible to send data between any two computers.\n\nHowever, if any connection breaks down, it will no longer be possible to send data between some computers. Your task is to add the minimum number of new connections in such a way that you can still send data between any two computers even if any single connection breaks down.\n\nInput\n\nThe first input line has an integer n : the number of computers. The computers are numbered 1,2,…,n .\n\nAfter this, there are n-1 lines describing the connections. Each line has two integers a and b : there is a connection between computers a and b .\n\nOutput\n\nFirst print an integer k : the minimum number of new connections. After this, print k lines describing the connections. You can print any valid solution.\n\nConstraints\n\n3 ≤ n ≤ 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5\n1 2\n1 3\n3 4\n3 5\n\n\nOutput:\n\n\n2\n2 4\n4 5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    adj = defaultdict(list)\n    \n    for i in range(1, n):\n        a, b = map(int, data[i].split())\n        a -= 1\n        b -= 1\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    leaves = []\n    \n    def dfs(cur, par):\n        if len(adj[cur]) == 1:\n            leaves.append(cur)\n        for nex in adj[cur]:\n            if nex == par:\n                continue\n            dfs(nex, cur)\n    \n    dfs(0, -1)\n    \n    edges = []\n    n1 = len(leaves) // 2 * 2\n    for i in range(n1 // 2):\n        edges.append((1 + leaves[i], 1 + leaves[n1 // 2 + i]))\n    \n    if n1 < len(leaves):\n        edges.append((1 + leaves[0], 1 + leaves[-1]))\n    \n    print(len(edges))\n    for u, v in edges:\n        print(u, v)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1704",
        "hidden_test_path": "/id/hidden/1704",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 21
    },
    {
        "problem_id": "forbiddencities1705",
        "topic": "Chương 1",
        "sub_topic": "Advanced Graph Problems",
        "name": "Forbidden Cities",
        "description": "There are n cities and m roads between them. Kaaleppi is currently in city a and wants to travel to city b .\n\nHowever, there is a problem: Kaaleppi has recently robbed a bank in city c and can't enter the city, because the local police would catch him. Your task is to find out if there is a route from city a to city b that does not visit city c .\n\nAs an additional challenge, you have to process q queries where a , b and c vary.\n\nInput\n\nThe first input line has three integers n , m and q : the number of cities, roads and queries. The cities are numbered 1,2,…,n .\n\nThen, there are m lines describing the roads. Each line has two integers a and b : there is a road between cities a and b . Each road is bidirectional.\n\nFinally, there are q lines describing the queries. Each line has three integers a , b and c : is there a route from city a to city b that does not visit city c ?\n\nYou can assume that there is a route between any two cities.\n\nOutput\n\nFor each query, print \"YES\", if there is such a route, and \"NO\" otherwise.\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ q ≤ 10^5 1 ≤ a,b,c ≤ n\n\nExample\n\nInput:\n\n\n5 6 3\n1 2\n1 3\n2 3\n2 4\n3 4\n4 5\n1 4 2\n3 5 4\n3 5 2\n\n\nOutput:\n\n\nYES\nNO\nYES",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport sys\nimport itertools\n\ninput = sys.stdin.read\nsys.setrecursionlimit(10**6)\n\nn, m, q = map(int, input().split())\nbelong = [0] * m\nnum = [0] * n\nst = []\ned = defaultdict(list)\nTime = 0\nncomps = 0\n\ndef dfs(at, par, f):\n    global Time, st\n    me = num[at] = Time + 1\n    Time += 1\n    top = me\n    for y, e in ed[at]:\n        if e != par:\n            if num[y]:\n                top = min(top, num[y])\n                if num[y] < me:\n                    st.append(e)\n            else:\n                si = len(st)\n                up = dfs(y, e, f)\n                top = min(top, up)\n                if up >= me:\n                    st.append(e)\n                    f(st[si:])\n                    st = st[:si]\n                elif up < me:\n                    st.append(e)\n    return top\n\ndef bicomps(f):\n    global ncomps\n    for i in range(len(ed)):\n        if not num[i]:\n            dfs(i, -1, f)\n\ndef assign(e):\n    global ncomps\n    for i in e:\n        belong[i] = ncomps\n    ncomps += 1\n\nclass RMQ:\n    def __init__(self, V):\n        self.jmp = [V]\n        pw = 1\n        k = 1\n        while pw * 2 <= len(V):\n            self.jmp.append([0] * (len(V) - pw * 2 + 1))\n            for j in range(len(self.jmp[k])):\n                self.jmp[k][j] = min(self.jmp[k - 1][j], self.jmp[k - 1][j + pw])\n            pw *= 2\n            k += 1\n\n    def query(self, a, b):\n        assert a < b\n        dep = 31 - (b - a).bit_length() + 1\n        return min(self.jmp[dep][a], self.jmp[dep][b - (1 << dep)])\n\nclass LCA:\n    def __init__(self, C):\n        self.T = 0\n        self.time = [0] * len(C)\n        self.path = []\n        self.ret = []\n        self.rmq = RMQ(self.dfs(C, 0, -1))\n\n    def dfs(self, C, v, par):\n        self.time[v] = self.T\n        self.T += 1\n        for y in C[v]:\n            if y != par:\n                self.path.append(v)\n                self.ret.append(self.time[v])\n                self.dfs(C, y, v)\n\n    def lca(self, a, b):\n        if a == b:\n            return a\n        a, b = min(self.time[a], self.time[b]), max(self.time[a], self.time[b])\n        return self.path[self.rmq.query(a, b)]\n\ned = defaultdict(list)\nfor i in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    ed[a].append((b, i))\n    ed[b].append((a, i))\n\nbicomps(assign)\nrl = {}\nisart = [0] * n\n\nfor i in range(n):\n    bccs = set()\n    for b, id in ed[i]:\n        bccs.add(belong[id])\n    if len(bccs) > 1:\n        rl[i] = ncomps\n        isart[i] = 1\n    else:\n        rl[i] = next(iter(bccs))\n\nadj = [[] for _ in range(ncomps)]\nfor i in range(n):\n    if not isart[i]:\n        continue\n    bccs = set()\n    for b, id in ed[i]:\n        bccs.add(belong[id])\n    for id in bccs:\n        adj[id].append(rl[i])\n        adj[rl[i]].append(id)\n\nlc = LCA(adj)\n\noutput = []\nfor _ in range(q):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    c -= 1\n    if a == c or b == c:\n        output.append(\"NO\")\n        continue\n    a, b = rl[a], rl[b]\n    \n    if a == b or not isart[c]:\n        output.append(\"YES\")\n        continue\n    \n    c = rl[c]\n    l = lc.lca(a, b)\n    if lc.lca(l, c) == l and (lc.lca(a, c) == c or lc.lca(b, c) == c):\n        output.append(\"NO\")\n    else:\n        output.append(\"YES\")\n\nprint(\"\\n\".join(output))",
        "public_test_path": "/id/public/1705",
        "hidden_test_path": "/id/hidden/1705",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "creatingoffices1752",
        "topic": "Chương 1",
        "sub_topic": "Advanced Graph Problems",
        "name": "Creating Offices",
        "description": "There are n cities and n-1 roads between them. There is a unique route between any two cities, and their distance is the number of roads on that route.\n\nA company wants to have offices in some cities, but the distance between any two offices has to be at least d . What is the maximum number of offices they can have?\n\nInput\n\nThe first input line has two integers n and d : the number of cities and the minimum distance. The cities are numbered 1,2,…,n .\n\nAfter this, there are n-1 lines describing the roads. Each line has two integers a and b : there is a road between cities a and b .\n\nOutput\n\nFirst print an integer k : the maximum number of offices. After that, print the cities which will have offices. You can print any valid solution.\n\nConstraints\n\n1 ≤ n,d ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 3\n1 2\n2 3\n3 4\n3 5\n\n\nOutput:\n\n\n2\n1 4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport sys\nimport itertools\n\ninput = sys.stdin.read\n\nclass Centroid:\n    def __init__(self, adj, f):\n        self.adj = adj\n        self.f = f\n        self.sub_sz = [-1] * len(adj)\n        self.par = [-1] * len(adj)\n        for i in range(len(adj)):\n            if self.sub_sz[i] == -1:\n                self.dfs(i)\n\n    def calc_sz(self, u, p):\n        self.sub_sz[u] = 1\n        for v in self.adj[u]:\n            if v != p:\n                self.calc_sz(v, u)\n                self.sub_sz[u] += self.sub_sz[v]\n\n    def dfs(self, u):\n        self.calc_sz(u, -1)\n        sz_root = self.sub_sz[u]\n        p = -1\n        while True:\n            big_ch = next((v for v in self.adj[u] if v != p and 2 * self.sub_sz[v] > sz_root), None)\n            if big_ch is None:\n                break\n            p, u = u, big_ch\n        self.f(self.adj, u)\n        for v in self.adj[u]:\n            self.adj[v].remove(u)\n            self.par[self.dfs(v)] = u\n        return u\n\nclass RMQ:\n    def __init__(self, V):\n        self.jmp = [V]\n        n = len(V)\n        k = 1\n        while (1 << k) <= n:\n            jmp_k = [0] * (n - (1 << k) + 1)\n            for j in range(len(jmp_k)):\n                jmp_k[j] = min(self.jmp[k - 1][j], self.jmp[k - 1][j + (1 << (k - 1))])\n            self.jmp.append(jmp_k)\n            k += 1\n\n    def query(self, a, b):\n        assert a < b\n        dep = 31 - (b - a).bit_length() + 1\n        return min(self.jmp[dep][a], self.jmp[dep][b - (1 << dep)])\n\nclass LCA:\n    def __init__(self, C):\n        self.T = 0\n        self.time = [0] * len(C)\n        self.path = []\n        self.ret = []\n        self.depth = [0] * len(C)\n        self.rmq = RMQ(self.dfs(C, 0, -1))\n\n    def dfs(self, C, v, par):\n        self.time[v] = self.T\n        self.T += 1\n        for y in C[v]:\n            if y != par:\n                self.path.append(v)\n                self.ret.append(self.time[v])\n                self.depth[y] = self.depth[v] + 1\n                self.dfs(C, y, v)\n\n    def lca(self, a, b):\n        if a == b:\n            return a\n        a, b = min(self.time[a], self.time[b]), max(self.time[a], self.time[b])\n        return self.path[self.rmq.query(a, b)]\n\n    def dist(self, a, b):\n        return self.depth[a] + self.depth[b] - 2 * self.depth[self.lca(a, b)]\n\ndef main():\n    input_data = input().split()\n    n = int(input_data[0])\n    k = int(input_data[1])\n    adj = defaultdict(list)\n    \n    index = 2\n    for _ in range(n - 1):\n        u = int(input_data[index]) - 1\n        v = int(input_data[index + 1]) - 1\n        adj[u].append(v)\n        adj[v].append(u)\n        index += 2\n\n    centroids = [[] for _ in range(n)]\n    lca = LCA(adj)\n    cc = Centroid(adj, lambda v, c: None)\n    ord = list(range(n))\n    ord.sort(key=lambda x: lca.depth[x], reverse=True)\n    \n    ans = []\n    closest = [k + 10] * n\n    for i in ord:\n        c = float('inf')\n        u = i\n        while u != -1:\n            c = min(lca.dist(i, u) + closest[u], c)\n            u = cc.par[u]\n        if c < k:\n            continue\n        ans.append(i)\n        u = i\n        while u != -1:\n            closest[u] = min(closest[u], lca.dist(i, u))\n            u = cc.par[u]\n\n    print(len(ans))\n    print(' '.join(str(i + 1) for i in ans))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1752",
        "hidden_test_path": "/id/hidden/1752",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 22
    },
    {
        "problem_id": "newflightroutes1685",
        "topic": "Chương 1",
        "sub_topic": "Advanced Graph Problems",
        "name": "New Flight Routes",
        "description": "There are n cities and m flight connections between them. Your task is to add new flights so that it will be possible to travel from any city to any other city. What is the minimum number of new flights required?\n\nInput\n\nThe first input line has two integers n and m : the number of cities and flights. The cities are numbered 1,2,…,n .\n\nAfter this, there are m lines describing the flights. Each line has two integers a and b : there is a flight from city a to city b . All flights are one-way flights.\n\nOutput\n\nFirst print an integer k : the required number of new flights. After this, print k lines describing the new flights. You can print any valid solution.\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n4 5\n1 2\n2 3\n3 1\n1 4\n3 4\n\n\nOutput:\n\n\n1\n4 2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\n\ns = []\nval = []\ncomp = []\nz = []\ncont = []\nTime = 0\nncomps = 0\n\ndef dfs(j, g, f):\n    global Time, ncomps\n    low = val[j] = Time + 1\n    global z\n    z.append(j)\n    for e in g[j]:\n        if comp[e] < 0:\n            low = min(low, val[e] if val[e] != 0 else dfs(e, g, f))\n\n    if low == val[j]:\n        while True:\n            x = z.pop()\n            comp[x] = ncomps\n            cont.append(x)\n            if x == j:\n                break\n        f(cont)\n        cont.clear()\n        ncomps += 1\n    return val[j] = low\n\ndef addscc(v):\n    s.append(v)\n\ndef scc(g, f):\n    global val, comp, Time, ncomps\n    n = len(g)\n    val = [0] * n\n    comp = [-1] * n\n    Time = ncomps = 0\n    for i in range(n):\n        if comp[i] < 0:\n            dfs(i, g, f)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    adj = [[] for _ in range(n)]\n    \n    index = 2\n    for _ in range(m):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        adj[a].append(b)\n        index += 2\n\n    scc(adj, addscc)\n    sadj = [[] for _ in range(ncomps)]\n    rsadj = [[] for _ in range(ncomps)]\n    cadj = [[] for _ in range(ncomps)]\n    \n    for i in range(ncomps):\n        for j in s[i]:\n            for k in adj[j]:\n                sadj[comp[j]].append(comp[k])\n                rsadj[comp[k]].append(comp[j])\n                cadj[comp[j]].append(comp[k])\n                cadj[comp[k]].append(comp[j])\n\n    sinks = []\n    sources = []\n    issource = [False] * ncomps\n    issink = [False] * ncomps\n    \n    for i in range(ncomps):\n        if len(sadj[i]) == 0:\n            sinks.append(i)\n            issink[i] = True\n        if len(rsadj[i]) == 0:\n            sources.append(i)\n            issource[i] = True\n\n    ans = []\n    mc = [-1] * ncomps\n    mcsource = []\n    mcsink = []\n\n    def dfs_func(cur, cm):\n        if mc[cur] != -1:\n            return\n        mc[cur] = cm\n        if issource[cur]:\n            mcsource[cm].append(cur)\n        if issink[cur]:\n            mcsink[cm].append(cur)\n        for nex in cadj[cur]:\n            dfs_func(nex, cm)\n\n    for i in range(ncomps):\n        if mc[i] != -1:\n            continue\n        mcsource.append([])\n        mcsink.append([])\n        dfs_func(i, len(mcsource) - 1)\n\n    cm = len(mcsource)\n    for i in range(cm):\n        j = (i + 1) % cm\n        ans.append((mcsink[i][-1], mcsource[j][-1]))\n        mcsink[i].pop()\n        mcsource[j].pop()\n\n    leftsources = []\n    leftsinks = []\n    for i in range(cm):\n        leftsources.extend(mcsource[i])\n        leftsinks.extend(mcsink[i])\n\n    mn = min(len(leftsources), len(leftsinks))\n    for i in range(mn - 1):\n        pass\n\n    while leftsources and leftsinks:\n        while len(leftsources) > 1 and leftsources[-1] == leftsinks[-1]:\n            leftsources[-1], leftsources[-2] = leftsources[-2], leftsources[-1]\n        if leftsources[-1] == leftsinks[-1]:\n            break\n        ans.append((leftsinks[-1], leftsources[-1]))\n        leftsinks.pop()\n        leftsources.pop()\n\n    for i in leftsinks:\n        for j in sources:\n            if i != j:\n                ans.append((i, j))\n                break\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1685",
        "hidden_test_path": "/id/hidden/1685",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 27
    },
    {
        "problem_id": "emptystring1080",
        "topic": "Chương 1",
        "sub_topic": "Counting Problems",
        "name": "Empty String",
        "description": "You are given a string consisting of n characters between a and z.\n\nOn each turn, you may remove any two adjacent characters that are equal. Your goal is to construct an empty string by removing all the characters.\n\nIn how many ways can you do this?\n\nInput\n\nThe only input line has a string of length n .\n\nOutput\n\nPrint one integer: the number of ways modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 500\n\nExample\n\nInput:\n\n\naabccb\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = int(1e9 + 7)\nLIM = int(1e3 + 10)\n\ninv = [0] * LIM\nfact = [0] * LIM\ninvfact = [0] * LIM\n\ndef mod(k):\n    return k % MOD\n\ndef main():\n    fact[0] = invfact[0] = 1\n    inv[1] = fact[1] = invfact[1] = 1\n    for i in range(2, LIM):\n        inv[i] = MOD - (MOD // i) * inv[MOD % i] % MOD\n        fact[i] = mod(i * fact[i - 1])\n        invfact[i] = mod(inv[i] * invfact[i - 1])\n\n    def choose(a, b):\n        return mod(fact[a] * mod(invfact[a - b] * invfact[b]))\n\n    str_input = input().strip()\n    n = len(str_input)\n    dp = [[0] * n for _ in range(n + 1)]\n    \n    for i in range(n):\n        dp[i + 1][i] = 1\n\n    for length in range(2, n + 1):\n        for l in range(n - length + 1):\n            r = l + length - 1\n            if length == 2:\n                dp[l][r] = str_input[l] == str_input[r]\n                continue\n            for len1 in range(2, length, 2):\n                if str_input[l] == str_input[l + len1 - 1]:\n                    dp[l][r] = mod(dp[l][r] + mod(mod(choose(length // 2, len1 // 2) * dp[l + 1][l + len1 - 2]) * dp[l + len1][r]))\n            if str_input[l] == str_input[r]:\n                dp[l][r] = mod(dp[l][r] + dp[l + 1][r - 1])\n\n    print(dp[0][n - 1])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1080",
        "hidden_test_path": "/id/hidden/1080",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "permutationinversions2229",
        "topic": "Chương 1",
        "sub_topic": "Counting Problems",
        "name": "Permutation Inversions",
        "description": "Your task is to count the number of permutations of 1,2,…,n that have exactly k inversions (i.e., pairs of elements in the wrong order).\n\nFor example, when n=4 and k=3 , there are 6 such permutations:\n\n[1,4,3,2] [2,3,4,1] [2,4,1,3] [3,1,4,2] [3,2,1,4] [4,1,2,3]\n\nInput\n\nThe only input line has two integers n and k .\n\nOutput\n\nPrint the answer modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 500 0 ≤ k ≤ \\frac{n(n-1)}{2}\n\nExample\n\nInput:\n\n\n4 3\n\n\nOutput:\n\n\n6",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\nmaxk = 500 * 499 // 2 + 5\ndp = [[0] * maxk for _ in range(501)]\n\nMOD = 10**9 + 7\n\ndef mod(k):\n    k %= MOD\n    if k < 0:\n        k = (k + MOD) % MOD\n    return k\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    \n    dp[0][0] = 1\n    dp[0][1] = -1\n    \n    for i in range(n):\n        pref = 0\n        for j in range(maxk):\n            pref = mod(pref + dp[i][j])\n            if pref == 0:\n                continue\n            dp[i + 1][j] = mod(dp[i + 1][j] + pref)\n            if j + i + 1 + 1 < maxk:\n                dp[i + 1][j + i + 1 + 1] = mod(dp[i + 1][j + i + 1 + 1] - pref)\n    \n    pref = 0\n    for j in range(k + 1):\n        pref = mod(pref + dp[n - 1][j])\n    \n    print(pref)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2229",
        "hidden_test_path": "/id/hidden/2229",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "countingbishops2176",
        "topic": "Chương 1",
        "sub_topic": "Counting Problems",
        "name": "Counting Bishops",
        "description": "Your task is to count the number of ways k bishops can be placed on an n × n chessboard so that no two bishops attack each other.\n\nTwo bishops attack each other if they are on the same diagonal.\n\nInput\n\nThe only input line has two integers n and k : the board size and the number of bishops.\n\nOutput\n\nPrint one integer: the number of ways modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 500 1 ≤ k ≤ n^2\n\nExample\n\nInput:\n\n\n5 4\n\n\nOutput:\n\n\n2728",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = int(1e9 + 7)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n\n    to = [0] * (2 * n - 1)\n    for i in range(n):\n        for j in range(n):\n            to[i + j] += 1\n\n    totdp = []\n    for t in range(2):\n        cands = []\n        for i in range(len(to)):\n            if (i & 1) == t:\n                cands.append(to[i])\n        cands.sort()\n\n        cnt = []\n        items = []\n        for i in range(len(cands)):\n            if i == 0 or cands[i] != cands[i - 1]:\n                cnt.append(0)\n                items.append(cands[i] - (0 if i == 0 else cands[i - 1]))\n            cnt[-1] += 1\n\n        cnt.reverse()\n        items.reverse()\n        for i in range(1, len(cnt)):\n            cnt[i] += cnt[i - 1]\n\n        dp = [[-1] * (n + 1) for _ in range(len(cnt) + 1)]\n\n        def go(layer, used):\n            if dp[layer + 1][used] != -1:\n                return dp[layer + 1][used]\n            if layer == -1:\n                return 1 if used == 0 else 0\n\n            ans = 0\n            ans += go(layer - 1, used)\n\n            if used >= 1 and items[layer] >= 1:\n                free = cnt[layer] - (used - 1)\n                if free >= 1:\n                    ans += free * items[layer] * go(layer - 1, used - 1)\n                    ans %= MOD\n\n            if used >= 2 and items[layer] >= 2:\n                free = cnt[layer] - (used - 2)\n                if free >= 2:\n                    ans += (free * (free - 1) % MOD) * go(layer - 1, used - 2)\n                    ans %= MOD\n\n            ans %= MOD\n            return ans\n\n        totdp.append([])\n        for i in range(n + 1):\n            v = go(len(cnt) - 1, i)\n            totdp[-1].append(v)\n\n    ans = 0\n    for i in range(n + 1):\n        for j in range(n + 1):\n            if i < len(totdp[0]) and j < len(totdp[1]) and i + j == k:\n                ans += (totdp[0][i] * totdp[1][j] % MOD)\n                ans %= MOD\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2176",
        "hidden_test_path": "/id/hidden/2176",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "countingsequences2228",
        "topic": "Chương 1",
        "sub_topic": "Counting Problems",
        "name": "Counting Sequences",
        "description": "Your task is to count the number of sequences of length n where each element is an integer between 1 … k and each integer between 1 … k appears at least once in the sequence.\n\nFor example, when n=6 and k=4 , some valid sequences are [1,3,1,4,3,2] and [2,2,1,3,4,2] .\n\nInput\n\nThe only input line has two integers n and k .\n\nOutput\n\nPrint one integer: the number of sequences modulo 10^9+7 .\n\nConstraints\n\n1 ≤ k ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\n6 4\n\n\nOutput:\n\n\n1560",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "LIM = int(1e6 + 10)\ninv = [0] * LIM\nfact = [0] * LIM\ninvfact = [0] * LIM\nMOD = int(1e9 + 7)\n\ndef mod(k):\n    return k % MOD\n\ndef mod1(k):\n    return (k % MOD + MOD) % MOD\n\ndef modpow(b, p):\n    if p == 0:\n        return 1\n    if p == 1:\n        return b\n    res = modpow(b, p // 2)\n    res = mod(res * res)\n    res = mod(res * modpow(b, p % 2))\n    return res\n\nn, k = map(int, input().split())\nfact[0] = invfact[0] = 1\ninv[1] = fact[1] = invfact[1] = 1\n\nfor i in range(2, LIM):\n    inv[i] = MOD - (MOD // i) * inv[MOD % i] % MOD\n    fact[i] = mod(i * fact[i - 1])\n    invfact[i] = mod(inv[i] * invfact[i - 1])\n\ndef choose(a, b):\n    return mod(fact[a] * mod(invfact[a - b] * invfact[b]))\n\nans = 0\nfor i in range(k):\n    ans = mod(ans + mod1((1 if i % 2 == 0 else -1) * choose(k, i) * modpow(k - i, n)))\n\nprint(ans)",
        "public_test_path": "/id/public/2228",
        "hidden_test_path": "/id/hidden/2228",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "gridcompletion2429",
        "topic": "Chương 1",
        "sub_topic": "Counting Problems",
        "name": "Grid Completion",
        "description": "Your task is to create an n × n grid whose each row and column has exactly one A and B. Some of the characters have already been placed. In how many ways can you complete the grid?\n\nInput\n\nThe first input line has an integer n : the size of the grid.\n\nAfter this, there are n lines that describe the grid. Each line has n characters: . means an empty square, and A and B show the characters already placed.\n\nYou can assume that every row and column has at most one A and B.\n\nOutput\n\nPrint one integer: the number of ways modulo 10^9+7 .\n\nConstraints\n\n2 ≤ n ≤ 500\n\nExample\n\nInput:\n\n\n5\n.....\n..AB.\n.....\nB....\n...A.\n\n\nOutput:\n\n\n16",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import defaultdict\n\nMOD = int(1e9 + 7)\n\nclass Comb:\n    def __init__(self):\n        self.inv = 1\n        self.fact = 1\n        self.inv_fact = 1\n\nt = [Comb() for _ in range(2)]\n\ndef grow(n):\n    while len(t) <= n:\n        i = len(t)\n        inv = MOD - (MOD // i) * t[MOD % i].inv % MOD\n        t.append(Comb())\n        t[i].inv = inv\n        t[i].fact = i * t[i - 1].fact % MOD\n        t[i].inv_fact = inv * t[i - 1].inv_fact % MOD\n\ndef C(n, k):\n    if k < 0 or n < k:\n        return 0\n    grow(n)\n    return t[n].fact * t[k].inv_fact % MOD * t[n - k].inv_fact % MOD\n\nN = 501\ndp = [[[-1] * N for _ in range(N)] for _ in range(N)]\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    grid = data[1:n + 1]\n    \n    ac = [-1] * n\n    bc = [-1] * n\n    \n    for c in range(n):\n        for r in range(n):\n            if grid[r][c] == 'A':\n                ac[c] = r\n            if grid[r][c] == 'B':\n                bc[c] = r\n    \n    cleared = 0\n    astate = [0] * n\n    bstate = [0] * n\n    \n    for i in range(n):\n        if ac[i] != -1 and bc[i] != -1:\n            astate[ac[i]] = bstate[bc[i]] = 2\n        elif ac[i] != -1:\n            astate[ac[i]] = 1\n        elif bc[i] != -1:\n            bstate[bc[i]] = 1\n        else:\n            cleared += 1\n\n    cnt = [0] * 9\n    for i in range(n):\n        cnt[bstate[i] * 3 + astate[i]] += 1\n\n    def go(ona, onb, offb):\n        ans = dp[ona][onb][offb]\n        if ans != -1:\n            return ans\n        if ona == 0 and onb == 0 and offb == 0:\n            return 1\n        assert onb >= 0 and ona >= 0 and offb >= 0\n        res = 0\n        if ona:\n            if offb:\n                res += offb * go(ona - 1, onb, offb - 1) % MOD\n        else:\n            if offb:\n                res += offb * go(ona, onb, offb - 1) % MOD\n            if onb:\n                res += onb * go(ona, onb - 1, offb) % MOD\n        return res % MOD\n\n    ona = onb = matcheda = matchedb = offa = offb = 0\n    for a in range(3):\n        for b in range(3):\n            if a == 2:\n                matcheda += cnt[b * 3 + a]\n            if a == 1:\n                ona += cnt[b * 3 + a]\n            if a == 0:\n                offa += cnt[b * 3 + a]\n            if b == 2:\n                matchedb += cnt[b * 3 + a]\n            if b == 1:\n                onb += cnt[b * 3 + a]\n            if b == 0:\n                offb += cnt[b * 3 + a]\n\n    ans = 0\n    for i in range(1 + cnt[0]):\n        for j in range(1 + cnt[3]):\n            for k in range(1 + cnt[1]):\n                offa -= i\n                offb -= i\n                offa -= j\n                onb -= j\n                ona -= k\n                offb -= k\n                ways = (C(cnt[0], i) * C(cnt[3], j) % MOD * C(cnt[1], k) % MOD)\n                par = 1 if (i + j + k) % 2 == 0 else -1\n                w = go(ona, onb, offb)\n                ans = (ans + w * ways * par) % MOD\n                offa += i\n                offb += i\n                offa += j\n                onb += j\n                ona += k\n                offb += k\n\n    grow(2 * n + 10)\n    ans = (ans + MOD) % MOD\n    ans = (ans * t[cleared].fact) % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2429",
        "hidden_test_path": "/id/hidden/2429",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    },
    {
        "problem_id": "countingreorders2421",
        "topic": "Chương 1",
        "sub_topic": "Counting Problems",
        "name": "Counting Reorders",
        "description": "Calculate the number of ways you can reorder the characters of a string so that no two adjacent characters are the same.\n\nFor example, the answer for aabc is 6 , because the possible orders are abac , abca , acab , acba , baca , and caba .\n\nInput\n\nThe only input line has a string that consists of n characters between a – z .\n\nOutput\n\nPrint an integer: the answer modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 5000\n\nExample\n\nInput:\n\n\naabc\n\n\nOutput:\n\n\n6",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from cmath import polar, acos\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef mod(k):\n    return k % MOD\n\ndef fft(a):\n    n = len(a)\n    L = 31 - (n - 1).bit_length()\n    R = [1] * (2 * n)\n    rt = [1] * (2 * n)\n    for k in range(2, n * 2, k * 2):\n        x = polar(1.0, acos(-1.0) / k)\n        for i in range(k, 2 * k):\n            rt[i] = R[i] = R[i // 2] * x if i & 1 else R[i // 2]\n    rev = [(rev[i // 2] | (i & 1) << L) // 2 for i in range(n)]\n    for i in range(n):\n        if i < rev[i]:\n            a[i], a[rev[i]] = a[rev[i]], a[i]\n    for k in range(1, n, k * 2):\n        for i in range(0, n, 2 * k):\n            for j in range(k):\n                z = rt[j + k] * a[i + j + k]\n                a[i + j + k] = a[i + j] - z\n                a[i + j] += z\n\ndef conv(a, b):\n    if not a or not b:\n        return []\n    res = [0] * (len(a) + len(b) - 1)\n    L = 32 - (len(res) - 1).bit_length()\n    n = 1 << L\n    in_ = [0] * n\n    out = [0] * n\n    for i in range(len(a)):\n        in_[i] = complex(a[i], 0)\n    for i in range(len(b)):\n        in_[i] = complex(in_[i].real, b[i])\n    fft(in_)\n    for i in range(n):\n        in_[i] *= in_[i]\n    for i in range(n):\n        out[i] = in_[-i & (n - 1)] - in_[i].conjugate()\n    fft(out)\n    for i in range(len(res)):\n        res[i] = out[i].imag / (4 * n)\n    return res\n\ndef convMod(a, b):\n    if not a or not b:\n        return []\n    res = [0] * (len(a) + len(b) - 1)\n    B = 32 - (len(res) - 1).bit_length()\n    n = 1 << B\n    cut = int(MOD**0.5)\n    L = [0] * n\n    R = [0] * n\n    outs = [0] * n\n    outl = [0] * n\n    for i in range(len(a)):\n        L[i] = complex(a[i] // cut, a[i] % cut)\n    for i in range(len(b)):\n        R[i] = complex(b[i] // cut, b[i] % cut)\n    fft(L)\n    fft(R)\n    for i in range(n):\n        j = -i & (n - 1)\n        outl[j] = (L[i] + L[j].conjugate()) * R[i] / (2.0 * n)\n        outs[j] = (L[i] - L[j].conjugate()) * R[i] / (2.0 * n) / 1j\n    fft(outl)\n    fft(outs)\n    for i in range(len(res)):\n        av = int(outl[i].real + 0.5)\n        cv = int(outs[i].imag + 0.5)\n        bv = int(outl[i].imag + 0.5) + int(outs[i].real + 0.5)\n        res[i] = ((av % MOD * cut + bv) % MOD * cut + cv) % MOD\n    return res\n\nclass ModChoose:\n    def __init__(self, n, m):\n        self.MOD = m\n        self.LIM = n + 1\n        self.inv = [0] * self.LIM\n        self.fact = [0] * self.LIM\n        self.invfact = [0] * self.LIM\n        self.fact[0] = self.invfact[0] = self.inv[1] = self.fact[1] = self.invfact[1] = 1\n        for i in range(2, self.LIM):\n            self.inv[i] = self.MOD - (self.MOD // i) * self.inv[self.MOD % i] % self.MOD\n            self.fact[i] = (i * self.fact[i - 1]) % self.MOD\n            self.invfact[i] = (self.inv[i] * self.invfact[i - 1]) % self.MOD\n\n    def choose(self, n, k):\n        if k > n or k < 0:\n            return 0\n        return (self.fact[n] * self.invfact[k]) % self.MOD * self.invfact[n - k] % self.MOD\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    str_input = input().strip()\n    freq = [0] * 26\n    for c in str_input:\n        freq[ord(c) - ord('a')] += 1\n    freq.sort(reverse=True)\n    types = sum(1 for f in freq if f > 0)\n    n = len(str_input)\n    mc = ModChoose(2 * n + 100, MOD)\n    negone = MOD - 1\n    negpow = [1] * (n + 5)\n    for i in range(1, len(negpow)):\n        negpow[i] = mod(negpow[i - 1] * negone)\n    dp = [[0] * (n + 1) for _ in range(types + 1)]\n    for i in range(n + 1):\n        dp[0][i] = mc.fact[i]\n    for i in range(1, types + 1):\n        f = [0] * freq[i - 1]\n        for k in range(freq[i - 1]):\n            f[k] = mod(negpow[k] * mod(mc.invfact[freq[i - 1] - k] * mc.choose(freq[i - 1] - 1, k)))\n        dp[i] = convMod(dp[i - 1], f)\n        dp[i] = dp[i][:n + 1]\n    print(dp[types][n])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2421",
        "hidden_test_path": "/id/hidden/2421",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 9
    },
    {
        "problem_id": "functionalgraphdistribution2415",
        "topic": "Chương 1",
        "sub_topic": "Counting Problems",
        "name": "Functional Graph Distribution",
        "description": "A functional graph is a directed graph where each node has outdegree 1 . For example, here is a functional graph that has 9 nodes and 2 components: Given n , your task is to calculate for each k=1 … n the number of functional graphs that have n nodes and k components.\n\nInput\n\nThe only input line has an integer n : the number of nodes.\n\nOutput\n\nPrint n lines: for each k=1 … n the number of graphs modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 5000\n\nExample\n\nInput:\n\n\n3\n\n\nOutput:\n\n\n17\n9\n1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = int(1e9 + 7)\n\ndef mod(k):\n    return k % MOD\n\ndef modpow(b, p):\n    if p == 0:\n        return 1\n    if p == 1:\n        return mod(b)\n    res = modpow(b, p // 2)\n    res = mod(res * res)\n    if p % 2 == 1:\n        res = mod(res * b)\n    return res\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    n = int(input().strip())\n    \n    sterling = [[0] * (n + 1) for _ in range(n + 1)]\n    chooses = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    chooses[0][0] = 1\n    sterling[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            sterling[i][j] = mod((i - 1) * sterling[i - 1][j] + sterling[i - 1][j - 1])\n        \n        for j in range(1, i):\n            chooses[i][j] = mod(chooses[i][j] + chooses[i - 1][j - 1])\n            chooses[i][j] = mod(chooses[i][j] + chooses[i - 1][j])\n        \n        chooses[i][0] = chooses[i][i] = 1\n    \n    ans = [0] * (n + 1)\n    pows = [0] * (n + 1)\n    pows[0] = 1\n    \n    for i in range(1, len(pows)):\n        pows[i] = mod(n * pows[i - 1])\n    \n    for k in range(1, n + 1):\n        for a in range(k, n + 1):\n            ans[k] = mod(ans[k] + mod(sterling[a][k] * mod(chooses[n - 1][a - 1] * pows[n - a])))\n        print(ans[k])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2415",
        "hidden_test_path": "/id/hidden/2415",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "swapgame1670",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems I",
        "name": "Swap Game",
        "description": "You are given a 3 × 3 grid containing the numbers 1,2,…,9 . Your task is to perform a sequence of moves so that the grid will look like this: \\begin{matrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9 \\\\\n\\end{matrix} On each move, you can swap the numbers in any two adjacent squares (horizontally or vertically). What is the minimum number of moves required?\n\nInput\n\nThe input has three lines, and each of them has three integers.\n\nOutput\n\nPrint one integer: the minimum number of moves.\n\nExample\n\nInput:\n\n\n2 1 3\n7 5 9\n8 4 6\n\n\nOutput:\n\n\n4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import deque\n\ndef hsh(g):\n    h = 0\n    mult = 1\n    for i in range(3):\n        for j in range(3):\n            h += mult * g[i][j]\n            mult *= 9\n    return h\n\npows = [1] * 15\nfor i in range(1, 15):\n    pows[i] = 9 * pows[i - 1]\n\ndef swp(h, idx1, idx2):\n    v1 = (h % pows[idx1 + 1]) // pows[idx1]\n    v2 = (h % pows[idx2 + 1]) // pows[idx2]\n    return h - pows[idx1] * v1 - pows[idx2] * v2 + pows[idx1] * v2 + pows[idx2] * v1\n\ndef unhash(h):\n    res = [[0] * 3 for _ in range(3)]\n    for i in range(3):\n        for j in range(3):\n            v = h % 9\n            res[i][j] = v\n            h //= 9\n    return res\n\ndef main():\n    grid = [list(map(int, input().split())) for _ in range(3)]\n    for i in range(3):\n        for j in range(3):\n            grid[i][j] -= 1\n\n    target = [[i * 3 + j for j in range(3)] for i in range(3)]\n    targethash = hsh(target)\n\n    seen = [False] * pows[9]\n    q = deque()\n    q.append((hsh(grid), 0))\n    seen[hsh(grid)] = True\n    ans = 0\n\n    while q:\n        h, v = q.popleft()\n        if h == targethash:\n            ans = v\n            break\n\n        for i in range(3):\n            for j in range(2):\n                h1 = swp(h, i * 3 + j, i * 3 + j + 1)\n                if not seen[h1]:\n                    q.append((h1, 1 + v))\n                    seen[h1] = True\n\n        for i in range(2):\n            for j in range(3):\n                h1 = swp(h, i * 3 + j, (i + 1) * 3 + j)\n                if not seen[h1]:\n                    q.append((h1, 1 + v))\n                    seen[h1] = True\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1670",
        "hidden_test_path": "/id/hidden/1670",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 19
    },
    {
        "problem_id": "multiplicationtable2422",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems I",
        "name": "Multiplication Table",
        "description": "Find the middle element when the numbers in an n × n multiplication table are sorted in increasing order. It is assumed that n is odd.\n\nFor example, the 3 × 3 multiplication table is as follows: \\begin{matrix}\n1 & 2 & 3 \\\\\n2 & 4 & 6 \\\\\n3 & 6 & 9 \\\\\n\\end{matrix} The numbers in increasing order are [1,2,2,3,3,4,6,6,9] , so the answer is 3 .\n\nInput\n\nThe only input line has an integer n .\n\nOutput\n\nPrint one integer: the answer to the task.\n\nConstraints\n\n1 ≤ n < 10^6\n\nExample\n\nInput:\n\n\n3\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    n = int(input().strip())\n    lo, hi = 1, n * n\n    target = (n * n + 1) // 2\n    \n    while lo < hi:\n        mid = lo + (hi - lo) // 2\n        cnt = 0\n        for i in range(1, n + 1):\n            cnt += min(n, mid // i)\n        if cnt >= target:\n            hi = mid\n        else:\n            lo = mid + 1\n            \n    print(lo)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2422",
        "hidden_test_path": "/id/hidden/2422",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "advertisement1142",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems I",
        "name": "Advertisement",
        "description": "A fence consists of n vertical boards. The width of each board is 1 and their heights may vary.\n\nYou want to attach a rectangular advertisement to the fence. What is the maximum area of such an advertisement?\n\nInput\n\nThe first input line contains an integer n : the width of the fence.\n\nAfter this, there are n integers k_1,k_2,…,k_n : the height of each board.\n\nOutput\n\nPrint one integer: the maximum area of an advertisement.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ k_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8\n4 1 5 3 3 2 4 1\n\n\nOutput:\n\n\n10",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    from collections import defaultdict\n    from sortedcontainers import SortedSet\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:n+1]))\n    \n    ss = SortedSet()\n    occ = defaultdict(list)\n    \n    for i in range(n):\n        ss.add(a[i])\n        occ[a[i]].append(i)\n    \n    vals = list(ss)\n    \n    ans = n * vals[0]\n    separators = SortedSet([-1, n])\n    ints = SortedSet([n])\n    \n    for i in range(len(vals) - 1):\n        for j in occ[vals[i]]:\n            left = separators[separators.bisect_left(j) - 1]\n            right = separators[separators.bisect_right(j)]\n            ints.remove(right - left - 1)\n            ints.add(j - left - 1)\n            ints.add(right - j - 1)\n            separators.add(j)\n        \n        ans = max(ans, vals[i + 1] * ints[-1])\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1142",
        "hidden_test_path": "/id/hidden/1142",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "specialsubstrings2186",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems I",
        "name": "Special Substrings",
        "description": "A substring is called special if every character that appears in the string appears the same number of times in the substring.\n\nYour task is to count the number of special substrings in a given string.\n\nInput\n\nThe only input line has a string of length n . Every character is between a...z.\n\nOutput\n\nPrint one integer: the number of special substrings.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5\n\nExample\n\nInput:\n\n\nabccabab\n\n\nOutput:\n\n\n5\n\n\nExplanation : The special substrings are abc , cab , abccab , bccaba and ccabab .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport sys\n\ninput = sys.stdin.read\n\ndef main():\n    str_input = input().strip()\n    frq = [0] * 26\n    mm = defaultdict(int)\n    frq1 = [-1] * 26\n    \n    for char in str_input:\n        frq1[ord(char) - ord('a')] = 0\n    mm[tuple(frq1)] += 1\n\n    for char in str_input:\n        frq[ord(char) - ord('a')] += 1\n        a = [-1] * 26\n        mn = float('inf')\n        \n        for j in range(26):\n            if frq1[j] != -1:\n                mn = min(mn, frq[j])\n        \n        for j in range(26):\n            if frq1[j] != -1:\n                a[j] = frq[j] - mn\n        \n        mm[tuple(a)] += 1\n\n    ans = 0\n    for val in mm.values():\n        ans += (val - 1) * val // 2\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2186",
        "hidden_test_path": "/id/hidden/2186",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "stackweights2425",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems I",
        "name": "Stack Weights",
        "description": "You have n coins, each of which has a distinct weight.\n\nThere are two stacks which are initially empty. On each step you move one coin to a stack. You never remove a coin from a stack.\n\nAfter each move, your task is to determine which stack is heavier (if we can be sure that either stack is heavier).\n\nInput\n\nThe first input line has an integer n : the number of coins. The coins are numbered 1,2,…,n . You know that coin i is always heavier than coin i-1 , but you don't know their exact weights.\n\nAfter this, there are n lines that describe the moves. Each line has two integers c and s : move coin c to stack s (1 = left, 2 = right).\n\nOutput\n\nAfter each move, print < if the right stack is heavier, > if the left stack is heavier, and ? if we can't know which stack is heavier.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5\n\nExample\n\nInput:\n\n\n3\n2 1\n3 2\n1 1\n\n\nOutput:\n\n\n>\n<\n?\n\n\nExplanation: After the last move, if the coins are [2,3,4] , the left stack is heavier, but if the coins are [1,2,5] , the right stack is heavier.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import namedtuple\n\npi = namedtuple('pi', ['f', 's'])\n\ninf = int(1e9)\n\nclass Node:\n    def __init__(self, lo, hi):\n        self.l = None\n        self.r = None\n        self.lo = lo\n        self.hi = hi\n        self.madd = 0\n        self.info = pi(0, 0)\n        if lo + 1 < hi:\n            mid = lo + (hi - lo) // 2\n            self.l = Node(lo, mid)\n            self.r = Node(mid, hi)\n            self.comb()\n\n    def combine(self, l, r):\n        return pi(min(l.f, r.f), max(l.s, r.s))\n\n    def comb(self):\n        self.info = self.combine(self.l.info, self.r.info)\n\n    def query(self, L, R):\n        if R <= self.lo or self.hi <= L:\n            return pi(inf, -inf)\n        if L <= self.lo and self.hi <= R:\n            return self.info\n        self.push()\n        return self.combine(self.l.query(L, R), self.r.query(L, R))\n\n    def add(self, L, R, x):\n        if R <= self.lo or self.hi <= L:\n            return\n        if L <= self.lo and self.hi <= R:\n            self.madd += x\n            self.info = pi(self.info.f + x, self.info.s + x)\n        else:\n            self.push()\n            self.l.add(L, R, x)\n            self.r.add(L, R, x)\n            self.comb()\n\n    def push(self):\n        if self.madd:\n            self.l.add(self.lo, self.hi, self.madd)\n            self.r.add(self.lo, self.hi, self.madd)\n            self.madd = 0\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    n = int(data[0])\n    tree = Node(0, n)\n    results = []\n    \n    for i in range(n):\n        v, t = map(int, data[i + 1].split())\n        v -= 1\n        tree.add(0, v + 1, -1 if t == 1 else 1)\n        info = tree.query(0, n)\n        if info.f >= 0:\n            results.append(\"<\")\n        elif info.s <= 0:\n            results.append(\">\")\n        else:\n            results.append(\"?\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2425",
        "hidden_test_path": "/id/hidden/2425",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 5
    },
    {
        "problem_id": "pyramidarray1747",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems I",
        "name": "Pyramid Array",
        "description": "You are given an array consisting of n distinct integers. On each move, you can swap any two adjacent values.\n\nYou want to transform the array into a pyramid array . This means that the final array has to be first increasing and then decreasing. It is also allowed that the final array is only increasing or decreasing.\n\nWhat is the minimum number of moves needed?\n\nInput\n\nThe first input line has an integer n : the size of the array.\n\nThe next line has n distinct integers x_1,x_2,…,x_n : the contents of the array.\n\nOutput\n\nPrint one integer: the minimum number of moves.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4\n2 1 5 3\n\n\nOutput:\n\n\n1\n\n\nExplanation: You may swap the first two values which creates a pyramid array [1,2,5,3] .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class FT:\n    def __init__(self, n):\n        self.s = [0] * n\n        self.n = n\n\n    def update(self, pos, dif):\n        while pos < len(self.s):\n            self.s[pos] += dif\n            pos |= pos + 1\n\n    def query(self, pos):\n        res = 0\n        while pos > 0:\n            res += self.s[pos - 1]\n            pos &= pos - 1\n        return res\n\n    def lower_bound(self, sum):\n        if sum <= 0:\n            return -1\n        pos = 0\n        for pw in (1 << 25, 1 << 24, 1 << 23, 1 << 22, 1 << 21, 1 << 20, 1 << 19, 1 << 18, 1 << 17, 1 << 16, 1 << 15, 1 << 14, 1 << 13, 1 << 12, 1 << 11, 1 << 10, 1 << 9, 1 << 8, 1 << 7, 1 << 6, 1 << 5, 1 << 4, 1 << 3, 1 << 2, 1 << 1, 1):\n            if pos + pw <= len(self.s) and self.s[pos + pw - 1] < sum:\n                pos += pw\n                sum -= self.s[pos - 1]\n        return pos\n\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:n + 1]))\nmx = 0\nss = set(a)\nrl = {}\nfor i in ss:\n    rl[i] = len(rl)\nfor i in range(n):\n    a[i] = rl[a[i]]\n    mx = max(mx, a[i])\n\ninvleft = [0] * n\ninvright = [0] * (n + 1)\nft = FT(n + 5)\n\nfor i in range(n):\n    invleft[i] = ft.query(n) - ft.query(a[i] + 1)\n    ft.update(a[i], 1)\n\nft = FT(n + 5)\nfor i in range(n - 1, -1, -1):\n    invright[i] = ft.query(ft.n) - ft.query(a[i] + 1)\n    ft.update(a[i], 1)\n\nans = 0\nfor i in range(n):\n    ans += min(invleft[i], invright[i])\n\nprint(ans)",
        "public_test_path": "/id/public/1747",
        "hidden_test_path": "/id/hidden/1747",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "bitinversions1188",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems I",
        "name": "Bit Inversions",
        "description": "There is a bit string consisting of n bits. Then, there are some changes that invert one given bit. Your task is to report, after each change, the length of the longest substring whose each bit is the same.\n\nInput\n\nThe first input line has a bit string consisting of n bits. The bits are numbered 1,2,…,n .\n\nThe next line contains an integer m : the number of changes.\n\nThe last line contains m integers x_1,x_2,…,x_m describing the changes.\n\nOutput\n\nAfter each change, print the length of the longest substring whose each bit is the same.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ x_i ≤ n\n\nExample\n\nInput:\n\n\n001011\n3\n3 2 5\n\n\nOutput:\n\n\n4 2 3\n\n\nExplanation: The bit string first becomes 000011 , then 010011 , and finally 010001 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\ns = set()\nm = defaultdict(int)\nn = 0\n\ndef change(k, v):\n    m[k] += v\n    if m[k] == 0:\n        del m[k]\n\ndef fix(k):\n    if k == 0 or k == n:\n        return\n    if k not in s:\n        s.add(k)\n        it = sorted(s)\n        idx = it.index(k)\n        change(it[idx + 1] - it[idx - 1], -1)\n        change(it[idx + 1] - it[idx], 1)\n        change(it[idx] - it[idx - 1], 1)\n    else:\n        it = sorted(s)\n        idx = it.index(k)\n        change(it[idx + 1] - it[idx - 1], 1)\n        change(it[idx + 1] - it[idx], -1)\n        change(it[idx] - it[idx - 1], -1)\n        s.remove(k)\n\ns1 = data[0]\nc = ' '\nn = len(s1)\n\nfor i in range(n):\n    if s1[i] != c:\n        s.add(i)\n    c = s1[i]\ns.add(n)\n\np = -1\nfor v in sorted(s):\n    m[v - p] += 1\n    p = v\n\nq = int(data[1])\noutput = []\nfor i in range(q):\n    k = int(data[i + 2]) - 1\n    fix(k)\n    fix(k + 1)\n    output.append(max(m.keys()))\n\nprint(\" \".join(map(str, output)))",
        "public_test_path": "/id/public/1188",
        "hidden_test_path": "/id/hidden/1188",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "writingnumbers1086",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems I",
        "name": "Writing Numbers",
        "description": "You would like to write a list of positive integers 1,2,3,… using your computer. However, you can press each key 0 – 9 at most n times during the process.\n\nWhat is the last number you can write?\n\nInput\n\nThe only input line contains the value of n .\n\nOutput\n\nPrint the last number you can write.\n\nConstraints\n\n1 ≤ n ≤ 10^{18}\n\nExample\n\nInput:\n\n\n5\n\n\nOutput:\n\n\n12\n\n\nExplanation: You can write the numbers 1,2,…,12 . This requires that you press key 1 five times, so you cannot write the number 13 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip()\n    \n    cnt = [0] * 10\n    for i in range(1, 1000):\n        v = i\n        while v:\n            cnt[v % 10] += 1\n            v //= 10\n        for j in range(1, 9):\n            assert cnt[j] >= cnt[j + 1]\n    \n    score = [0]\n    startdig = 0\n    n = int(data)\n    placevalue = 1\n    while score[-1] <= n:\n        score.append(placevalue + 10 * score[-1])\n        placevalue *= 10\n    startdig -= 1\n    placevalue //= 10\n    \n    ans = 0\n    ones = 0\n    while startdig >= 0:\n        duse = -1\n        drem = -1\n        for d in range(10):\n            rem = d * placevalue * ones + d * score[startdig]\n            if d > 1:\n                rem += placevalue\n            if rem <= n:\n                drem = rem\n                duse = d\n        if duse == 1:\n            ones += 1\n        n -= drem\n        ans = ans * 10 + duse\n        startdig -= 1\n        placevalue //= 10\n    \n    ans -= 1\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1086",
        "hidden_test_path": "/id/hidden/1086",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 21
    },
    {
        "problem_id": "letterpairmovegame2427",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems I",
        "name": "Letter Pair Move Game",
        "description": "There are 2n boxes in a line. Two adjacent boxes are empty, and all other boxes have a letter \"A\" or \"B\". Both letters appear in exactly n-1 boxes.\n\nYour task is to move the letters so that all letters \"A\" appear before any letter \"B\". On each turn you can choose any two adjacent boxes that have a letter and move the letters to the two adjacent empty boxes, preserving their order.\n\nIt can be proven that either there is a solution that consists of at most 10n turns or there are no solutions.\n\nInput\n\nThe first line has an integer n : there are 2n boxes.\n\nThe second line has a string of 2n characters which describes the starting position. Each character is \"A\", \"B\" or \".\" (empty box).\n\nOutput\n\nFirst print an integer k : the number of turns. After this, print k lines that describe the moves. You can print any solution, as long as k ≤ 1000 .\n\nIf there are no solutions, print only \"-1\".\n\nConstraints\n\n1 ≤ n ≤ 100\n\nExample 1\n\nInput:\n\n\n3\nAB..BA\n\n\nOutput:\n\n\n2\nABBA..\nA..ABB\n\nExample 2\n\nInput:\n\n\n3\nABAB..\n\n\nOutput:\n\n\n-1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import deque\n\ndef getrank(s):\n    bcnt = 0\n    ans = 0\n    for c in s:\n        if c == 'A':\n            ans += bcnt\n        elif c == 'B':\n            bcnt += 1\n    return ans\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    start = data[1]\n    \n    if n == 3:\n        bad = [\n            \"..ABAB\",\n            \"..BABA\",\n            \"A..BBA\",\n            \"AB..AB\",\n            \"ABAB..\",\n            \"ABB..A\",\n            \"B..AAB\",\n            \"BA..BA\",\n            \"BAA..B\",\n            \"BABA..\"\n        ]\n        if start in bad:\n            print(\"-1\")\n            return\n    \n    cur = start\n    res = []\n    \n    while getrank(cur) != 0:\n        r = getrank(cur)\n        reach = {}  # cur to prev\n        q = deque([cur])\n        reach[cur] = \"\"\n        best = (float('inf'), \"\")\n        \n        while q:\n            s = q.popleft()\n            places = [i for i in range(len(s) - 1) if s[i] != '.' and s[i + 1] != '.']\n            \n            for i in range(len(s) - 1):\n                if s[i] != '.' or s[i + 1] != '.':\n                    continue\n                for p in places:\n                    t = list(s)\n                    t[i], t[p] = t[p], t[i]\n                    t[i + 1], t[p + 1] = t[p + 1], t[i + 1]\n                    t = ''.join(t)\n                    if t in reach:\n                        continue\n                    reach[t] = s\n                    r1 = getrank(t)\n                    if r1 < r:\n                        best = min(best, (r1, t))\n                        break\n                    q.append(t)\n        \n        use = best[1]\n        if not use:\n            print(\"-1\")\n            return\n        \n        mv = []\n        while use != cur:\n            mv.append(use)\n            use = reach[use]\n        \n        cur = mv[0]\n        res.extend(reversed(mv))\n    \n    print(len(res))\n    for s in res:\n        print(s)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2427",
        "hidden_test_path": "/id/hidden/2427",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 24
    },
    {
        "problem_id": "sortingmethods1162",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems I",
        "name": "Sorting Methods",
        "description": "Here are some possible methods using which we can sort the elements of an array in increasing order:\n\nAt each step, choose two adjacent elements and swap them. At each step, choose any two elements and swap them. At each step, choose any element and move it to another position. At each step, choose any element and move it to the front of the array.\n\nGiven a permutation of numbers 1,2,…,n , calculate the minimum number of steps to sort the array using the above methods.\n\nInput\n\nThe first input line contains an integer n .\n\nThe second line contains n integers describing the permutation.\n\nOutput\n\nPrint four numbers: the minimum number of steps using each method.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5\n\nExample\n\nInput:\n\n\n8\n7 8 2 6 5 1 3 4\n\n\nOutput:\n\n\n20 6 5 6",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Node:\n    def __init__(self, lo, hi, v=None):\n        self.l = None\n        self.r = None\n        self.lo = lo\n        self.hi = hi\n        self.mset = float('inf')\n        self.madd = 0\n        self.val = -float('inf')\n        if v is not None:\n            if lo + 1 < hi:\n                mid = lo + (hi - lo) // 2\n                self.l = Node(lo, mid, v)\n                self.r = Node(mid, hi, v)\n                self.val = max(self.l.val, self.r.val)\n            else:\n                self.val = v[lo]\n\n    def query(self, L, R):\n        if R <= self.lo or self.hi <= L:\n            return -float('inf')\n        if L <= self.lo and self.hi <= R:\n            return self.val\n        self.push()\n        return max(self.l.query(L, R), self.r.query(L, R))\n\n    def set(self, L, R, x):\n        if R <= self.lo or self.hi <= L:\n            return\n        if L <= self.lo and self.hi <= R:\n            self.mset = self.val = x\n            self.madd = 0\n        else:\n            self.push()\n            self.l.set(L, R, x)\n            self.r.set(L, R, x)\n            self.val = max(self.l.val, self.r.val)\n\n    def add(self, L, R, x):\n        if R <= self.lo or self.hi <= L:\n            return\n        if L <= self.lo and self.hi <= R:\n            if self.mset != float('inf'):\n                self.mset += x\n            else:\n                self.madd += x\n            self.val += x\n        else:\n            self.push()\n            self.l.add(L, R, x)\n            self.r.add(L, R, x)\n            self.val = max(self.l.val, self.r.val)\n\n    def push(self):\n        if not self.l:\n            mid = self.lo + (self.hi - self.lo) // 2\n            self.l = Node(self.lo, mid)\n            self.r = Node(mid, self.hi)\n        if self.mset != float('inf'):\n            self.l.set(self.lo, self.hi, self.mset)\n            self.r.set(self.lo, self.hi, self.mset)\n            self.mset = float('inf')\n        elif self.madd:\n            self.l.add(self.lo, self.hi, self.madd)\n            self.r.add(self.lo, self.hi, self.madd)\n            self.madd = 0\n\n\nclass FT:\n    def __init__(self, n):\n        self.s = [0] * n\n\n    def update(self, pos, dif):\n        while pos < len(self.s):\n            self.s[pos] += dif\n            pos |= pos + 1\n\n    def query(self, pos):\n        res = 0\n        while pos > 0:\n            res += self.s[pos - 1]\n            pos &= pos - 1\n        return res\n\n    def lower_bound(self, sum):\n        if sum <= 0:\n            return -1\n        pos = 0\n        for pw in (1 << i for i in range(25, -1, -1)):\n            if pos + pw <= len(self.s) and self.s[pos + pw - 1] < sum:\n                pos += pw\n                sum -= self.s[pos - 1]\n        return pos\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:n + 1]))\n    rev = [0] * n\n    inv = FT(n)\n    idxst = FT(n)\n    inversions = 0\n    tree = Node(0, n + 10)\n    tree.set(0, n + 10, 0)\n\n    for i in range(n):\n        a[i] -= 1\n        rev[a[i]] = i\n        inversions += inv.query(n) - inv.query(a[i])\n        inv.update(a[i], 1)\n        tree.set(a[i], a[i] + 1, 1 + max(0, tree.query(0, a[i])))\n\n    lis = tree.query(0, n + 5)\n    lastans = 0\n    vis = [False] * n\n    cycles = 0\n\n    for i in range(n):\n        if not vis[i]:\n            cycles += 1\n            c = i\n            while not vis[c]:\n                vis[c] = True\n                c = a[c]\n\n    pre = n + 5\n    for i in range(n - 1, -1, -1):\n        if rev[i] < pre:\n            pre = rev[i]\n            lastans += 1\n\n    print(inversions, n - cycles, n - lis, n - lastans)\n\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1162",
        "hidden_test_path": "/id/hidden/1162",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "cyclicarray1191",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems I",
        "name": "Cyclic Array",
        "description": "You are given a cyclic array consisting of n values. Each element has two neighbors; the elements at positions n and 1 are also considered neighbors.\n\nYour task is to divide the array into subarrays so that the sum of each subarray is at most k . What is the minimum number of subarrays?\n\nInput\n\nThe first input line contains integers n and k .\n\nThe next line has n integers x_1,x_2,…,x_n : the contents of the array.\n\nThere is always at least one division (i.e., no value in the array is larger than k ).\n\nOutput\n\nPrint one integer: the minimum number of subarrays.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9 1 ≤ k ≤ 10^{18}\n\nExample\n\nInput:\n\n\n8 5\n2 2 2 1 3 1 2 1\n\n\nOutput:\n\n\n3\n\n\nExplanation : We can create three subarrays: [2,2,1] , [3,1] , and [2,1,2] (remember that the array is cyclic).",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import deque\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:n+2]))\n\nnex = [0] * (2 * n + 1)\nrunning = 0\nr = 0\n\nfor i in range(2 * n):\n    while r < 2 * n and running + a[r % n] <= k:\n        running += a[r % n]\n        r += 1\n    nex[i] = min(2 * n, r)\n    running -= a[i % n]\n\nnex[2 * n] = 2 * n\njmp = [[0] * 20 for _ in range(2 * n + 1)]\n\nfor i in range(2 * n + 1):\n    jmp[i][0] = nex[i]\n\nfor j in range(1, 20):\n    for i in range(2 * n + 1):\n        jmp[i][j] = jmp[jmp[i][j - 1]][j - 1]\n\nans = float('inf')\n\nfor i in range(n):\n    c = i\n    v = 0\n    for j in range(19, -1, -1):\n        if jmp[c][j] < i + n:\n            c = jmp[c][j]\n            v += 1 << j\n    v += 1\n    ans = min(v, ans)\n\nprint(ans)",
        "public_test_path": "/id/public/1191",
        "hidden_test_path": "/id/hidden/1191",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 22
    },
    {
        "problem_id": "listofsums2414",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems I",
        "name": "List of Sums",
        "description": "List A consists of n positive integers, and list B contains the sum of each element pair of list A .\n\nFor example, if A=[1,2,3] , then B=[3,4,5] , and if A=[1,3,3,3] , then B=[4,4,4,6,6,6] .\n\nGiven list B , your task is to reconstruct list A .\n\nInput\n\nThe first input line has an integer n : the size of list A .\n\nThe next line has \\frac{n(n-1)}{2} integers: the contents of list B .\n\nYou can assume that there is a list A that corresponds to the input, and each value in A is between 1 … k .\n\nOutput\n\nPrint n integers: the contents of list A .\n\nYou can print the values in any order. If there are more than one solution, you can print any of them.\n\nConstraints\n\n3 ≤ n ≤ 100 1 ≤ k ≤ 10^9\n\nExample\n\nInput:\n\n\n4\n4 4 4 6 6 6\n\n\nOutput:\n\n\n1 3 3 3\n\n\nExplanation : In this case list A can be either [1,3,3,3] or [2,2,2,4] and both solutions are accepted.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from itertools import combinations\nfrom collections import Counter\n\ndef main():\n    n = int(input())\n    n2 = n * (n - 1) // 2\n    a = list(map(int, input().split()))\n    a.sort()\n    \n    for i in range(2, n2):\n        s1 = a[0] + a[1] - a[i]\n        if s1 <= 0 or s1 % 2 != 0:\n            continue\n        x0 = s1 // 2\n        x1 = a[0] - x0\n        x2 = a[1] - x0\n        v = [x0, x1, x2]\n        ss = Counter(a)\n        \n        for j in range(len(v)):\n            for k in range(j + 1, len(v)):\n                ss[v[j] + v[k]] -= 1\n                if ss[v[j] + v[k]] == 0:\n                    del ss[v[j] + v[k]]\n        \n        works = True\n        while ss and works:\n            x = min(ss) - v[0]\n            for i in v:\n                if (i + x) not in ss:\n                    works = False\n                    break\n                ss[i + x] -= 1\n                if ss[i + x] == 0:\n                    del ss[i + x]\n            v.append(x)\n        \n        if works:\n            print(\" \".join(map(str, v)))\n            break\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2414",
        "hidden_test_path": "/id/hidden/2414",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "fooddivision1189",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems II",
        "name": "Food Division",
        "description": "There are n children around a round table. For each child, you know the amount of food they currently have and the amount of food they want. The total amount of food in the table is correct.\n\nAt each step, a child can give one unit of food to his or her neighbour. What is the minimum number of steps needed?\n\nInput\n\nThe first input line contains an integer n : the number of children.\n\nThe next line has n integers a_1,a_2,…,a_n : the current amount of food for each child.\n\nThe last line has n integers b_1,b_2,…,b_n : the required amount of food for each child.\n\nOutput\n\nPrint one integer: the minimum number of steps.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 0 ≤ a_i, b_i ≤ 10^6\n\nExample\n\nInput:\n\n\n3\n3 5 0\n2 4 2\n\n\nOutput:\n\n\n2\n\n\nExplanation : Child 1 gives one unit of food to child 3, and child 2 gives one unit of food to child 3.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:n+1]))\n    b = list(map(int, data[n+1:2*n+1]))\n    \n    from_value = a[0] - b[0]\n    pos, neg = [], []\n    ans = 0\n    \n    for i in range(1, n):\n        if from_value > 0:\n            pos.append(from_value)\n        if from_value < 0:\n            neg.append(abs(from_value))\n        ans += abs(from_value)\n        from_value += a[i] - b[i]\n    \n    pos.sort(reverse=True)\n    neg.sort(reverse=True)\n    \n    for v in [pos, neg]:\n        pre = 0\n        while len(v) > 0 and len(v) > n - len(v):\n            dif = v[-1] - pre\n            ans -= dif * (len(v) - (n - len(v)))\n            pre = v[-1]\n            v.pop()\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1189",
        "hidden_test_path": "/id/hidden/1189",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 5
    },
    {
        "problem_id": "swaproundsorting1698",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems II",
        "name": "Swap Round Sorting",
        "description": "You are given an array containing a permutation of numbers 1,2,…,n , and your task is to sort the array using swap rounds . On each swap round, you can choose any number of distinct pairs of elements and swap each pair.\n\nYour task is to find the minimum number of rounds and show how you can choose the pairs in each round.\n\nInput\n\nThe first input line has an integer n : the size of the array.\n\nThe second line has n integers x_1,x_2,…,x_n : the initial permutation.\n\nOutput\n\nFirst print an integer k : the minimum number of rounds.\n\nThen, for each round, print the number of swaps and the indices of each swap. You can print any valid solution.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5\n\nExample\n\nInput:\n\n\n5\n5 2 1 3 4\n\n\nOutput:\n\n\n2\n2\n1 3\n4 5\n1\n3 5\n\n\nExplanation : The initial array is [5,2,1,3,4] . After round 1 , the array becomes [1,2,5,4,3] . After round 2 , the array becomes [1,2,3,4,5] .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    p = list(map(int, data[1:n+1]))\n    rp = [0] * n\n    for i in range(n):\n        p[i] -= 1\n        rp[p[i]] = i\n    \n    ans = [[]]\n    used = [False] * n\n    \n    def sw(v1, v2):\n        i1, i2 = rp[v1], rp[v2]\n        used[i1] = used[i2] = True\n        p[i1], p[i2] = p[i2], p[i1]\n        rp[v1], rp[v2] = rp[v2], rp[v1]\n        ans[-1].append((i1, i2))\n    \n    for i in range(n):\n        if used[i] or used[p[i]] or p[i] == i:\n            continue\n        if p[p[i]] == i:\n            sw(p[i], p[p[i]])\n        else:\n            cur, nex = p[i], p[p[i]]\n            sw(cur, nex)\n            while p[nex] != rp[nex]:\n                cur, nex = rp[nex], p[nex]\n                sw(cur, nex)\n            cur = p[i]\n    \n    if len(ans[0]) == 0:\n        ans.pop()\n    \n    solved = all(p[i] == i for i in range(n))\n    if not solved:\n        ans.append([])\n        for i in range(n):\n            if p[i] != i:\n                sw(i, p[i])\n    \n    print(len(ans))\n    for v in ans:\n        print(len(v))\n        for a, b in v:\n            print(a + 1, b + 1)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1698",
        "hidden_test_path": "/id/hidden/1698",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "binarysubsequences2430",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems II",
        "name": "Binary Subsequences",
        "description": "Your task is to find a minimum length bit string that has exactly n distinct subsequences.\n\nFor example, a correct solution for n=6 is 101 whose distinct subsequences are 0 , 1 , 01 , 10 , 11 and 101 .\n\nInput\n\nThe only input line has an integer n .\n\nOutput\n\nPrint one bit string: a solution to the task. You can print any valid solution.\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\n6\n\n\nOutput:\n\n\n101",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import defaultdict\nfrom bisect import bisect_left\n\ninput = sys.stdin.read\ndef main():\n    n = int(input().strip())\n    ls = defaultdict(list)  # all b for given a\n\n    for i in range(n, n - n // 2 - 1, -1):\n        ls[i].append(n - i)\n\n    for a in range(n, 0, -1):\n        ls[a] = sorted(set(ls[a]))\n        while ls[a] and ls[a][-1] == a:\n            ls[a].pop()\n        for b in ls[a]:\n            if b == 0:\n                continue\n            c = a % (b + 1)\n            ls[max(c, b)].append(min(c, b))\n\n    ans = defaultdict(list)\n    for a in range(1, n + 1):\n        ans[a] = [0] * len(ls[a])\n        for j in range(len(ls[a])):\n            b = ls[a][j]\n            res = ans[a][j]\n            if b == 0:\n                res = a\n            elif a == 2 and b == 1:\n                res = 2\n            else:\n                c = a % (b + 1)\n                idx = bisect_left(ls[max(c, b)], min(c, b))\n                if idx == len(ls[max(c, b)]):\n                    res = float('inf')\n                else:\n                    res = (a - c) // (b + 1) + ans[max(c, b)][idx]\n                ans[a][j] = res\n\n    best = (n, 0)\n    bestans = n\n    for i in range(n, n - n // 2 - 1, -1):\n        idx = bisect_left(ls[max(i, n - i)], min(i, n - i))\n        if idx == len(ls[max(i, n - i)]):\n            continue\n        if ans[i][idx] < bestans:\n            best = (i, n - i)\n            bestans = ans[i][idx]\n\n    cur = 0\n    result = []\n    while best[0] != 0:\n        c = best[0] % (best[1] + 1)\n        d = (best[0] - c) // (best[1] + 1)\n        result.append(str(cur) * d)\n        cur = 1 - cur\n        best = (c, best[1])\n        if best[0] < best[1]:\n            best = (best[1], best[0])\n\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2430",
        "hidden_test_path": "/id/hidden/2430",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "coingrid1709",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems II",
        "name": "Coin Grid",
        "description": "There is an n × n grid whose each square is empty or has a coin. On each move, you can remove all coins in a row or column.\n\nWhat is the minimum number of moves after which the grid is empty?\n\nInput\n\nThe first input line has an integer n : the size of the grid. The rows and columns are numbered 1,2,…,n .\n\nAfter this, there are n lines describing the grid. Each line has n characters: each character is either . (empty) or o (coin).\n\nOutput\n\nFirst print an integer k : the minimum number of moves. After this, print k lines describing the moves.\n\nOn each line, first print 1 (row) or 2 (column), and then the number of a row or column. You can print any valid solution.\n\nConstraints\n\n1 ≤ n ≤ 100\n\nExample\n\nInput:\n\n\n3\n..o\no.o\n...\n\n\nOutput:\n\n\n2\n1 2\n2 3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import deque\n\nclass Dinic:\n    class Edge:\n        def __init__(self, to, rev, c, oc):\n            self.to = to\n            self.rev = rev\n            self.c = c\n            self.oc = oc\n        \n        def flow(self):\n            return max(self.oc - self.c, 0)\n\n    def __init__(self, n):\n        self.lvl = [0] * n\n        self.ptr = [0] * n\n        self.q = [0] * n\n        self.adj = [[] for _ in range(n)]\n\n    def add_edge(self, a, b, c, rcap=0):\n        self.adj[a].append(self.Edge(b, len(self.adj[b]), c, c))\n        self.adj[b].append(self.Edge(a, len(self.adj[a]) - 1, rcap, rcap))\n\n    def dfs(self, v, t, f):\n        if v == t or f == 0:\n            return f\n        for i in range(self.ptr[v], len(self.adj[v])):\n            e = self.adj[v][i]\n            if self.lvl[e.to] == self.lvl[v] + 1:\n                p = self.dfs(e.to, t, min(f, e.c))\n                if p:\n                    e.c -= p\n                    self.adj[e.to][e.rev].c += p\n                    return p\n        return 0\n\n    def calc(self, s, t):\n        flow = 0\n        self.q[0] = s\n        for L in range(31):\n            self.lvl = [0] * len(self.lvl)\n            self.ptr = [0] * len(self.ptr)\n            qi = 0\n            qe = self.lvl[s] = 1\n            while qi < qe and not self.lvl[t]:\n                v = self.q[qi]\n                qi += 1\n                for e in self.adj[v]:\n                    if not self.lvl[e.to] and e.c >> (30 - L):\n                        self.q[qe] = e.to\n                        qe += 1\n                        self.lvl[e.to] = self.lvl[v] + 1\n            while (p := self.dfs(s, t, float('inf'))):\n                flow += p\n        return flow\n\n    def left_of_min_cut(self, a):\n        return self.lvl[a] != 0\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    grid = [[0] * n for _ in range(n)]\n    d = Dinic(2 * n + 2)\n    edges = []\n    \n    for i in range(n):\n        str_row = data[i + 1]\n        for j in range(n):\n            if str_row[j] == 'o':\n                d.add_edge(i, j + n, 1)\n                edges.append((i, j + n))\n        d.add_edge(2 * n, i, 1)\n        d.add_edge(i + n, 2 * n + 1, 1)\n    \n    mf = d.calc(2 * n, 2 * n + 1)\n    moves = [False] * (2 * n)\n    \n    for l, r in edges:\n        if d.left_of_min_cut(l):\n            moves[r] = True\n        else:\n            moves[l] = True\n    \n    cnt = sum(moves)\n    print(cnt)\n    \n    for i in range(2 * n):\n        if moves[i]:\n            print(2 if i >= n else 1, (i % n) + 1)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1709",
        "hidden_test_path": "/id/hidden/1709",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "programmersandartists2426",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems II",
        "name": "Programmers and Artists",
        "description": "A company wants to hire a programmers and b artists.\n\nThere are a total of n applicants, and each applicant can become either a programmer or an artist. You know each applicant's programming and artistic skills.\n\nYour task is to select the new employees so that the sum of their skills is maximum.\n\nInput\n\nThe first input line has three integers a , b and n : the required number of programmers and artists, and the total number of applicants.\n\nAfter this, there are n lines that describe the applicants. Each line has two integers x and y : the applicant's programming and artistic skills.\n\nOutput\n\nPrint one integer: the maximum sum of skills.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 0 ≤ a,b ≤ n a+b ≤ n 1 ≤ x,y ≤ 10^9\n\nExample\n\nInput:\n\n\n2 1 4\n3 7\n9 8\n1 5\n4 2\n\n\nOutput:\n\n\n20\n\n\nExplanation: An optimal solution is to hire two programmers with skills 9 and 4 and one artist with skill 7 . The sum of the skills is 9+4+7=20 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from sortedcontainers import SortedList\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\nindex = 0\n\ndef read_int():\n    global index\n    value = int(data[index])\n    index += 1\n    return value\n\nclass cmp1:\n    def __lt__(self, other):\n        if self[0] == other[0]:\n            return self[1] < other[1]\n        return self[0] < other[0]\n\nclass cmp2:\n    def __lt__(self, other):\n        if self[1] == other[1]:\n            return self[0] < other[0]\n        return self[1] < other[1]\n\nclass cmp3:\n    def __lt__(self, other):\n        if self[0] - self[1] == other[0] - other[1]:\n            return self[0] < other[0]\n        return self[0] - self[1] < other[0] - other[1]\n\ndef main():\n    a = read_int()\n    b = read_int()\n    n = read_int()\n    \n    a1 = SortedList(key=cmp1)\n    c1 = SortedList(key=cmp1)\n    b2 = SortedList(key=cmp2)\n    c2 = SortedList(key=cmp2)\n    a3 = SortedList(key=cmp3)\n    b3 = SortedList(key=cmp3)\n\n    for i in range(n):\n        d1 = read_int()\n        d2 = read_int()\n        d = (d1, d2)\n        if i < a:\n            a1.add(d)\n            a3.add(d)\n        elif i < a + b:\n            b2.add(d)\n            b3.add(d)\n        else:\n            c1.add(d)\n            c2.add(d)\n\n    c = n - a - b\n\n    while True:\n        sa3 = a3[0] if a else None\n        sa1 = a1[0] if a else None\n        sb2 = b2[0] if b else None\n        lb3 = b3[-1] if b else None\n        lc1 = c1[-1] if c else None\n        lc2 = c2[-1] if c else None\n\n        if a and b and sa3 < lb3:\n            ap = sa3\n            bp = lb3\n            a3.remove(ap)\n            a1.remove(ap)\n            b3.remove(bp)\n            b2.remove(bp)\n            b3.add(ap)\n            b2.add(ap)\n            a3.add(bp)\n            a1.add(bp)\n            continue\n\n        if a and c and sa1 < lc1:\n            ap = sa1\n            cp = lc1\n            a1.remove(ap)\n            a3.remove(ap)\n            c1.remove(lc1)\n            c2.remove(cp)\n            c1.add(ap)\n            c2.add(ap)\n            a1.add(cp)\n            a3.add(cp)\n            continue\n\n        if b and c and sb2 < lc2:\n            bp = sb2\n            cp = lc2\n            b2.remove(bp)\n            b3.remove(bp)\n            c2.remove(cp)\n            c1.remove(cp)\n            c1.add(bp)\n            c2.add(bp)\n            b2.add(cp)\n            b3.add(cp)\n            continue\n\n        if a and b and c:\n            ap = sa3\n            bp = sb2\n            cp = lc1\n            if ap[1] - ap[0] - (bp[1] - cp[0]) > 0:\n                a3.remove(ap)\n                a1.remove(ap)\n                b2.remove(bp)\n                b3.remove(bp)\n                c1.remove(cp)\n                c2.remove(cp)\n                a1.add(cp)\n                a3.add(cp)\n                b2.add(ap)\n                b3.add(ap)\n                c1.add(bp)\n                c2.add(bp)\n                continue\n\n        if a and b and c:\n            ap = sa1\n            bp = lb3\n            cp = lc2\n            if -ap[0] + cp[1] + bp[0] - bp[1] > 0:\n                a1.remove(ap)\n                a3.remove(ap)\n                b3.remove(bp)\n                b2.remove(bp)\n                c2.remove(cp)\n                c1.remove(cp)\n                a1.add(cp)\n                a3.add(cp)\n                b2.add(ap)\n                b3.add(ap)\n                c1.add(bp)\n                c2.add(bp)\n                continue\n\n        break\n\n    score = sum(x[0] for x in a1) + sum(x[1] for x in b2)\n    print(score)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2426",
        "hidden_test_path": "/id/hidden/2426",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "coinarrangement2180",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems II",
        "name": "Coin Arrangement",
        "description": "There is a 2 × n grid whose each cell contains some number of coins. The total number of coins is 2n .\n\nYour task is to arrange the coins so that each cell contains exactly one coin. On each move you can choose any coin and move it one step left, right, up or down.\n\nWhat is the minimum number of moves if you act optimally?\n\nInput\n\nThe first input line has an integer n : the width of the grid.\n\nAfter this, there are two lines that describe the grid. Each line has n integers: the number of coins in each cell.\n\nOutput\n\nPrint one integer: the minimum number of moves.\n\nConstraints\n\n1 ≤ n ≤ 10^5\n\nExample\n\nInput:\n\n\n4\n0 1 0 1\n2 0 1 3\n\n\nOutput:\n\n\n5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Node:\n    def __init__(self, lo, hi):\n        self.l = None\n        self.r = None\n        self.lo = lo\n        self.hi = hi\n        self.madd = 0\n        self.val = 0\n        self.reset = False\n        if lo + 1 < hi:\n            mid = lo + (hi - lo) // 2\n            self.l = Node(lo, mid)\n            self.r = Node(mid, hi)\n            self.val = self.l.val + self.r.val\n\n    def query(self, L, R):\n        if R <= self.lo or self.hi <= L:\n            return 0\n        if L <= self.lo and self.hi <= R:\n            return self.val\n        self.push()\n        return self.l.query(L, R) + self.r.query(L, R)\n\n    def add(self, L, R, x):\n        if R <= self.lo or self.hi <= L:\n            return\n        if L <= self.lo and self.hi <= R:\n            self.madd += x\n            self.val += x\n        else:\n            self.push()\n            self.l.add(L, R, x)\n            self.r.add(L, R, x)\n            self.val = self.l.val + self.r.val\n\n    def clear(self, L, R):\n        if R <= self.lo or self.hi <= L:\n            return\n        if L <= self.lo and self.hi <= R:\n            self.reset = True\n            self.madd = 0\n        else:\n            self.push()\n            self.l.clear(L, R)\n            self.r.clear(L, R)\n            self.val = self.l.val + self.r.val\n\n    def push(self):\n        if not self.l:\n            mid = self.lo + (self.hi - self.lo) // 2\n            self.l = Node(self.lo, mid)\n            self.r = Node(mid, self.hi)\n        if self.reset:\n            self.l.clear(self.lo, self.hi)\n            self.r.clear(self.lo, self.hi)\n            self.reset = False\n        if self.madd:\n            self.l.add(self.lo, self.hi, self.madd)\n            self.r.add(self.lo, self.hi, self.madd)\n            self.madd = 0\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    grid = [[0] * n for _ in range(2)]\n    index = 1\n    for i in range(2):\n        for j in range(n):\n            grid[i][j] = int(data[index]) - 1\n            index += 1\n\n    net = [0, 0]\n    ans = 0\n    for i in range(n):\n        for j in range(2):\n            net[j] += grid[j][i]\n        if (net[0] > 0 and net[1] <= 0) or (net[0] <= 0 and net[1] > 0):\n            mn = min(abs(net[0]), abs(net[1]))\n            if net[0] > 0 and net[1] <= 0:\n                net[0] -= mn\n                net[1] += mn\n            else:\n                net[0] += mn\n                net[1] -= mn\n            ans += mn\n        ans += abs(net[0]) + abs(net[1])\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2180",
        "hidden_test_path": "/id/hidden/2180",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "bitsubstrings2115",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems II",
        "name": "Bit Substrings",
        "description": "You are given a bit string of length n . Your task is to calculate for each k between 0  … n the number of non-empty substrings that contain exactly k ones.\n\nFor example, if the string is 101, there are:\n\n1 substring that contains 0 ones: 0 4 substrings that contain 1 one: 01, 1, 1, 10 1 substring that contains 2 ones: 101 0 substrings that contain 3 ones\n\nInput\n\nThe only input line contains a binary string of length n .\n\nOutput\n\nPrint n+1 values as specified above.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5\n\nExample\n\nInput:\n\n\n101\n\n\nOutput:\n\n\n1 4 1 0",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport cmath\nfrom collections import deque\n\ndef fft(a):\n    n = len(a)\n    L = 31 - (n - 1).bit_length()\n    R = [1] * (2 * n)\n    rt = [1] * (2 * n)\n    \n    for k in range(2, n * 2, k * 2):\n        x = cmath.exp(complex(0, cmath.pi) / k)\n        for i in range(k, 2 * k):\n            rt[i] = R[i] = R[i // 2] * x if i & 1 else R[i // 2]\n    \n    rev = [0] * n\n    for i in range(n):\n        rev[i] = (rev[i // 2] | (i & 1) << L) // 2\n    \n    for i in range(n):\n        if i < rev[i]:\n            a[i], a[rev[i]] = a[rev[i]], a[i]\n    \n    for k in range(1, n, k * 2):\n        for i in range(0, n, 2 * k):\n            for j in range(k):\n                z = rt[j + k] * a[i + j + k]\n                a[i + j + k] = a[i + j] - z\n                a[i + j] += z\n\ndef conv(a, b):\n    if not a or not b:\n        return []\n    res = [0] * (len(a) + len(b) - 1)\n    L = 32 - (len(res) - 1).bit_length()\n    n = 1 << L\n    in_data = [0] * n\n    out_data = [0] * n\n    \n    for i in range(len(a)):\n        in_data[i] = complex(a[i], 0)\n    for i in range(len(b)):\n        in_data[i].imag = b[i]\n    \n    fft(in_data)\n    \n    for i in range(n):\n        in_data[i] *= in_data[i]\n    \n    for i in range(n):\n        out_data[i] = in_data[-i & (n - 1)] - in_data[i].conjugate()\n    \n    fft(out_data)\n    \n    for i in range(len(res)):\n        res[i] = out_data[i].imag / (4 * n)\n    \n    return res\n\ndef main():\n    input = sys.stdin.read\n    str_input = input().strip()\n    n = len(str_input)\n    cnt = sum(1 for char in str_input if char == '1')\n    \n    left = [0] * cnt\n    right = [0] * cnt\n    pre = 0\n    idx = 0\n    \n    for i in range(n):\n        if str_input[i] == '1':\n            left[idx] = i - pre + 1\n            pre = i + 1\n            idx += 1\n    \n    idx = cnt - 1\n    pre = n - 1\n    \n    for i in range(n - 1, -1, -1):\n        if str_input[i] == '1':\n            right[idx] = pre - i + 1\n            pre = i - 1\n            idx -= 1\n    \n    right.reverse()\n    res = conv(left, right)\n    res = res[:cnt][::-1]\n    \n    ans = [0] * (n + 1)\n    \n    for i in range(len(res)):\n        ans[i + 1] = int(res[i] + 0.1)\n    \n    ones = [-1]\n    for i in range(n):\n        if str_input[i] == '1':\n            ones.append(i)\n    ones.append(n)\n    \n    for i in range(len(ones) - 1):\n        v = ones[i + 1] - ones[i]\n        ans[0] += v * (v - 1) // 2\n    \n    print(\" \".join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2115",
        "hidden_test_path": "/id/hidden/2115",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "reversalsorting2075",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems II",
        "name": "Reversal Sorting",
        "description": "You have an array that contains a permutation of integers 1,2,…,n . Your task is to sort the array in increasing order by reversing subarrays. You can construct any solution that has at most n reversals.\n\nInput\n\nThe first input line has an integer n : the size of the array. The array elements are numbered 1,2,…,n .\n\nThe next line has n integers x_1,x_2,…,x_n : the contents of the array.\n\nOutput\n\nFirst print an integer k : the number of reversals.\n\nAfter that, print k lines that describe the reversals. Each line has two integers a and b : you reverse a subarray from position a to position b .\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5\n\nExample\n\nInput:\n\n\n4\n2 3 1 4\n\n\nOutput:\n\n\n2\n1 3\n2 3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import random\nfrom typing import List, Tuple, Optional\n\nclass Node:\n    def __init__(self, val: int):\n        self.l: Optional[Node] = None\n        self.r: Optional[Node] = None\n        self.val = val\n        self.y = random.randint(0, 2**30)\n        self.c = 1\n        self.mn = (val, 0)\n        self.sw = False\n\n    def recalc(self):\n        self.c = cnt(self.l) + cnt(self.r) + 1\n        self.mn = (self.val, cnt(self.l))\n        if self.l:\n            self.mn = min(self.mn, self.l.mn)\n        if self.r:\n            self.mn = min(self.mn, (self.r.mn[0], self.r.mn[1] + 1 + cnt(self.l)))\n\n    def tag(self):\n        self.sw = not self.sw\n        self.mn = (self.mn[0], cnt(self) - 1 - self.mn[1])\n        self.l, self.r = self.r, self.l\n\n    def push(self):\n        if self.sw:\n            self.sw = False\n            if self.l:\n                self.l.tag()\n            if self.r:\n                self.r.tag()\n\ndef cnt(n: Optional[Node]) -> int:\n    return n.c if n else 0\n\ndef each(n: Optional[Node], f):\n    if n:\n        n.push()\n        each(n.l, f)\n        f(n)\n        each(n.r, f)\n\ndef split(n: Optional[Node], k: int) -> Tuple[Optional[Node], Optional[Node]]:\n    if not n:\n        return None, None\n    n.push()\n    if cnt(n.l) >= k:\n        pa = split(n.l, k)\n        n.l = pa[1]\n        n.recalc()\n        return pa[0], n\n    else:\n        pa = split(n.r, k - cnt(n.l) - 1)\n        n.r = pa[0]\n        n.recalc()\n        return n, pa[1]\n\ndef merge(l: Optional[Node], r: Optional[Node]) -> Optional[Node]:\n    if not l:\n        return r\n    if not r:\n        return l\n    l.push()\n    r.push()\n    if l.y > r.y:\n        l.r = merge(l.r, r)\n        l.recalc()\n        return l\n    else:\n        r.l = merge(l, r.l)\n        r.recalc()\n        return r\n\ndef ins(t: Optional[Node], n: Node, pos: int) -> Optional[Node]:\n    pa = split(t, pos)\n    return merge(merge(pa[0], n), pa[1])\n\ndef rev(t: Optional[Node], l: int, r: int):\n    a, b, c = split(t, l), split(split(t, l)[1], r - l)\n    b[0].tag()\n    t = merge(a[0], merge(b[0], c[1]))\n\ndef main():\n    n = int(input())\n    root = None\n    for i in range(n):\n        v = int(input())\n        root = ins(root, Node(v), i)\n    \n    ans = []\n    for i in range(n):\n        mindex = root.mn[1]\n        ans.append((i + 1, i + 1 + mindex))\n        rev(root, 0, mindex + 1)\n        p, root = split(root, 1)\n\n    print(len(ans))\n    for a, b in ans:\n        print(a, b)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2075",
        "hidden_test_path": "/id/hidden/2075",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "codingcompany1665",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems II",
        "name": "Coding Company",
        "description": "Your company has n coders, and each of them has a skill level between 0 and 100 . Your task is to divide the coders into teams that work together.\n\nBased on your experience, you know that teams work well when the skill levels of the coders are about the same. For this reason, the penalty for creating a team is the skill level difference between the best and the worst coder.\n\nIn how many ways can you divide the coders into teams such that the sum of the penalties is at most x ?\n\nInput\n\nThe first input line has two integers n and x : the number of coders and the maximum allowed penalty sum.\n\nThe next line has n integers t_1,t_2,…,t_n : the skill level of each coder.\n\nOutput\n\nPrint one integer: the number of valid divisions modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 100 0 ≤ x ≤ 5000 0 ≤ t_i ≤ 100\n\nExample\n\nInput:\n\n\n3 2\n2 5 3\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = int(1e9 + 7)\ndp = [[[0] * 5001 for _ in range(102)] for _ in range(102)]\ndp[0][0][0] = 1\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\na.append(-1)\na.sort()\n\nfor i in range(n):\n    c = a[i + 1] - a[i]\n    for j in range(n + 1):\n        for k in range(x + 1):\n            k1 = k + j * c\n            if k1 > x or k1 < 0 or dp[i][j][k] == 0:\n                continue\n            if j:\n                dp[i + 1][j - 1][k1] = (dp[i + 1][j - 1][k1] + (j * dp[i][j][k]) % MOD) % MOD\n            dp[i + 1][j + 1][k1] = (dp[i + 1][j + 1][k1] + dp[i][j][k]) % MOD\n            dp[i + 1][j][k1] = (dp[i + 1][j][k1] + dp[i][j][k]) % MOD\n            dp[i + 1][j][k1] = (dp[i + 1][j][k1] + (j * dp[i][j][k]) % MOD) % MOD\n\nans = 0\nfor k in range(x + 1):\n    ans = (ans + dp[n][0][k]) % MOD\n\nprint(ans)",
        "public_test_path": "/id/public/1665",
        "hidden_test_path": "/id/hidden/1665",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "twostackssorting2402",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems II",
        "name": "Two Stacks Sorting",
        "description": "You are given an input list that consists of n numbers. Each integer between 1 and n appears exactly once in the list.\n\nYour task is to create a sorted output list using two stacks. On each move you can do one of the following:\n\nMove the first number from the input list to a stack Move a number from a stack to the end of the output list\n\nInput\n\nThe first input line has an integer n .\n\nThe second line has n integers: the contents of the input list.\n\nOutput\n\nPrint n integers: for each number the stack where it is moved ( 1 or 2 ).\n\nYou can print any valid solution. If there are no solutions, print IMPOSSIBLE .\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5\n\nExample\n\nInput:\n\n\n5\n2 3 1 5 4\n\n\nOutput:\n\n\n1 2 1 1 2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport heapq\n\nclass UF:\n    def __init__(self, n, r):\n        self.e = [-1] * n\n        self.ss = [set() for _ in range(n)]\n        for i in range(n):\n            self.ss[i].add((r[i], i))\n\n    def find(self, x):\n        if self.e[x] < 0:\n            return x\n        self.e[x] = self.find(self.e[x])\n        return self.e[x]\n\n    def same_set(self, a, b):\n        return self.find(a) == self.find(b)\n\n    def size(self, x):\n        return -self.e[self.find(x)]\n\n    def join(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return False\n        if self.e[a] > self.e[b]:\n            a, b = b, a\n        self.e[a] += self.e[b]\n        self.e[b] = a\n        for R, i in self.ss[b]:\n            self.ss[a].add((R, i))\n        self.ss[b].clear()\n        return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    p = list(map(lambda x: int(x) - 1, data[1:n + 1]))\n    \n    l = [-1] * n\n    r = [-1] * n\n    T = 0\n    solve = 0\n    seen = [False] * n\n    \n    for i in range(n):\n        seen[p[i]] = True\n        l[p[i]] = T\n        T += 1\n        while solve < n and seen[solve]:\n            r[solve] = T\n            solve += 1\n\n    adj = defaultdict(list)\n    uf = UF(n, r)\n    rs = [(l[i], r[i], i) for i in range(n)]\n    rs.sort()\n    pq = []\n    \n    for L, R, i in rs:\n        while pq and pq[0][0] < L:\n            r1, idx1 = heapq.heappop(pq)\n            u = uf.find(idx1)\n            it = next(((R, i) for R, i in uf.ss[u] if R > r1), None)\n            if it:\n                heapq.heappush(pq, it)\n        \n        other = []\n        while pq and pq[0][0] < R:\n            r1, idx = heapq.heappop(pq)\n            other.append((r1, idx))\n        \n        for j in range(1, len(other)):\n            uf.join(other[j - 1][1], other[j][1])\n        \n        if other:\n            adj[i].append(other[0][1])\n            adj[other[0][1]].append(i)\n            u = uf.find(other[0][1])\n            it = next(((L, -1) for R, i in uf.ss[u] if R > L), None)\n            if it:\n                heapq.heappush(pq, it)\n        \n        heapq.heappush(pq, (R, i))\n\n    comps = defaultdict(list)\n    for i in range(n):\n        comps[uf.find(i)].append(i)\n    \n    state = [0] * n\n    val = [0] * n\n\n    def dfs(c, t):\n        if state[c]:\n            return val[c] != t\n        state[c] = 1\n        val[c] = t\n        for u in comps[c]:\n            for v in adj[u]:\n                if dfs(uf.find(v), not t):\n                    return True\n        return False\n\n    imp = False\n    for i in range(n):\n        if comps[i] and state[i] == 0 and dfs(i, 0):\n            imp = True\n\n    if imp:\n        print(\"IMPOSSIBLE\")\n        return\n\n    st = [[], []]\n    solve = 0\n    for i in range(n):\n        v = p[i]\n        c = val[uf.find(v)]\n        if st[c] and st[c][-1] < v:\n            imp = True\n            break\n        st[c].append(v)\n        while solve < n and ((st[0] and st[0][-1] == solve) or (st[1] and st[1][-1] == solve)):\n            if st[0] and st[0][-1] == solve:\n                st[0].pop()\n            else:\n                st[1].pop()\n            solve += 1\n\n    if solve != n:\n        imp = True\n\n    if imp:\n        print(\"IMPOSSIBLE\")\n    else:\n        print(\" \".join(str(val[uf.find(p[i])] + 1) for i in range(n)))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2402",
        "hidden_test_path": "/id/hidden/2402",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "weirdalgorithm1068",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Weird Algorithm",
        "description": "Consider an algorithm that takes as input a positive integer n . If n is even, the algorithm divides it by two, and if n is odd, the algorithm multiplies it by three and adds one. The algorithm repeats this, until n is one. For example, the sequence for n=3 is as follows: 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1 Your task is to simulate the execution of the algorithm for a given value of n .\n\nInput\n\nThe only input line contains an integer n .\n\nOutput\n\nPrint a line that contains all values of n during the algorithm.\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\n3\n\n\nOutput:\n\n\n3 10 5 16 8 4 2 1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "N = int(input())\nwhile N > 1:\n    print(N, end=' ')\n    if N % 2 == 1:\n        N = 3 * N + 1\n    else:\n        N //= 2\nprint(1)",
        "public_test_path": "/id/public/1068",
        "hidden_test_path": "/id/hidden/1068",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "palindromereorder1755",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Palindrome Reorder",
        "description": "You are given all numbers between 1,2,…,n except one. Your task is to find the missing number.\n\nInput\n\nThe first input line contains an integer n .\n\nThe second line contains n-1 numbers. Each number is distinct and between 1 and n (inclusive).\n\nOutput\n\nPrint the missing number.\n\nConstraints\n\n2 ≤ n ≤ 2 · 10^5\n\nExample\n\nInput:\n\n\n5\n2 3 1 5\n\n\nOutput:\n\n\n4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "S = input().strip()\nN = len(S)\nfreq = [0] * 26\n\nfor char in S:\n    freq[ord(char) - ord('A')] += 1\n\nodd = -1\nfor i in range(26):\n    if freq[i] % 2 == 1:\n        if odd != -1:\n            print(\"NO SOLUTION\")\n            exit()\n        else:\n            odd = i\n\nresult = []\nfor i in range(26):\n    result.append(chr(i + ord('A')) * (freq[i] // 2))\n\nif odd != -1:\n    result.append(chr(odd + ord('A')))\n\nfor i in range(25, -1, -1):\n    result.append(chr(i + ord('A')) * (freq[i] // 2))\n\nprint(''.join(result))",
        "public_test_path": "/id/public/1755",
        "hidden_test_path": "/id/hidden/1755",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 17
    },
    {
        "problem_id": "towerofhanoi2165",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Tower of Hanoi",
        "description": "You are given a DNA sequence: a string consisting of characters A, C, G, and T. Your task is to find the longest repetition in the sequence. This is a maximum-length substring containing only one type of character.\n\nInput\n\nThe only input line contains a string of n characters.\n\nOutput\n\nPrint one integer: the length of the longest repetition.\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\nATTCGGGA\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def move(from_peg, to_peg, depth):\n    if depth == 1:\n        print(from_peg, to_peg)\n        return\n\n    other_peg = 6 - from_peg - to_peg\n    move(from_peg, other_peg, depth - 1)\n    print(from_peg, to_peg)\n    move(other_peg, to_peg, depth - 1)\n\nN = int(input())\nprint((1 << N) - 1)\nmove(1, 3, N)",
        "public_test_path": "/id/public/2165",
        "hidden_test_path": "/id/hidden/2165",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "raabgamei3399",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Raab Game I",
        "description": "You are given an array of n integers. You want to modify the array so that it is increasing, i.e., every element is at least as large as the previous element.\n\nOn each move, you may increase the value of any element by one. What is the minimum number of moves required?\n\nInput\n\nThe first input line contains an integer n : the size of the array.\n\nThen, the second line contains n integers x_1,x_2,…,x_n : the contents of the array.\n\nOutput\n\nPrint the minimum number of moves.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5\n3 2 5 1 7\n\n\nOutput:\n\n\n5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "T = int(input())\n\nfor _ in range(T):\n    n, a, b = map(int, input().split())\n\n    # Degenerate case: all ties\n    if a == 0 and b == 0:\n        print(\"YES\")\n        for i in range(1, n + 1):\n            print(i, end=\" \" if i < n else \"\\n\")\n        continue\n\n    # Otherwise, each player must win at least once\n    # and the total wins cannot exceed n\n    if a + b > n or a == 0 or b == 0:\n        print(\"NO\")\n        continue\n\n    # General case: trade wins then handle ties\n    print(\"YES\")\n    ties = n - a - b\n    xs = [0] * (n + 1)\n\n    # Start with both players playing 1, 2, 3, ...\n    # Cyclic shift a player by k to the right\n    # in order to give them k wins\n    for i in range(1, a + b + 1):\n        pos = (i + b - 1) % (a + b) + 1\n        xs[pos] = i\n    for i in range(a + b + 1, n + 1):\n        xs[i] = i\n\n    # Print out solution\n    for i in range(1, n + 1):\n        print(i, end=\" \" if i < n else \"\\n\")\n    for i in range(1, n + 1):\n        print(xs[i], end=\" \" if i < n else \"\\n\")",
        "public_test_path": "/id/public/3399",
        "hidden_test_path": "/id/hidden/3399",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 2
    },
    {
        "problem_id": "mexgridconstruction3419",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Mex Grid Construction",
        "description": "A permutation of integers 1,2,…,n is called beautiful if there are no adjacent elements whose difference is 1 .\n\nGiven n , construct a beautiful permutation if such a permutation exists.\n\nInput\n\nThe only input line contains an integer n .\n\nOutput\n\nPrint a beautiful permutation of integers 1,2,…,n . If there are several solutions, you may print any of them. If there are no solutions, print \"NO SOLUTION\".\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample 1\n\nInput:\n\n\n5\n\n\nOutput:\n\n\n4 2 5 3 1\n\nExample 2\n\nInput:\n\n\n3\n\n\nOutput:\n\n\nNO SOLUTION",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "N = int(input())\nfor i in range(N):\n    for j in range(N):\n        print(i ^ j, end=' ' if j < N - 1 else '\\n')",
        "public_test_path": "/id/public/3419",
        "hidden_test_path": "/id/hidden/3419",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 3
    },
    {
        "problem_id": "gridcoloringi3311",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Grid Coloring I",
        "description": "A number spiral is an infinite grid whose upper-left square has number 1. Here are the first five layers of the spiral: Your task is to find out the number in row y and column x .\n\nInput\n\nThe first input line contains an integer t : the number of tests.\n\nAfter this, there are t lines, each containing integers y and x .\n\nOutput\n\nFor each test, print the number in row y and column x .\n\nConstraints\n\n1 ≤ t ≤ 10^5 1 ≤ y,x ≤ 10^9\n\nExample\n\nInput:\n\n\n3\n2 3\n1 1\n4 2\n\n\nOutput:\n\n\n8\n1\n15",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "N, M = map(int, input().split())\ncs = [['A', 'B'], ['C', 'D']]\n\nfor i in range(N):\n    for j in range(M):\n        c = input().strip()\n        odd = (i + j) % 2\n        small = c < 'C'\n        print(cs[small][odd], end='')\n    print()",
        "public_test_path": "/id/public/3311",
        "hidden_test_path": "/id/hidden/3311",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "gridpathdescription1625",
        "topic": "Chương 1",
        "sub_topic": "Introductory Problems",
        "name": "Grid Path Description",
        "description": "Your task is to count for k=1,2,…,n the number of ways two knights can be placed on a k × k chessboard so that they do not attack each other.\n\nInput\n\nThe only input line contains an integer n .\n\nOutput\n\nPrint n integers: the results.\n\nConstraints\n\n1 ≤ n ≤ 10000\n\nExample\n\nInput:\n\n\n8\n\n\nOutput:\n\n\n0\n6\n28\n96\n252\n550\n1056\n1848",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "N = 7\n\nans = 0\nc = input().strip()\nvis = [[False] * (N + 1) for _ in range(N + 1)]\n\ndef inbounds(x, y):\n    return 1 <= x <= N and 1 <= y <= N\n\ndef dfs(x, y, i):\n    global ans\n    if i == N * N - 1 or (x == N and y == 1):\n        ans += (i == N * N - 1 and (x == N and y == 1))\n        return\n\n    if (not inbounds(x + 1, y) or vis[x + 1][y]) and (not inbounds(x - 1, y) or vis[x - 1][y]):\n        if inbounds(x, y - 1) and not vis[x][y - 1] and inbounds(x, y + 1) and not vis[x][y + 1]:\n            return\n    if (not inbounds(x, y + 1) or vis[x][y + 1]) and (not inbounds(x, y - 1) or vis[x][y - 1]):\n        if inbounds(x + 1, y) and not vis[x + 1][y] and inbounds(x - 1, y) and not vis[x - 1][y]:\n            return\n\n    vis[x][y] = True\n    if c[i] == 'D' or c[i] == '?':\n        if inbounds(x + 1, y) and not vis[x + 1][y]:\n            dfs(x + 1, y, i + 1)\n    if c[i] == 'U' or c[i] == '?':\n        if inbounds(x - 1, y) and not vis[x - 1][y]:\n            dfs(x - 1, y, i + 1)\n    if c[i] == 'R' or c[i] == '?':\n        if inbounds(x, y + 1) and not vis[x][y + 1]:\n            dfs(x, y + 1, i + 1)\n    if c[i] == 'L' or c[i] == '?':\n        if inbounds(x, y - 1) and not vis[x][y - 1]:\n            dfs(x, y - 1, i + 1)\n    vis[x][y] = False\n\ndfs(1, 1, 0)\nprint(ans)",
        "public_test_path": "/id/public/1625",
        "hidden_test_path": "/id/hidden/1625",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "collectingnumbersii2217",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Collecting Numbers II",
        "description": "Your task is to divide the numbers 1,2,…,n into two sets of equal sum.\n\nInput\n\nThe only input line contains an integer n .\n\nOutput\n\nPrint \"YES\", if the division is possible, and \"NO\" otherwise.\n\nAfter this, if the division is possible, print an example of how to create the sets. First, print the number of elements in the first set followed by the elements themselves in a separate line, and then, print the second set in a similar way.\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample 1\n\nInput:\n\n\n7\n\n\nOutput:\n\n\nYES\n4\n1 2 4 7\n3\n3 5 6\n\nExample 2\n\nInput:\n\n\n6\n\n\nOutput:\n\n\nNO",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "maxN = int(2e5 + 5)\n\nN, M, cnt = 0, 0, 0\nx = [0] * maxN\npos = [0] * maxN\n\ndef update(a, b):\n    global cnt\n    if pos[x[a] - 1] <= pos[x[a]] and b < pos[x[a] - 1]:\n        cnt += 1\n    if pos[x[a] - 1] > pos[x[a]] and b >= pos[x[a] - 1]:\n        cnt -= 1\n    if pos[x[a] + 1] >= pos[x[a]] and b > pos[x[a] + 1]:\n        cnt += 1\n    if pos[x[a] + 1] < pos[x[a]] and b <= pos[x[a] + 1]:\n        cnt -= 1\n    pos[x[a]] = b\n\n    if pos[x[b] - 1] <= pos[x[b]] and a < pos[x[b] - 1]:\n        cnt += 1\n    if pos[x[b] - 1] > pos[x[b]] and a >= pos[x[b] - 1]:\n        cnt -= 1\n    if pos[x[b] + 1] >= pos[x[b]] and a > pos[x[b] + 1]:\n        cnt += 1\n    if pos[x[b] + 1] < pos[x[b]] and a <= pos[x[b] + 1]:\n        cnt -= 1\n    pos[x[b]] = a\n\n    x[a], x[b] = x[b], x[a]\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    for i in range(1, N + 1):\n        x[i] = int(input())\n        pos[x[i]] = i\n    pos[N + 1] = N + 1\n\n    cnt = 1\n    ptr = 0\n    for i in range(1, N + 1):\n        if ptr > pos[i]:\n            cnt += 1\n        ptr = pos[i]\n\n    for _ in range(M):\n        a, b = map(int, input().split())\n        update(a, b)\n        print(cnt)",
        "public_test_path": "/id/public/2217",
        "hidden_test_path": "/id/hidden/2217",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 2
    },
    {
        "problem_id": "josephusproblemi2162",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Josephus Problem I",
        "description": "Your task is to calculate the number of bit strings of length n .\n\nFor example, if n=3 , the correct answer is 8 , because the possible bit strings are 000, 001, 010, 011, 100, 101, 110, and 111.\n\nInput\n\nThe only input line has an integer n .\n\nOutput\n\nPrint the result modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\n3\n\n\nOutput:\n\n\n8",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from sortedcontainers import SortedList\n\nN = int(input())\nT = SortedList(range(1, N + 1))\n\nidx = 1\nwhile len(T) > 0:\n    idx %= len(T)\n    x = T[idx]\n    T.remove(x)\n    print(x, end=(\" \\n\" if len(T) == 0 else \" \"))\n    idx += 1",
        "public_test_path": "/id/public/2162",
        "hidden_test_path": "/id/hidden/2162",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "josephusproblemii2163",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Josephus Problem II",
        "description": "Your task is to calculate the number of trailing zeros in the factorial n! .\n\nFor example, 20!=2432902008176640000 and it has 4 trailing zeros.\n\nInput\n\nThe only input line has an integer n .\n\nOutput\n\nPrint the number of trailing zeros in n! .\n\nConstraints\n\n1 ≤ n ≤ 10^9\n\nExample\n\nInput:\n\n\n20\n\n\nOutput:\n\n\n4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from sortedcontainers import SortedList\n\nN, K = map(int, input().split())\nT = SortedList(range(1, N + 1))\n\nidx = K\nwhile T:\n    idx %= len(T)\n    x = T[idx]\n    T.remove(x)\n    print(x, end=(\" \\n\" if not T else \" \"))\n    idx += K",
        "public_test_path": "/id/public/2163",
        "hidden_test_path": "/id/hidden/2163",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 17
    },
    {
        "problem_id": "nestedrangescheck2168",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Nested Ranges Check",
        "description": "You have two coin piles containing a and b coins. On each move, you can either remove one coin from the left pile and two coins from the right pile, or two coins from the left pile and one coin from the right pile.\n\nYour task is to efficiently find out if you can empty both the piles.\n\nInput\n\nThe first input line has an integer t : the number of tests.\n\nAfter this, there are t lines, each of which has two integers a and b : the numbers of coins in the piles.\n\nOutput\n\nFor each test, print \"YES\" if you can empty the piles and \"NO\" otherwise.\n\nConstraints\n\n1 ≤ t ≤ 10^5 0 ≤ a, b ≤ 10^9\n\nExample\n\nInput:\n\n\n3\n2 1\n2 2\n3 3\n\n\nOutput:\n\n\nYES\nNO\nYES",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN = int(data[0])\nans = [[0] * (N) for _ in range(2)]\nds = [0] * (2 * (2 * 10**5 + 1))\nintervals = []\nunique_vals = set()\nmp = {}\n\ndef update(idx, val):\n    while idx < len(ds):\n        ds[idx] += val\n        idx += idx & -idx\n\ndef query(idx):\n    cnt = 0\n    while idx > 0:\n        cnt += ds[idx]\n        idx -= idx & -idx\n    return cnt\n\nfor i in range(1, N + 1):\n    x, y = map(int, data[i].split())\n    intervals.append((x, y, i - 1))\n    unique_vals.add(x)\n    unique_vals.add(y)\n\nintervals.sort(key=lambda A: (A[0], -A[1]))\n\nval_id = 1\nfor x in sorted(unique_vals):\n    mp[x] = val_id\n    val_id += 1\n\nfor i in range(N - 1, -1, -1):\n    y = mp[intervals[i][1]]\n    id = intervals[i][2]\n    ans[0][id] = query(y)\n    update(y, 1)\n\nds = [0] * (2 * (2 * 10**5 + 1))\nfor i in range(N):\n    y = mp[intervals[i][1]]\n    id = intervals[i][2]\n    ans[1][id] = i - query(y - 1)\n    update(y, 1)\n\nfor i in range(2):\n    for j in range(N):\n        print(1 if ans[i][j] else 0, end=' ' if j < N - 1 else '\\n')",
        "public_test_path": "/id/public/2168",
        "hidden_test_path": "/id/hidden/2168",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "nestedrangescount2169",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Nested Ranges Count",
        "description": "Given a string, your task is to reorder its letters in such a way that it becomes a palindrome (i.e., it reads the same forwards and backwards).\n\nInput\n\nThe only input line has a string of length n consisting of characters A–Z.\n\nOutput\n\nPrint a palindrome consisting of the characters of the original string. You may print any valid solution. If there are no solutions, print \"NO SOLUTION\".\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\nAAAACACBA\n\n\nOutput:\n\n\nAACABACAA",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN = int(data[0])\nans = [[0] * N for _ in range(2)]\nds = [0] * (2 * (2 * 10**5 + 1))\nintervals = []\nunique_vals = set()\nmp = {}\n\ndef update(idx, val):\n    while idx < len(ds):\n        ds[idx] += val\n        idx += idx & -idx\n\ndef query(idx):\n    cnt = 0\n    while idx > 0:\n        cnt += ds[idx]\n        idx -= idx & -idx\n    return cnt\n\nfor i in range(N):\n    x, y = map(int, data[i + 1].split())\n    intervals.append((x, y, i))\n    unique_vals.add(x)\n    unique_vals.add(y)\n\nintervals.sort(key=lambda A: (A[0], -A[1]))\n\nval_id = 1\nfor x in sorted(unique_vals):\n    mp[x] = val_id\n    val_id += 1\n\nfor i in range(N - 1, -1, -1):\n    y = mp[intervals[i][1]]\n    id = intervals[i][2]\n    ans[0][id] = query(y)\n    update(y, 1)\n\nds = [0] * (2 * (2 * 10**5 + 1))\nfor i in range(N):\n    y = mp[intervals[i][1]]\n    id = intervals[i][2]\n    ans[1][id] = i - query(y - 1)\n    update(y, 1)\n\nfor i in range(2):\n    print(' '.join(map(str, ans[i])))",
        "public_test_path": "/id/public/2169",
        "hidden_test_path": "/id/hidden/2169",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "subarraysumsi1660",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Subarray Sums I",
        "description": "A Gray code is a list of all 2^n bit strings of length n , where any two successive strings differ in exactly one bit (i.e., their Hamming distance is one).\n\nYour task is to create a Gray code for a given length n .\n\nInput\n\nThe only input line has an integer n .\n\nOutput\n\nPrint 2^n lines that describe the Gray code. You can print any valid solution.\n\nConstraints\n\n1 ≤ n ≤ 16\n\nExample\n\nInput:\n\n\n2\n\n\nOutput:\n\n\n00\n01\n11\n10",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "maxN = int(2e5)\n\nN, x = map(int, input().split())\na = list(map(int, input().split()))\na = [0] + a  # Adjusting index to start from 1\nsum = 0\ncnt = 0\nl = 1\n\nfor r in range(1, N + 1):\n    sum += a[r]\n    while sum > x:\n        sum -= a[l]\n        l += 1\n    if sum == x:\n        cnt += 1\n\nprint(cnt)",
        "public_test_path": "/id/public/1660",
        "hidden_test_path": "/id/hidden/1660",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "subarraysumsii1661",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Subarray Sums II",
        "description": "The Tower of Hanoi game consists of three stacks (left, middle and right) and n round disks of different sizes. Initially, the left stack has all the disks, in increasing order of size from top to bottom.\n\nThe goal is to move all the disks to the right stack using the middle stack. On each move you can move the uppermost disk from a stack to another stack. In addition, it is not allowed to place a larger disk on a smaller disk.\n\nYour task is to find a solution that minimizes the number of moves.\n\nInput\n\nThe only input line has an integer n : the number of disks.\n\nOutput\n\nFirst print an integer k : the minimum number of moves.\n\nAfter this, print k lines that describe the moves. Each line has two integers a and b : you move a disk from stack a to stack b .\n\nConstraints\n\n1 ≤ n ≤ 16\n\nExample\n\nInput:\n\n\n2\n\n\nOutput:\n\n\n3\n1 2\n1 3\n2 3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\n\nN, X = map(int, input().split())\nfreq = defaultdict(int)\nfreq[0] = 1\npre = 0\ncnt = 0\n\nfor _ in range(N):\n    a = int(input())\n    pre += a\n    cnt += freq[pre - X]\n    freq[pre] += 1\n\nprint(cnt)",
        "public_test_path": "/id/public/1661",
        "hidden_test_path": "/id/hidden/1661",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 28
    },
    {
        "problem_id": "distinctvaluessubarraysii2428",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Distinct Values Subarrays II",
        "description": "Given a string, your task is to generate all different strings that can be created using its characters.\n\nInput\n\nThe only input line has a string of length n . Each character is between a–z.\n\nOutput\n\nFirst print an integer k : the number of strings. Then print k lines: the strings in alphabetical order.\n\nConstraints\n\n1 ≤ n ≤ 8\n\nExample\n\nInput:\n\n\naabac\n\n\nOutput:\n\n\n20\naaabc\naaacb\naabac\naabca\naacab\naacba\nabaac\nabaca\nabcaa\nacaab\nacaba\nacbaa\nbaaac\nbaaca\nbacaa\nbcaaa\ncaaab\ncaaba\ncabaa\ncbaaa",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\n\nN, K = map(int, input().split())\nx = list(map(int, input().split()))\nx = [0] + x  # To make it 1-indexed\nfreq = defaultdict(int)\nans = 0\n\nunique = 0\nr = 0\nfor l in range(1, N + 1):\n    while r < N and (freq[x[r + 1]] >= 1 or unique < K):\n        r += 1\n        freq[x[r]] += 1\n        if freq[x[r]] == 1:\n            unique += 1\n\n    ans += (r - l + 1)\n\n    freq[x[l]] -= 1\n    if freq[x[l]] == 0:\n        unique -= 1\n\nprint(ans)",
        "public_test_path": "/id/public/2428",
        "hidden_test_path": "/id/hidden/2428",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "moviefestivalii1632",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Movie Festival II",
        "description": "There are n apples with known weights. Your task is to divide the apples into two groups so that the difference between the weights of the groups is minimal.\n\nInput\n\nThe first input line has an integer n : the number of apples.\n\nThe next line has n integers p_1,p_2,…,p_n : the weight of each apple.\n\nOutput\n\nPrint one integer: the minimum difference between the weights of the groups.\n\nConstraints\n\n1 ≤ n ≤ 20 1 ≤ p_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5\n3 2 7 4 1\n\n\nOutput:\n\n\n1\n\n\nExplanation: Group 1 has weights 2, 3 and 4 (total weight 9), and group 2 has weights 1 and 7 (total weight 8).",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import defaultdict\n\nmaxN = int(2e5)\nSIZE = int(5e6)\nINF = 0x3f3f3f3f\n\nN, K, ans = 0, 0, 0\nA = [0] * maxN\nB = [0] * maxN\nlo = [0] * SIZE\nhi = [0] * SIZE\nd = [0] * SIZE\nmx = [0] * SIZE\nmovies = []\nmp = {}\n\nclass Movie:\n    def __init__(self, t, id, type):\n        self.t = t\n        self.id = id\n        self.type = type\n\ndef push(i):\n    if d[i]:\n        d[2 * i] += d[i]\n        d[2 * i + 1] += d[i]\n        d[i] = 0\n\ndef pull(i):\n    mx[i] = max(mx[2 * i] + d[2 * i], mx[2 * i + 1] + d[2 * i + 1])\n\ndef init(i, l, r):\n    lo[i] = l\n    hi[i] = r\n    if l == r:\n        return\n    m = l + (r - l) // 2\n    init(2 * i, l, m)\n    init(2 * i + 1, m + 1, r)\n    pull(i)\n\ndef increment(i, l, r):\n    if l > hi[i] or r < lo[i]:\n        return\n    if l <= lo[i] and hi[i] <= r:\n        d[i] += 1\n        return\n    push(i)\n    increment(2 * i, l, r)\n    increment(2 * i + 1, l, r)\n    pull(i)\n\ndef maximum(i, l, r):\n    if l > hi[i] or r < lo[i]:\n        return -INF\n    if l <= lo[i] and hi[i] <= r:\n        return mx[i] + d[i]\n\n    push(i)\n    lmax = maximum(2 * i, l, r)\n    rmax = maximum(2 * i + 1, l, r)\n    pull(i)\n\n    return max(lmax, rmax)\n\ndef main():\n    global N, K, ans\n    N, K = map(int, sys.stdin.readline().split())\n    for i in range(N):\n        A[i], B[i] = map(int, sys.stdin.readline().split())\n        movies.append(Movie(A[i], i, 0))\n        movies.append(Movie(B[i], i, 1))\n    \n    movies.sort(key=lambda x: (x.t, -A[x.id] if x.type == 0 else x.t))\n\n    for i in range(2 * N):\n        mp[movies[i].t] = 2 * i + 1\n\n    init(1, 1, 4 * N)\n    for i in range(2 * N):\n        if movies[i].type == 1:\n            id = movies[i].id\n            a = mp[A[id]]\n            b = mp[B[id]]\n\n            if maximum(1, a, b) < K:\n                increment(1, a, b - 1)\n                ans += 1\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1632",
        "hidden_test_path": "/id/hidden/1632",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "maximumsubarraysumii1644",
        "topic": "Chương 1",
        "sub_topic": "Sorting and Searching",
        "name": "Maximum Subarray Sum II",
        "description": "Your task is to place eight queens on a chessboard so that no two queens are attacking each other. As an additional challenge, each square is either free or reserved, and you can only place queens on the free squares. However, the reserved squares do not prevent queens from attacking each other.\n\nHow many possible ways are there to place the queens?\n\nInput\n\nThe input has eight lines, and each of them has eight characters. Each square is either free ( . ) or reserved ( * ).\n\nOutput\n\nPrint one integer: the number of ways you can place the queens.\n\nExample\n\nInput:\n\n\n........\n........\n..*.....\n........\n........\n.....**.\n...*....\n........\n\n\nOutput:\n\n\n65",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from sortedcontainers import SortedList\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = int(data[1])\nB = int(data[2])\npre = [0] * (N + 1)\n\nfor i in range(1, N + 1):\n    pre[i] = pre[i - 1] + int(data[i + 2])\n\nS = SortedList()\n\nfor i in range(A, B + 1):\n    S.add(pre[i])\n\nbest = S[-1]\nfor i in range(1, N - A + 2):\n    S.remove(pre[i + A - 1])\n    S.add(pre[min(i + B, N)])\n    best = max(best, S[-1] - pre[i])\n\nprint(best)",
        "public_test_path": "/id/public/1644",
        "hidden_test_path": "/id/hidden/1644",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 25
    },
    {
        "problem_id": "dicecombinations1633",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Dice Combinations",
        "description": "Consider a two player game where each player has n cards numbered 1,2,…,n . On each turn both players place one of their cards on the table. The player who placed the higher card gets one point. If the cards are equal, neither player gets a point. The game continues until all cards have been played.\n\nYou are given the number of cards n and the players' scores at the end of the game, a and b . Your task is to give an example of how the game could have played out.\n\nInput\n\nThe first line contains one integer t : the number of tests.\n\nThen there are t lines, each with three integers n , a and b .\n\nOutput\n\nFor each test case print YES if there is a game with the given outcome and NO otherwise.\n\nIf the answer is YES , print an example of one possible game. Print two lines representing the order in which the players place their cards. You can give any valid example.\n\nConstraints\n\n1 ≤ t ≤ 1000 1 ≤ n ≤ 100 0 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5\n4 1 2\n2 0 1\n3 0 0\n2 1 1\n4 4 1\n\n\nOutput:\n\n\nYES\n1 4 3 2\n2 1 3 4\nNO\nYES\n1 2 3\n1 2 3\nYES\n1 2\n2 1\nNO",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "maxN = int(1e6)\nMOD = int(1e9 + 7)\n\nN = int(input())\ndp = [0] * (maxN + 1)\ndp[0] = 1\n\nfor i in range(1, N + 1):\n    for j in range(1, 7):\n        if i - j >= 0:\n            dp[i] = (dp[i] + dp[i - j]) % MOD\n\nprint(dp[N])",
        "public_test_path": "/id/public/1633",
        "hidden_test_path": "/id/hidden/1633",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "minimizingcoins1634",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Minimizing Coins",
        "description": "Your task is to construct an n × n grid where each square has the smallest nonnegative integer that does not appear to the left on the same row or above on the same column.\n\nInput\n\nThe only line has an integer n .\n\nOutput\n\nPrint the grid according to the example.\n\nConstraints\n\n1 ≤ n ≤ 100\n\nExample\n\nInput:\n\n\n5\n\n\nOutput:\n\n\n0 1 2 3 4\n1 0 3 2 5\n2 3 0 1 6\n3 2 1 0 7\n4 5 6 7 0",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\nmaxX = int(1e6)\nINF = float('inf')\n\nN, X = map(int, sys.stdin.readline().split())\ndp = [INF] * (maxX + 1)\ndp[0] = 0\n\nfor _ in range(N):\n    c = int(sys.stdin.readline().strip())\n    for j in range(X - c + 1):\n        if dp[j] != INF:\n            dp[j + c] = min(dp[j + c], dp[j] + 1)\n\nprint(-1 if dp[X] == INF else dp[X])",
        "public_test_path": "/id/public/1634",
        "hidden_test_path": "/id/hidden/1634",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 18
    },
    {
        "problem_id": "coincombinationsi1635",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Coin Combinations I",
        "description": "There is a knight on an n × n chessboard. For each square, print the minimum number of moves the knight needs to do to reach the top-left corner.\n\nInput\n\nThe only line has an integer n .\n\nOutput\n\nPrint the number of moves for each square.\n\nConstraints\n\n4 ≤ n ≤ 1000\n\nExample\n\nInput:\n\n\n8\n\n\nOutput:\n\n\n0 3 2 3 2 3 4 5 \n3 4 1 2 3 4 3 4 \n2 1 4 3 2 3 4 5 \n3 2 3 2 3 4 3 4 \n2 3 2 3 4 3 4 5 \n3 4 3 4 3 4 5 4 \n4 3 4 3 4 5 4 5 \n5 4 5 4 5 4 5 6",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "maxN = 100\nmaxX = int(1e6)\nMOD = int(1e9 + 7)\n\nN, X = map(int, input().split())\nc = list(map(int, input().split()))\n\ndp = [0] * (maxX + 1)\ndp[0] = 1\n\nfor i in range(X):\n    if dp[i] != 0:\n        for j in range(N):\n            if i + c[j] <= X:\n                dp[i + c[j]] = (dp[i + c[j]] + dp[i]) % MOD\n\nprint(dp[X])",
        "public_test_path": "/id/public/1635",
        "hidden_test_path": "/id/hidden/1635",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "coincombinationsii1636",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Coin Combinations II",
        "description": "You are given an n× m grid where each cell contains one character A , B , C or D .\n\nFor each cell, you must change the character to A , B , C or D . The new character must be different from the old one.\n\nYour task is to change the characters in every cell such that no two adjacent cells have the same character.\n\nInput\n\nThe first line has two integers n and m : the number of rows and columns.\n\nThe next n lines each have m characters: the description of the grid.\n\nOutput\n\nPrint n lines each with m characters: the description of the final grid.\n\nYou may print any valid solution.\n\nIf no solution exists, just print IMPOSSIBLE .\n\nConstraints\n\n1 ≤ n, m ≤ 500\n\nExample\n\nInput:\n\n\n3 4\nAAAA\nBBBB\nCCDD\n\n\nOutput:\n\n\nCDCD\nDCDC\nABAB",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "maxX = int(1e6)\nMOD = int(1e9 + 7)\n\nN, X = map(int, input().split())\ndp = [0] * (maxX + 1)\ndp[0] = 1\n\nfor _ in range(N):\n    c = int(input())\n    for j in range(X - c + 1):\n        dp[j + c] = (dp[j + c] + dp[j]) % MOD\n\nprint(dp[X])",
        "public_test_path": "/id/public/1636",
        "hidden_test_path": "/id/hidden/1636",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "removingdigits1637",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Removing Digits",
        "description": "Consider an infinite string that consists of all positive integers in increasing order:\n\n12345678910111213141516171819202122232425...\n\nYour task is to process q queries of the form: what is the digit at position k in the string?\n\nInput\n\nThe first input line has an integer q : the number of queries.\n\nAfter this, there are q lines that describe the queries. Each line has an integer k : a 1 -indexed position in the string.\n\nOutput\n\nFor each query, print the corresponding digit.\n\nConstraints\n\n1 ≤ q ≤ 1000 1 ≤ k ≤ 10^{18}\n\nExample\n\nInput:\n\n\n3\n7\n19\n12\n\n\nOutput:\n\n\n7\n4\n1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "maxN = int(1e6)\nINF = float('inf')\n\nN = int(input())\ndp = [INF] * (maxN + 1)\ndp[0] = 0\n\nfor i in range(1, N + 1):\n    d = i\n    while d > 0:\n        if d % 10 != 0:\n            dp[i] = min(dp[i], dp[i - (d % 10)] + 1)\n        d //= 10\n\nprint(dp[N])",
        "public_test_path": "/id/public/1637",
        "hidden_test_path": "/id/hidden/1637",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "gridpathsi1638",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Grid Paths I",
        "description": "Your task is to reorder the characters of a string so that no two adjacent characters are the same. What is the lexicographically minimal such string?\n\nInput\n\nThe only line has a string of length n consisting of characters A–Z.\n\nOutput\n\nPrint the lexicographically minimal reordered string where no two adjacent characters are the same. If it is not possible to create such a string, print -1 .\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\nHATTIVATTI\n\n\nOutput:\n\n\nAHATITITVT",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = 10**9 + 7\nmaxN = 1000\n\nN = int(input())\nc = [input().strip() for _ in range(N)]\ndp = [[0] * (maxN + 1) for _ in range(maxN + 1)]\n\ndp[1][1] = 1 if c[0][0] == '.' else 0\nfor i in range(1, N + 1):\n    for j in range(1, N + 1):\n        if c[i - 1][j - 1] == '.':\n            if i > 1 and c[i - 2][j - 1] == '.':\n                dp[i][j] += dp[i - 1][j]\n            if j > 1 and c[i - 1][j - 2] == '.':\n                dp[i][j] += dp[i][j - 1]\n            dp[i][j] %= MOD\n\nprint(dp[N][N])",
        "public_test_path": "/id/public/1638",
        "hidden_test_path": "/id/hidden/1638",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "arraydescription1746",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Array Description",
        "description": "There are 88418 paths in a 7 × 7 grid from the upper-left square to the lower-left square. Each path corresponds to a 48 -character description consisting of characters D (down), U (up), L (left) and R (right).\n\nFor example, the path corresponds to the description DRURRRRRDDDLUULDDDLDRRURDDLLLLLURULURRUULDLLDDDD .\n\nYou are given a description of a path which may also contain characters ? (any direction). Your task is to calculate the number of paths that match the description.\n\nInput\n\nThe only input line has a 48 -character string of characters ? , D , U , L and R .\n\nOutput\n\nPrint one integer: the total number of paths.\n\nExample\n\nInput:\n\n\n??????R??????U??????????????????????????LD????D?\n\n\nOutput:\n\n\n201",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = int(1e9 + 7)\n\nN, M = map(int, input().split())\nx = list(map(int, input().split()))\nx = [0] + x  # Adjusting index to start from 1\nans = 0\ndp = [[0] * (M + 1) for _ in range(N + 1)]\n\nif x[1]:\n    dp[1][x[1]] = 1\nelse:\n    for i in range(1, M + 1):\n        dp[1][i] = 1\n\nfor i in range(2, N + 1):\n    for j in range(1, M + 1):\n        dp[i][j] = dp[i - 1][j]\n        if j != 1:\n            dp[i][j] += dp[i - 1][j - 1]\n        if j != M:\n            dp[i][j] += dp[i - 1][j + 1]\n        dp[i][j] %= MOD\n\n    if x[i]:\n        for j in range(M + 1):\n            if j != x[i]:\n                dp[i][j] = 0\n\nfor i in range(1, M + 1):\n    ans = (ans + dp[N][i]) % MOD\n\nprint(ans)",
        "public_test_path": "/id/public/1746",
        "hidden_test_path": "/id/hidden/1746",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 29
    },
    {
        "problem_id": "twosetsii1093",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Two Sets II",
        "description": "You are given a list of n integers, and your task is to calculate the number of distinct values in the list.\n\nInput\n\nThe first input line has an integer n : the number of values.\n\nThe second line has n integers x_1,x_2,…,x_n .\n\nOutput\n\nPrint one integers: the number of distinct values.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5\n2 3 2 2 3\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "mp = [0] * 501\n\ndef init():\n    global mp\n    mp[3] = 1\n    mp[4] = 1\n    mp[7] = 4\n    mp[8] = 7\n    mp[11] = 35\n    mp[12] = 62\n    mp[15] = 361\n    mp[16] = 657\n    mp[19] = 4110\n    mp[20] = 7636\n    mp[23] = 49910\n    mp[24] = 93846\n    mp[27] = 632602\n    mp[28] = 1199892\n    mp[31] = 8273610\n    mp[32] = 15796439\n    mp[35] = 110826888\n    mp[36] = 212681976\n    mp[39] = 512776583\n    mp[40] = 915017346\n    mp[43] = 965991877\n    mp[44] = 536015750\n    mp[47] = 245739109\n    mp[48] = 497111739\n    mp[51] = 319303648\n    mp[52] = 661531964\n    mp[55] = 919134122\n    mp[56] = 526597333\n    mp[59] = 857860749\n    mp[60] = 323065127\n    mp[63] = 142897738\n    mp[64] = 454622296\n    mp[67] = 832964922\n    mp[68] = 112945499\n    mp[71] = 21130483\n    mp[72] = 134912852\n    mp[75] = 58392205\n    mp[76] = 594756797\n    mp[79] = 116285762\n    mp[80] = 46020942\n    mp[83] = 199311883\n    mp[84] = 637852081\n    mp[87] = 681073029\n    mp[88] = 687587655\n    mp[91] = 403293621\n    mp[92] = 859161650\n    mp[95] = 135570834\n    mp[96] = 16951659\n    mp[99] = 90174435\n    mp[100] = 906443459\n    mp[103] = 445036292\n    mp[104] = 696064542\n    mp[107] = 589938798\n    mp[108] = 17765238\n    mp[111] = 671699270\n    mp[112] = 979144036\n    mp[115] = 717567569\n    mp[116] = 962408760\n    mp[119] = 24874238\n    mp[120] = 651719820\n    mp[123] = 882521441\n    mp[124] = 815306501\n    mp[127] = 177673311\n    mp[128] = 381523124\n    mp[131] = 647107433\n    mp[132] = 822743471\n    mp[135] = 951125976\n    mp[136] = 913762232\n    mp[139] = 860772858\n    mp[140] = 718799291\n    mp[143] = 546548485\n    mp[144] = 520899315\n    mp[147] = 348826222\n    mp[148] = 979465686\n    mp[151] = 551269897\n    mp[152] = 226367872\n    mp[155] = 224237396\n    mp[156] = 275455845\n    mp[159] = 597702194\n    mp[160] = 580526114\n    mp[163] = 837164670\n    mp[164] = 579854574\n    mp[167] = 643888367\n    mp[168] = 547744591\n    mp[171] = 362172782\n    mp[172] = 203753851\n    mp[175] = 472078730\n    mp[176] = 414960148\n    mp[179] = 751350256\n    mp[180] = 597996235\n    mp[183] = 302890488\n    mp[184] = 463389357\n    mp[187] = 28369705\n    mp[188] = 625260957\n    mp[191] = 439010166\n    mp[192] = 625343710\n    mp[195] = 345211145\n    mp[196] = 783212645\n    mp[199] = 171026155\n    mp[200] = 746149676\n    mp[203] = 574908810\n    mp[204] = 400819234\n    mp[207] = 797285006\n    mp[208] = 671068618\n    mp[211] = 857904807\n    mp[212] = 118539037\n    mp[215] = 258515519\n    mp[216] = 103887197\n    mp[219] = 692754470\n    mp[220] = 307691579\n    mp[223] = 543477917\n    mp[224] = 494845326\n    mp[227] = 461141061\n    mp[228] = 681627336\n    mp[231] = 194431224\n    mp[232] = 798222254\n    mp[235] = 34177070\n    mp[236] = 324550451\n    mp[239] = 395144714\n    mp[240] = 314224734\n    mp[243] = 256354567\n    mp[244] = 216295565\n    mp[247] = 556521816\n    mp[248] = 594547313\n    mp[251] = 701665484\n    mp[252] = 287171616\n    mp[255] = 305999810\n    mp[256] = 817725356\n    mp[259] = 456522567\n    mp[260] = 42456953\n    mp[263] = 53352478\n    mp[264] = 896195082\n    mp[267] = 374247344\n    mp[268] = 900048655\n    mp[271] = 613110673\n    mp[272] = 91338349\n    mp[275] = 904876664\n    mp[276] = 300880501\n    mp[279] = 604541603\n    mp[280] = 441166519\n    mp[283] = 73667549\n    mp[284] = 41483999\n    mp[287] = 51276243\n    mp[288] = 149197976\n    mp[291] = 539103967\n    mp[292] = 982253554\n    mp[295] = 969982399\n    mp[296] = 98482383\n    mp[299] = 605461327\n    mp[300] = 65785519\n    mp[303] = 548373331\n    mp[304] = 421491751\n    mp[307] = 480765781\n    mp[308] = 925355425\n    mp[311] = 850819946\n    mp[312] = 434384766\n    mp[315] = 747079619\n    mp[316] = 140715817\n    mp[319] = 154291092\n    mp[320] = 436737393\n    mp[323] = 694334366\n    mp[324] = 278298264\n    mp[327] = 100011200\n    mp[328] = 186925353\n    mp[331] = 951803656\n    mp[332] = 826521841\n    mp[335] = 467206470\n    mp[336] = 625245512\n    mp[339] = 37014692\n    mp[340] = 370302058\n    mp[343] = 942594593\n    mp[344] = 625802329\n    mp[347] = 696810018\n    mp[348] = 839447903\n    mp[351] = 973813010\n    mp[352] = 340829958\n    mp[355] = 333578000\n    mp[356] = 162910708\n    mp[359] = 898163184\n    mp[360] = 938735258\n    mp[363] = 969420912\n    mp[364] = 767331949\n    mp[367] = 49040853\n    mp[368] = 864361228\n    mp[371] = 666086921\n    mp[372] = 681324453\n    mp[375] = 406330883\n    mp[376] = 715350645\n    mp[379] = 276425302\n    mp[380] = 691275326\n    mp[383] = 936153559\n    mp[384] = 806887794\n    mp[387] = 672700998\n    mp[388] = 324056520\n    mp[391] = 624244157\n    mp[392] = 887151949\n    mp[395] = 111928807\n    mp[396] = 555201478\n    mp[399] = 892266330\n    mp[400] = 406976742\n    mp[403] = 179624853\n    mp[404] = 766709833\n    mp[407] = 615024703\n    mp[408] = 25276943\n    mp[411] = 675398735\n    mp[412] = 373735428\n    mp[415] = 283235362\n    mp[416] = 613728485\n    mp[419] = 581407804\n    mp[420] = 135760574\n    mp[423] = 421029356\n    mp[424] = 925084280\n    mp[427] = 409496848\n    mp[428] = 345330916\n    mp[431] = 754684998\n    mp[432] = 388429454\n    mp[435] = 997193850\n    mp[436] = 722803385\n    mp[439] = 747396848\n    mp[440] = 879532546\n    mp[443] = 363180870\n    mp[444] = 301109892\n    mp[447] = 337814331\n    mp[448] = 439172004\n    mp[451] = 142119927\n    mp[452] = 761228466\n    mp[455] = 649629227\n    mp[456] = 868002592\n    mp[459] = 927500726\n    mp[460] = 71856333\n    mp[463] = 621649641\n    mp[464] = 86464550\n    mp[467] = 159973467\n    mp[468] = 281964303\n    mp[471] = 220801847\n    mp[472] = 172221992\n    mp[475] = 631635476\n    mp[476] = 30971150\n    mp[479] = 664722592\n    mp[480] = 692804591\n    mp[483] = 620001363\n    mp[484] = 22371363\n    mp[487] = 541326371\n    mp[488] = 8514587\n    mp[491] = 996643776\n    mp[492] = 106479414\n    mp[495] = 920757401\n    mp[496] = 236457589\n    mp[499] = 608650075\n    mp[500] = 71857061\n\ndef main():\n    init()\n    N = int(input())\n    print(mp[N])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1093",
        "hidden_test_path": "/id/hidden/1093",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 24
    },
    {
        "problem_id": "increasingsubsequenceii1748",
        "topic": "Chương 1",
        "sub_topic": "Dynamic Programming",
        "name": "Increasing Subsequence II",
        "description": "There are n applicants and m free apartments. Your task is to distribute the apartments so that as many applicants as possible will get an apartment.\n\nEach applicant has a desired apartment size, and they will accept any apartment whose size is close enough to the desired size.\n\nInput\n\nThe first input line has three integers n , m , and k : the number of applicants, the number of apartments, and the maximum allowed difference.\n\nThe next line contains n integers a_1, a_2, …, a_n : the desired apartment size of each applicant. If the desired size of an applicant is x , they will accept any apartment whose size is between x-k and x+k .\n\nThe last line contains m integers b_1, b_2, …, b_m : the size of each apartment.\n\nOutput\n\nPrint one integer: the number of applicants who will get an apartment.\n\nConstraints\n\n1 ≤ n, m ≤ 2 · 10^5 0 ≤ k ≤ 10^9 1 ≤ a_i, b_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4 3 5\n60 45 80 60\n30 60 75\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = int(1e9 + 7)\nmaxN = int(2e5 + 5)\n\nN = int(input())\nans = 0\nds = [0] * maxN\nops = []\n\nclass Operation:\n    def __init__(self, x, idx):\n        self.x = x\n        self.idx = idx\n\ndef update(idx, val):\n    while idx < maxN:\n        ds[idx] = (ds[idx] + val) % MOD\n        idx += -idx & idx\n\ndef query(idx):\n    sum_ = 0\n    while idx > 0:\n        sum_ = (sum_ + ds[idx]) % MOD\n        idx -= -idx & idx\n    return sum_\n\nfor i in range(N):\n    x = int(input())\n    ops.append(Operation(x, i + 1))\n\nops.sort(key=lambda op: (op.x, -op.idx))\n\nfor i in range(N):\n    idx = ops[i].idx\n    amnt = query(idx) + 1\n    ans = (ans + amnt) % MOD\n    update(idx, amnt)\n\nprint(ans)",
        "public_test_path": "/id/public/1748",
        "hidden_test_path": "/id/hidden/1748",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "shortestroutesi1671",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Shortest Routes I",
        "description": "There are n children who want to go to a Ferris wheel, and your task is to find a gondola for each child.\n\nEach gondola may have one or two children in it, and in addition, the total weight in a gondola may not exceed x . You know the weight of every child.\n\nWhat is the minimum number of gondolas needed for the children?\n\nInput\n\nThe first input line contains two integers n and x : the number of children and the maximum allowed weight.\n\nThe next line contains n integers p_1,p_2,…,p_n : the weight of each child.\n\nOutput\n\nPrint one integer: the minimum number of gondolas.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x ≤ 10^9 1 ≤ p_i ≤ x\n\nExample\n\nInput:\n\n\n4 10\n7 2 3 9\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\nindex = 0\n\nN = int(data[index])\nM = int(data[index + 1])\nindex += 2\n\nclass Edge:\n    def __init__(self, v, w):\n        self.v = v\n        self.w = w\n\nclass Node:\n    def __init__(self, id, dist):\n        self.id = id\n        self.dist = dist\n\n    def __lt__(self, other):\n        return self.dist > other.dist\n\ndist = [float('inf')] * (N + 1)\nG = [[] for _ in range(N + 1)]\nQ = []\n\nfor _ in range(M):\n    a = int(data[index])\n    b = int(data[index + 1])\n    c = int(data[index + 2])\n    index += 3\n    G[a].append(Edge(b, c))\n\ndist[1] = 0\nheapq.heappush(Q, Node(1, 0))\n\nwhile Q:\n    d = Q[0].dist\n    u = Q[0].id\n    heapq.heappop(Q)\n\n    if d > dist[u]:\n        continue\n\n    for e in G[u]:\n        if dist[e.v] > d + e.w:\n            dist[e.v] = d + e.w\n            heapq.heappush(Q, Node(e.v, d + e.w))\n\nfor i in range(1, N + 1):\n    end_char = \" \\n\" if i == N else \" \"\n    print(dist[i], end=end_char)",
        "public_test_path": "/id/public/1671",
        "hidden_test_path": "/id/hidden/1671",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 24
    },
    {
        "problem_id": "shortestroutesii1672",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Shortest Routes II",
        "description": "There are n concert tickets available, each with a certain price. Then, m customers arrive, one after another.\n\nEach customer announces the maximum price they are willing to pay for a ticket, and after this, they will get a ticket with the nearest possible price such that it does not exceed the maximum price.\n\nInput\n\nThe first input line contains integers n and m : the number of tickets and the number of customers.\n\nThe next line contains n integers h_1,h_2,…,h_n : the price of each ticket.\n\nThe last line contains m integers t_1,t_2,…,t_m : the maximum price for each customer in the order they arrive.\n\nOutput\n\nPrint, for each customer, the price that they will pay for their ticket. After this, the ticket cannot be purchased again.\n\nIf a customer cannot get any ticket, print -1 .\n\nConstraints\n\n1 ≤ n, m ≤ 2 · 10^5 1 ≤ h_i, t_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5 3\n5 3 7 8 5\n4 8 3\n\n\nOutput:\n\n\n3\n8\n-1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport itertools\n\nmaxN = 500\nINF = 0x3f3f3f3f3f3f3f3f\n\nN, M, Q = map(int, sys.stdin.readline().split())\ndist = [[INF] * (maxN + 1) for _ in range(maxN + 1)]\n\nfor _ in range(M):\n    a, b, c = map(int, sys.stdin.readline().split())\n    dist[a][b] = min(dist[a][b], c)\n    dist[b][a] = min(dist[b][a], c)\n\nfor i in range(1, N + 1):\n    dist[i][i] = 0\n\nfor k in range(1, N + 1):\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\nfor _ in range(Q):\n    a, b = map(int, sys.stdin.readline().split())\n    print(-1 if dist[a][b] >= INF else dist[a][b])",
        "public_test_path": "/id/public/1672",
        "hidden_test_path": "/id/hidden/1672",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "roundtripii1678",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Round Trip II",
        "description": "You are given the arrival and leaving times of n customers in a restaurant.\n\nWhat was the maximum number of customers in the restaurant at any time?\n\nInput\n\nThe first input line has an integer n : the number of customers.\n\nAfter this, there are n lines that describe the customers. Each line has two integers a and b : the arrival and leaving times of a customer.\n\nYou may assume that all arrival and leaving times are distinct.\n\nOutput\n\nPrint one integer: the maximum number of customers.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ a < b ≤ 10^9\n\nExample\n\nInput:\n\n\n3\n5 8\n2 4\n3 9\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\n\nmaxN = int(1e5 + 1)\n\nN, M = map(int, input().split())\nG = defaultdict(list)\np = [0] * maxN\nvis = [0] * maxN\nans = []\nstart = finish = 0\n\ndef dfs(u):\n    global start, finish\n    vis[u] = 1\n    for v in G[u]:\n        if vis[v] == 0:\n            p[v] = u\n            dfs(v)\n            if start:\n                return\n        elif vis[v] == 1:\n            finish = u\n            start = v\n            return\n    vis[u] = 2\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    G[a].append(b)\n\nfor i in range(1, N + 1):\n    if vis[i] == 0 and not start:\n        dfs(i)\n\nif not start:\n    print(\"IMPOSSIBLE\")\nelse:\n    ans.append(start)\n    for u in range(finish, start, p[u]):\n        ans.append(u)\n    ans.append(start)\n    ans.reverse()\n\n    K = len(ans)\n    print(K)\n    print(' '.join(map(str, ans)))",
        "public_test_path": "/id/public/1678",
        "hidden_test_path": "/id/hidden/1678",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 23
    },
    {
        "problem_id": "planetsqueriesi1750",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Planets Queries I",
        "description": "In a movie festival n movies will be shown. You know the starting and ending time of each movie. What is the maximum number of movies you can watch entirely?\n\nInput\n\nThe first input line has an integer n : the number of movies.\n\nAfter this, there are n lines that describe the movies. Each line has two integers a and b : the starting and ending times of a movie.\n\nOutput\n\nPrint one integer: the maximum number of movies.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ a < b ≤ 10^9\n\nExample\n\nInput:\n\n\n3\n3 5\n4 9\n5 8\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "maxN = int(2e5 + 1)\nlogK = 31\n\nN, Q = map(int, input().split())\np = [[0] * logK for _ in range(maxN)]\n\nfor i in range(1, N + 1):\n    p[i][0] = int(input())\n\nfor j in range(1, logK):\n    for i in range(1, N + 1):\n        p[i][j] = p[p[i][j - 1]][j - 1]\n\nfor _ in range(Q):\n    x, k = map(int, input().split())\n    for i in range(logK):\n        if k & (1 << i):\n            x = p[x][i]\n    print(x)",
        "public_test_path": "/id/public/1750",
        "hidden_test_path": "/id/hidden/1750",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "planetsqueriesii1160",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Planets Queries II",
        "description": "You are given an array of n integers, and your task is to find two values (at distinct positions) whose sum is x .\n\nInput\n\nThe first input line has two integers n and x : the array size and the target sum.\n\nThe second line has n integers a_1,a_2,…,a_n : the array values.\n\nOutput\n\nPrint two integers: the positions of the values. If there are several solutions, you may print any of them. If there are no solutions, print IMPOSSIBLE .\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x,a_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4 8\n2 7 5 1\n\n\nOutput:\n\n\n2 4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import defaultdict\n\nmaxN = int(2e5 + 1)\nlogN = 20\n\nvis = [False] * maxN\nN, Q = map(int, sys.stdin.readline().split())\nds = [-1] * maxN\nd = [0] * maxN\ncomp = [0] * maxN\ncyc = [0] * maxN\np = [[0] * maxN for _ in range(logN)]\ncycleSeeds = []\nG = defaultdict(list)\n\ndef find(u):\n    if ds[u] < 0:\n        return u\n    ds[u] = find(ds[u])\n    return ds[u]\n\ndef merge(u, v):\n    u = find(u)\n    v = find(v)\n    if u == v:\n        return False\n    if ds[u] < ds[v]:\n        u, v = v, u\n    ds[v] += ds[u]\n    ds[u] = v\n    return True\n\ndef init_parents():\n    for i in range(1, logN):\n        for j in range(1, N + 1):\n            p[i][j] = p[i - 1][p[i - 1][j]]\n\ndef travel(u, k):\n    v = u\n    for i in range(logN - 1, -1, -1):\n        if k & (1 << i):\n            v = p[i][v]\n    return v\n\ndef dfs(u, compID):\n    vis[u] = True\n    comp[u] = compID\n    for v in G[u]:\n        if not vis[v]:\n            d[v] = d[u] + 1\n            dfs(v, compID)\n        else:\n            cyc[u] = d[u] + 1\n        cyc[u] = max(cyc[u], cyc[v])\n\ndef query(a, b):\n    if a == b:\n        return 0\n\n    if comp[a] != comp[b]:\n        return -1\n\n    if cyc[a]:\n        if not cyc[b]:\n            return -1\n        return (d[a] - d[b] + cyc[a]) % cyc[a]\n\n    if not cyc[b]:\n        if d[a] <= d[b]:\n            return -1\n        dist = d[a] - d[b]\n        return dist if travel(a, dist) == b else -1\n\n    root = a\n    for i in range(logN - 1, -1, -1):\n        par = p[i][root]\n        if not cyc[par]:\n            root = par\n    root = p[0][root]\n\n    return (d[a] - d[root]) + query(root, b)\n\nfor i in range(1, N + 1):\n    x = int(sys.stdin.readline().strip())\n    p[0][i] = x\n    G[x].append(i)\n    if not merge(x, i):\n        cycleSeeds.append(x)\n\ninit_parents()\ncompID = 1\nfor seed in cycleSeeds:\n    dfs(seed, compID)\n    \nfor _ in range(Q):\n    a, b = map(int, sys.stdin.readline().split())\n    print(query(a, b))",
        "public_test_path": "/id/public/1160",
        "hidden_test_path": "/id/hidden/1160",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "flightroutescheck1682",
        "topic": "Chương 1",
        "sub_topic": "Graph Algorithms",
        "name": "Flight Routes Check",
        "description": "Given an array of n integers, your task is to find the maximum sum of values in a contiguous, nonempty subarray.\n\nInput\n\nThe first input line has an integer n : the size of the array.\n\nThe second line has n integers x_1,x_2,…,x_n : the array values.\n\nOutput\n\nPrint one integer: the maximum subarray sum.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 -10^9 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8\n-1 3 -2 5 3 -5 2 2\n\n\nOutput:\n\n\n9",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "maxN = int(2e5 + 1)\n\nN, M = map(int, input().split())\nvis1 = [False] * maxN\nvis2 = [False] * maxN\nG1 = [[] for _ in range(maxN)]\nG2 = [[] for _ in range(maxN)]\n\ndef dfs1(u=1, p=0):\n    vis1[u] = True\n    for v in G1[u]:\n        if v != p and not vis1[v]:\n            dfs1(v, u)\n\ndef dfs2(u=1, p=0):\n    vis2[u] = True\n    for v in G2[u]:\n        if v != p and not vis2[v]:\n            dfs2(v, u)\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    G1[a].append(b)\n    G2[b].append(a)\n\ndfs1()\ndfs2()\n\nfor i in range(1, N + 1):\n    if not vis1[i] or not vis2[i]:\n        print(\"NO\")\n        if not vis1[i]:\n            print(f\"1 {i}\")\n        else:\n            print(f\"{i} 1\")\n        exit()\n\nprint(\"YES\")",
        "public_test_path": "/id/public/1682",
        "hidden_test_path": "/id/hidden/1682",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "staticrangesumqueries1646",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Static Range Sum Queries",
        "description": "There are n sticks with some lengths. Your task is to modify the sticks so that each stick has the same length.\n\nYou can either lengthen and shorten each stick. Both operations cost x where x is the difference between the new and original length.\n\nWhat is the minimum total cost?\n\nInput\n\nThe first input line contains an integer n : the number of sticks.\n\nThen there are n integers: p_1,p_2,…,p_n : the lengths of the sticks.\n\nOutput\n\nPrint one integer: the minimum total cost.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ p_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5\n2 3 1 5 2\n\n\nOutput:\n\n\n5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\nmaxN = int(2e5)\n\nN, Q = map(int, sys.stdin.readline().split())\nx = [0] * (maxN + 1)\n\nfor i in range(1, N + 1):\n    x[i] = x[i - 1] + int(sys.stdin.readline().strip())\n\nfor _ in range(Q):\n    a, b = map(int, sys.stdin.readline().split())\n    print(x[b] - x[a - 1])",
        "public_test_path": "/id/public/1646",
        "hidden_test_path": "/id/hidden/1646",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 2
    },
    {
        "problem_id": "staticrangeminimumqueries1647",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Static Range Minimum Queries",
        "description": "You have n coins with positive integer values. What is the smallest sum you cannot create using a subset of the coins?\n\nInput\n\nThe first line has an integer n : the number of coins.\n\nThe second line has n integers x_1,x_2,…,x_n : the value of each coin.\n\nOutput\n\nPrint one integer: the smallest coin sum.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5\n2 9 1 2 7\n\n\nOutput:\n\n\n6",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport math\n\nmaxN = int(2e5 + 1)\nlogN = 19\n\nN, Q = map(int, sys.stdin.readline().split())\nx = [[0] * logN for _ in range(maxN)]\n\nfor i in range(N):\n    x[i][0] = int(sys.stdin.readline().strip())\n\nfor i in range(1, logN):\n    for j in range(N - (1 << i) + 1):\n        x[j][i] = min(x[j][i - 1], x[j + (1 << (i - 1))][i - 1])\n\nfor _ in range(Q):\n    a, b = map(int, sys.stdin.readline().split())\n    a -= 1\n    b -= 1\n    l = b - a + 1\n    k = int(math.log2(l))\n    print(min(x[a][k], x[b - (1 << k) + 1][k]))",
        "public_test_path": "/id/public/1647",
        "hidden_test_path": "/id/hidden/1647",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    },
    {
        "problem_id": "dynamicrangesumqueries1648",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Dynamic Range Sum Queries",
        "description": "You are given an array that contains each number between 1 … n exactly once. Your task is to collect the numbers from 1 to n in increasing order.\n\nOn each round, you go through the array from left to right and collect as many numbers as possible. What will be the total number of rounds?\n\nInput\n\nThe first line has an integer n : the array size.\n\nThe next line has n integers x_1,x_2,…,x_n : the numbers in the array.\n\nOutput\n\nPrint one integer: the number of rounds.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5\n\nExample\n\nInput:\n\n\n5\n4 2 1 5 3\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\nmaxN = int(2e5)\nN, Q = map(int, sys.stdin.readline().split())\nx = [0] * (maxN + 1)\nds = [0] * (maxN + 1)\n\ndef update(idx, val):\n    diff = val - x[idx]\n    i = idx\n    while i <= N:\n        ds[i] += diff\n        i += -i & i\n    x[idx] = val\n\ndef query(idx):\n    sum_ = 0\n    i = idx\n    while i > 0:\n        sum_ += ds[i]\n        i -= -i & i\n    return sum_\n\nfor i in range(1, N + 1):\n    x[0] = int(sys.stdin.readline().strip())\n    update(i, x[0])\n\nfor _ in range(Q):\n    t, a, b = map(int, sys.stdin.readline().split())\n    if t == 1:\n        update(a, b)\n    else:\n        print(query(b) - query(a - 1))",
        "public_test_path": "/id/public/1648",
        "hidden_test_path": "/id/hidden/1648",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 2
    },
    {
        "problem_id": "dynamicrangeminimumqueries1649",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Dynamic Range Minimum Queries",
        "description": "You are given an array that contains each number between 1 … n exactly once. Your task is to collect the numbers from 1 to n in increasing order.\n\nOn each round, you go through the array from left to right and collect as many numbers as possible.\n\nGiven m operations that swap two numbers in the array, your task is to report the number of rounds after each operation.\n\nInput\n\nThe first line has two integers n and m : the array size and the number of operations.\n\nThe next line has n integers x_1,x_2,…,x_n : the numbers in the array.\n\nFinally, there are m lines that describe the operations. Each line has two integers a and b : the numbers at positions a and b are swapped.\n\nOutput\n\nPrint m integers: the number of rounds after each swap.\n\nConstraints\n\n1 ≤ n, m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 3\n4 2 1 5 3\n2 3\n1 5\n2 3\n\n\nOutput:\n\n\n2\n3\n4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport math\n\nmaxN = int(2e5)\nSIZE = 4 * maxN\nINF = float('inf')\n\nN, Q = map(int, sys.stdin.readline().split())\nlo = [0] * SIZE\nhi = [0] * SIZE\nmn = [0] * SIZE\n\ndef push(i):\n    pass\n\ndef pull(i):\n    mn[i] = min(mn[2 * i], mn[2 * i + 1])\n\ndef init(i, l, r):\n    lo[i] = l\n    hi[i] = r\n    if l == r:\n        mn[i] = int(sys.stdin.readline().strip())\n        return\n    m = l + (r - l) // 2\n    init(2 * i, l, m)\n    init(2 * i + 1, m + 1, r)\n    pull(i)\n\ndef assign(i, l, r, v):\n    if l > hi[i] or r < lo[i]:\n        return\n    if l <= lo[i] and hi[i] <= r:\n        mn[i] = v\n        return\n\n    push(i)\n    assign(2 * i, l, r, v)\n    assign(2 * i + 1, l, r, v)\n    pull(i)\n\ndef minimum(i, l, r):\n    if l > hi[i] or r < lo[i]:\n        return INF\n    if l <= lo[i] and hi[i] <= r:\n        return mn[i]\n\n    push(i)\n    lmin = minimum(2 * i, l, r)\n    rmin = minimum(2 * i + 1, l, r)\n    pull(i)\n\n    return min(lmin, rmin)\n\ninit(1, 1, N)\nfor _ in range(Q):\n    t, a, b = map(int, sys.stdin.readline().split())\n    if t == 1:\n        assign(1, a, a, b)\n    elif t == 2:\n        print(minimum(1, a, b))",
        "public_test_path": "/id/public/1649",
        "hidden_test_path": "/id/hidden/1649",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 2
    },
    {
        "problem_id": "rangexorqueries1650",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Range Xor Queries",
        "description": "You are given a playlist of a radio station since its establishment. The playlist has a total of n songs.\n\nWhat is the longest sequence of successive songs where each song is unique?\n\nInput\n\nThe first input line contains an integer n : the number of songs.\n\nThe next line has n integers k_1,k_2,…,k_n : the id number of each song.\n\nOutput\n\nPrint the length of the longest sequence of unique songs.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ k_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8\n1 2 1 3 2 7 4 2\n\n\nOutput:\n\n\n5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "maxN = int(2e5)\n\nN, Q = map(int, input().split())\nx = [0] * (maxN + 1)\n\nfor i in range(1, N + 1):\n    x[i] = int(input()) ^ x[i - 1]\n\nfor _ in range(Q):\n    a, b = map(int, input().split())\n    print(x[b] ^ x[a - 1])",
        "public_test_path": "/id/public/1650",
        "hidden_test_path": "/id/hidden/1650",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 2
    },
    {
        "problem_id": "rangeupdatequeries1651",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Range Update Queries",
        "description": "You are given n cubes in a certain order, and your task is to build towers using them. Whenever two cubes are one on top of the other, the upper cube must be smaller than the lower cube.\n\nYou must process the cubes in the given order. You can always either place the cube on top of an existing tower, or begin a new tower. What is the minimum possible number of towers?\n\nInput\n\nThe first input line contains an integer n : the number of cubes.\n\nThe next line contains n integers k_1,k_2,…,k_n : the sizes of the cubes.\n\nOutput\n\nPrint one integer: the minimum number of towers.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ k_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5\n3 8 2 1 5\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "maxN = 200001\n\nN, Q = map(int, input().split())\nds = [0] * maxN\n\ndef update(idx, val):\n    while idx <= N:\n        ds[idx] += val\n        idx += idx & -idx\n\ndef query(idx):\n    sum_ = 0\n    while idx > 0:\n        sum_ += ds[idx]\n        idx -= idx & -idx\n    return sum_\n\nfor i in range(1, N + 1):\n    x = int(input())\n    update(i, x)\n    update(i + 1, -x)\n\nfor _ in range(Q):\n    t = int(input())\n    if t == 1:\n        a, b, x = map(int, input().split())\n        update(b + 1, -x)\n        update(a, x)\n    elif t == 2:\n        k = int(input())\n        print(query(k))",
        "public_test_path": "/id/public/1651",
        "hidden_test_path": "/id/hidden/1651",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "subarraysumqueriesii3226",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Subarray Sum Queries II",
        "description": "There is a street of length x whose positions are numbered 0,1,…,x . Initially there are no traffic lights, but n sets of traffic lights are added to the street one after another.\n\nYour task is to calculate the length of the longest passage without traffic lights after each addition.\n\nInput\n\nThe first input line contains two integers x and n : the length of the street and the number of sets of traffic lights.\n\nThen, the next line contains n integers p_1,p_2,…,p_n : the position of each set of traffic lights. Each position is distinct.\n\nOutput\n\nPrint the length of the longest passage without traffic lights after each addition.\n\nConstraints\n\n1 ≤ x ≤ 10^9 1 ≤ n ≤ 2 · 10^5 0 < p_i < x\n\nExample\n\nInput:\n\n\n8 3\n3 6 2\n\n\nOutput:\n\n\n5 3 3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import defaultdict\n\nINF = 0x3f3f3f3f3f3f3f\nSIZE = int(8e5)\n\nN, Q = map(int, sys.stdin.readline().split())\nlo = [0] * SIZE\nhi = [0] * SIZE\nsum = [0] * SIZE\ndp = [0] * SIZE\ndpl = [0] * SIZE\ndpr = [0] * SIZE\n\ndef result_add(a, b):\n    return [\n        a[0] + b[0],\n        max(a[1], a[0] + b[1]),\n        max(b[2], b[0] + a[2]),\n        max(max(a[3], b[3]), a[2] + b[1]),\n    ]\n\ndef pull(i):\n    dpl[i] = max(dpl[2 * i], sum[2 * i] + dpl[2 * i + 1])\n    dpr[i] = max(dpr[2 * i + 1], sum[2 * i + 1] + dpr[2 * i])\n    dp[i] = max(dpr[2 * i] + dpl[2 * i + 1], max(dp[2 * i], dp[2 * i + 1]))\n    sum[i] = sum[2 * i] + sum[2 * i + 1]\n\ndef build(i, l, r):\n    lo[i] = l\n    hi[i] = r\n    if l == r:\n        sum[i] = int(sys.stdin.readline().strip())\n        dpl[i] = dpr[i] = dp[i] = sum[i]\n        return\n    m = l + (r - l) // 2\n    build(2 * i, l, m)\n    build(2 * i + 1, m + 1, r)\n    pull(i)\n\ndef query(i, l, r):\n    if lo[i] > r or hi[i] < l:\n        return [-INF, -INF, -INF, -INF]\n    if lo[i] >= l and hi[i] <= r:\n        return [sum[i], dpl[i], dpr[i], dp[i]]\n    left = query(2 * i, l, r)\n    right = query(2 * i + 1, l, r)\n    return result_add(left, right)\n\nbuild(1, 1, N)\nfor _ in range(Q):\n    l, r = map(int, sys.stdin.readline().split())\n    res = query(1, l, r)\n    print(max(res[3], 0))",
        "public_test_path": "/id/public/3226",
        "hidden_test_path": "/id/hidden/3226",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 2
    },
    {
        "problem_id": "distinctvaluesqueriesii3356",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Distinct Values Queries II",
        "description": "Given an array of n integers, count the number of subarrays where each element is dictinct.\n\nInput\n\nThe first line has an integer n : the array size.\n\nThe second line has n integers x_1,x_2,…,x_n : the array contents.\n\nOutput\n\nPrint the number of subarrays with distinct elements.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4\n1 2 1 3\n\n\nOutput:\n\n\n8\n\n\nExplanation : The subarrays are [1] (two times), [2] , [3] , [1,2] , [1,3] , [2,1] and [2,1,3] .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport sys\nimport bisect\n\ninput = sys.stdin.read\nINF = float('inf')\n\nclass SegmentTree:\n    def __init__(self, n):\n        self.lo = [0] * (4 * n)\n        self.hi = [0] * (4 * n)\n        self.mn = [INF] * (4 * n)\n        self.mx = [-INF] * (4 * n)\n        self.segtree_idx = {}\n    \n    def pull(self, i):\n        self.mn[i] = min(self.mn[2 * i], self.mn[2 * i + 1])\n        self.mx[i] = max(self.mx[2 * i], self.mx[2 * i + 1])\n    \n    def init(self, i, l, r, a, prv, nxt):\n        self.lo[i] = l\n        self.hi[i] = r\n        if l == r:\n            v = a[l]\n            self.mn[i] = INF if not nxt[v] or nxt[v][-1] <= l else nxt[v][bisect.bisect_right(nxt[v], l)]\n            self.mx[i] = -INF if not prv[v] or prv[v][0] >= l else prv[v][bisect.bisect_left(prv[v], l) - 1]\n            self.segtree_idx[l] = i\n            return\n        \n        m = (l + r) // 2\n        self.init(2 * i, l, m, a, prv, nxt)\n        self.init(2 * i + 1, m + 1, r, a, prv, nxt)\n        self.pull(i)\n\n    def assign(self, idx, _mn, _mx):\n        i = self.segtree_idx[idx]\n        if _mn != -1:\n            self.mn[i] = _mn\n        if _mx != -1:\n            self.mx[i] = _mx\n        while i > 1:\n            i //= 2\n            self.pull(i)\n\n    def query(self, i, l, r):\n        if l > self.hi[i] or r < self.lo[i]:\n            return (INF, -INF)\n        if l <= self.lo[i] and self.hi[i] <= r:\n            return (self.mn[i], self.mx[i])\n        \n        lmin = self.query(2 * i, l, r)\n        rmin = self.query(2 * i + 1, l, r)\n        \n        return (min(lmin[0], rmin[0]), max(lmin[1], rmin[1]))\n\ndef update(pos, val, a, prv, nxt, segtree):\n    old_val = a[pos]\n    old_next = INF if not nxt[old_val] or nxt[old_val][-1] <= pos else nxt[old_val][bisect.bisect_right(nxt[old_val], pos)]\n    old_prev = -INF if not prv[old_val] or prv[old_val][0] >= pos else prv[old_val][bisect.bisect_left(prv[old_val], pos) - 1]\n\n    prv[old_val].remove(pos)\n    nxt[old_val].remove(pos)\n    if old_next != INF:\n        segtree.assign(old_next, -1, old_prev)\n    if old_prev != -INF:\n        segtree.assign(old_prev, old_next, -1)\n\n    a[pos] = val\n    new_next = INF if not nxt[val] or nxt[val][-1] <= pos else nxt[val][bisect.bisect_right(nxt[val], pos)]\n    new_prev = -INF if not prv[val] or prv[val][0] >= pos else prv[val][bisect.bisect_left(prv[val], pos) - 1]\n    prv[val].add(pos)\n    nxt[val].add(pos)\n\n    segtree.assign(pos, new_next, new_prev)\n    if new_next != INF:\n        segtree.assign(new_next, -1, pos)\n    if new_prev != -INF:\n        segtree.assign(new_prev, pos, -1)\n\ndef main():\n    input_data = input().split()\n    idx = 0\n    N = int(input_data[idx])\n    Q = int(input_data[idx + 1])\n    idx += 2\n\n    a = [0] * (N + 1)\n    prv = defaultdict(set)\n    nxt = defaultdict(set)\n    \n    for i in range(1, N + 1):\n        a[i] = int(input_data[idx])\n        prv[a[i]].add(i)\n        nxt[a[i]].add(i)\n        idx += 1\n\n    segtree = SegmentTree(N)\n    segtree.init(1, 1, N, a, prv, nxt)\n\n    results = []\n    for _ in range(Q):\n        k = int(input_data[idx])\n        x = int(input_data[idx + 1])\n        y = int(input_data[idx + 2])\n        idx += 3\n        if k == 1:\n            update(x, y, a, prv, nxt, segtree)\n        else:\n            res = segtree.query(1, x, y)\n            mn_val, mx_val = res\n            results.append(\"NO\" if mn_val <= y or mx_val >= x else \"YES\")\n\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/3356",
        "hidden_test_path": "/id/hidden/3356",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 9
    },
    {
        "problem_id": "forestqueriesii1739",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Forest Queries II",
        "description": "Given an array of n integers, count the number of subsequences where each element is dictinct.\n\nA subsequence is a sequence of array elements from left to right that may have gaps.\n\nInput\n\nThe first line has an integer n : the array size.\n\nThe second line has n integers x_1,x_2,…,x_n : the array contents.\n\nOutput\n\nPrint the number of subsequences with distinct elements. The answer can be large, so print it modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4\n1 2 1 3\n\n\nOutput:\n\n\n11\n\n\nExplanation : The subsequences are [1] (two times), [2] , [3] , [1,2] , [1,3] (two times), [2,1] , [2,3] , [1,2,3] and [2,1,3] .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "maxN = 1000\n\nN, Q = map(int, input().split())\nc = [[''] * (maxN + 1) for _ in range(maxN + 1)]\nds = [[0] * (maxN + 1) for _ in range(maxN + 1)]\n\ndef update(x, y, val):\n    i = x\n    while i <= N:\n        j = y\n        while j <= N:\n            ds[i][j] += val\n            j += -j & j\n        i += -i & i\n\ndef query(x, y):\n    sum_ = 0\n    i = x\n    while i > 0:\n        j = y\n        while j > 0:\n            sum_ += ds[i][j]\n            j -= -j & j\n        i -= -i & i\n    return sum_\n\nfor i in range(1, N + 1):\n    row = input().strip()\n    for j in range(1, N + 1):\n        c[i][j] = row[j - 1]\n        if c[i][j] == '*':\n            update(i, j, 1)\n\nfor _ in range(Q):\n    t, x1, y1 = map(int, input().split())\n    if t == 1:\n        if c[x1][y1] == '*':\n            update(x1, y1, -1)\n            c[x1][y1] = '.'\n        elif c[x1][y1] == '.':\n            update(x1, y1, 1)\n            c[x1][y1] = '*'\n    elif t == 2:\n        x2, y2 = map(int, input().split())\n        result = query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1)\n        print(result)",
        "public_test_path": "/id/public/1739",
        "hidden_test_path": "/id/hidden/1739",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 5
    },
    {
        "problem_id": "rangeupdatesandsums1735",
        "topic": "Chương 1",
        "sub_topic": "Range Queries",
        "name": "Range Updates and Sums",
        "description": "Consider a game where there are n children (numbered 1,2,…,n ) in a circle. During the game, every other child is removed from the circle until there are no children left. In which order will the children be removed?\n\nInput\n\nThe only input line has an integer n .\n\nOutput\n\nPrint n integers: the removal order.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5\n\nExample\n\nInput:\n\n\n7\n\n\nOutput:\n\n\n2 4 6 1 5 3 7",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class SegmentTree:\n    def __init__(self, n):\n        self.N = n\n        self.maxN = 2 * n\n        self.lo = [0] * (4 * self.maxN)\n        self.hi = [0] * (4 * self.maxN)\n        self.del = [0] * (4 * self.maxN)\n        self.ass = [0] * (4 * self.maxN)\n        self.sum = [0] * (4 * self.maxN)\n\n    def len(self, i):\n        return self.hi[i] - self.lo[i] + 1\n\n    def increment(self, i, v):\n        self.del[i] += v\n        self.sum[i] += self.len(i) * v\n\n    def assign(self, i, v):\n        self.ass[i] = v\n        self.del[i] = 0\n        self.sum[i] = self.len(i) * v\n\n    def push(self, i):\n        if self.ass[i]:\n            self.assign(2 * i, self.ass[i])\n            self.assign(2 * i + 1, self.ass[i])\n            self.ass[i] = 0\n        if self.del[i]:\n            self.increment(2 * i, self.del[i])\n            self.increment(2 * i + 1, self.del[i])\n            self.del[i] = 0\n\n    def pull(self, i):\n        self.sum[i] = self.sum[2 * i] + self.sum[2 * i + 1]\n\n    def build(self, i, l, r):\n        self.lo[i] = l\n        self.hi[i] = r\n        if l == r:\n            self.sum[i] = int(input())\n            return\n        m = l + (r - l) // 2\n        self.build(2 * i, l, m)\n        self.build(2 * i + 1, m + 1, r)\n        self.pull(i)\n\n    def increment_range(self, i, l, r, v):\n        if l > self.hi[i] or r < self.lo[i]:\n            return\n        if l <= self.lo[i] and self.hi[i] <= r:\n            self.increment(i, v)\n            return\n\n        self.push(i)\n        self.increment_range(2 * i, l, r, v)\n        self.increment_range(2 * i + 1, l, r, v)\n        self.pull(i)\n\n    def assign_range(self, i, l, r, v):\n        if l > self.hi[i] or r < self.lo[i]:\n            return\n        if l <= self.lo[i] and self.hi[i] <= r:\n            self.assign(i, v)\n            return\n\n        self.push(i)\n        self.assign_range(2 * i, l, r, v)\n        self.assign_range(2 * i + 1, l, r, v)\n        self.pull(i)\n\n    def query(self, i, l, r):\n        if l > self.hi[i] or r < self.lo[i]:\n            return 0\n        if l <= self.lo[i] and self.hi[i] <= r:\n            return self.sum[i]\n\n        self.push(i)\n        lsum = self.query(2 * i, l, r)\n        rsum = self.query(2 * i + 1, l, r)\n        self.pull(i)\n\n        return lsum + rsum\n\n\ndef main():\n    N, Q = map(int, input().split())\n    seg_tree = SegmentTree(N)\n    seg_tree.build(1, 1, N)\n\n    for _ in range(Q):\n        t, a, b = map(int, input().split())\n        if t == 1:\n            x = int(input())\n            seg_tree.increment_range(1, a, b, x)\n        elif t == 2:\n            x = int(input())\n            seg_tree.assign_range(1, a, b, x)\n        elif t == 3:\n            print(seg_tree.query(1, a, b))\n\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1735",
        "hidden_test_path": "/id/hidden/1735",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "treedistancesi1132",
        "topic": "Chương 1",
        "sub_topic": "Tree Algorithms",
        "name": "Tree Distances I",
        "description": "Consider a game where there are n children (numbered 1,2,…,n ) in a circle. During the game, repeatedly k children are skipped and one child is removed from the circle. In which order will the children be removed?\n\nInput\n\nThe only input line has two integers n and k .\n\nOutput\n\nPrint n integers: the removal order.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 0 ≤ k ≤ 10^9\n\nExample\n\nInput:\n\n\n7 2\n\n\nOutput:\n\n\n3 6 2 7 5 1 4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\nmaxN = 200001\n\nN = 0\na = 0\nb = 0\ndown = [0] * maxN\nup = [0] * maxN\nbest = [0] * maxN\nG = defaultdict(list)\n\ndef dfs1(u=1, p=0):\n    for v in G[u]:\n        if v != p:\n            dfs1(v, u)\n            down[u] = max(down[u], down[v] + 1)\n\ndef dfs2(u=1, p=0):\n    first = 0\n    second = 0\n    for v in G[u]:\n        if v != p:\n            if down[v] >= down[first]:\n                second = first\n                first = v\n            elif down[v] > down[second]:\n                second = v\n\n    for v in G[u]:\n        if v != p:\n            up[v] = max(up[v], up[u] + 1)\n            if v == first:\n                if second != 0:\n                    up[v] = max(up[v], down[second] + 2)\n            elif first != 0:\n                up[v] = max(up[v], down[first] + 2)\n            dfs2(v, u)\n\n    best[u] = max(up[u], down[u])\n\ndata = input().split()\nN = int(data[0])\nindex = 1\nfor _ in range(N - 1):\n    a = int(data[index])\n    b = int(data[index + 1])\n    G[a].append(b)\n    G[b].append(a)\n    index += 2\n\ndfs1()\ndfs2()\n\nprint(' '.join(str(best[i]) for i in range(1, N + 1)))",
        "public_test_path": "/id/public/1132",
        "hidden_test_path": "/id/hidden/1132",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "treedistancesii1133",
        "topic": "Chương 1",
        "sub_topic": "Tree Algorithms",
        "name": "Tree Distances II",
        "description": "Given n ranges, your task is to determine for each range if it contains some other range and if some other range contains it.\n\nRange [a,b] contains range [c,d] if a ≤ c and d ≤ b .\n\nInput\n\nThe first input line has an integer n : the number of ranges.\n\nAfter this, there are n lines that describe the ranges. Each line has two integers x and y : the range is [x,y] .\n\nYou may assume that no range appears more than once in the input.\n\nOutput\n\nFirst print a line that describes for each range (in the input order) if it contains some other range (1) or not (0).\n\nThen print a line that describes for each range (in the input order) if some other range contains it (1) or not (0).\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x < y ≤ 10^9\n\nExample\n\nInput:\n\n\n4\n1 6\n2 4\n4 8\n3 6\n\n\nOutput:\n\n\n1 0 0 0\n0 1 0 1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN = int(data[0])\nG = defaultdict(list)\nsz = [0] * (N + 1)\ndown = [0] * (N + 1)\nup = [0] * (N + 1)\n\nfor i in range(1, N):\n    a, b = map(int, data[i].split())\n    G[a].append(b)\n    G[b].append(a)\n\ndef dfs1(u=1, p=0):\n    sz[u] = 1\n    for v in G[u]:\n        if v != p:\n            dfs1(v, u)\n            sz[u] += sz[v]\n            down[u] += down[v] + sz[v]\n\ndef dfs2(u=1, p=0):\n    if p != 0:\n        up[u] = (up[p] + down[p]) + N - (2 * sz[u] + down[u])\n    for v in G[u]:\n        if v != p:\n            dfs2(v, u)\n\ndfs1()\ndfs2()\n\nprint(' '.join(str(down[i] + up[i]) for i in range(1, N + 1)))",
        "public_test_path": "/id/public/1133",
        "hidden_test_path": "/id/hidden/1133",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "companyqueriesi1687",
        "topic": "Chương 1",
        "sub_topic": "Tree Algorithms",
        "name": "Company Queries I",
        "description": "Given n ranges, your task is to count for each range how many other ranges it contains and how many other ranges contain it.\n\nRange [a,b] contains range [c,d] if a ≤ c and d ≤ b .\n\nInput\n\nThe first input line has an integer n : the number of ranges.\n\nAfter this, there are n lines that describe the ranges. Each line has two integers x and y : the range is [x,y] .\n\nYou may assume that no range appears more than once in the input.\n\nOutput\n\nFirst print a line that describes for each range (in the input order) how many other ranges it contains.\n\nThen print a line that describes for each range (in the input order) how many other ranges contain it.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x < y ≤ 10^9\n\nExample\n\nInput:\n\n\n4\n1 6\n2 4\n4 8\n3 6\n\n\nOutput:\n\n\n2 0 0 0\n0 1 0 1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "maxN = int(2e5 + 1)\nlogK = 20\n\nN, Q = map(int, input().split())\np = [[0] * logK for _ in range(maxN)]\n\nfor i in range(2, N + 1):\n    p[i][0] = int(input())\n\nfor j in range(1, logK):\n    for i in range(1, N + 1):\n        p[i][j] = p[p[i][j - 1]][j - 1]\n\nfor _ in range(Q):\n    x, k = map(int, input().split())\n    for i in range(logK):\n        if k & (1 << i):\n            x = p[x][i]\n    print(x if x else -1)",
        "public_test_path": "/id/public/1687",
        "hidden_test_path": "/id/hidden/1687",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "companyqueriesii1688",
        "topic": "Chương 1",
        "sub_topic": "Tree Algorithms",
        "name": "Company Queries II",
        "description": "There is a large hotel, and n customers will arrive soon. Each customer wants to have a single room.\n\nYou know each customer's arrival and departure day. Two customers can stay in the same room if the departure day of the first customer is earlier than the arrival day of the second customer.\n\nWhat is the minimum number of rooms that are needed to accommodate all customers? And how can the rooms be allocated?\n\nInput\n\nThe first input line contains an integer n : the number of customers.\n\nThen there are n lines, each of which describes one customer. Each line has two integers a and b : the arrival and departure day.\n\nOutput\n\nPrint first an integer k : the minimum number of rooms required.\n\nAfter that, print a line that contains the room number of each customer in the same order as in the input. The rooms are numbered 1,2,…,k . You can print any valid solution.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ a ≤ b ≤ 10^9\n\nExample\n\nInput:\n\n\n3\n1 2\n2 4\n4 4\n\n\nOutput:\n\n\n2\n1 2 1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom collections import defaultdict\n\nsys_input = sys.stdin.read\ndata = sys_input().split()\nindex = 0\n\nmaxN = 200001\nlogN = 20\n\nN, Q = int(data[index]), int(data[index + 1])\nindex += 2\n\nG = defaultdict(list)\np = [[0] * logN for _ in range(maxN)]\ntimer = 0\nin_time = [0] * maxN\nout_time = [0] * maxN\n\ndef dfs(u=1, par=1):\n    global timer\n    in_time[u] = timer = timer + 1\n    p[u][0] = par\n    for i in range(1, logN):\n        p[u][i] = p[p[u][i - 1]][i - 1]\n    for v in G[u]:\n        if v != par:\n            dfs(v, u)\n    out_time[u] = timer = timer + 1\n\ndef ancestor(u, v):\n    return in_time[u] <= in_time[v] and out_time[u] >= out_time[v]\n\ndef lca(u, v):\n    if ancestor(u, v):\n        return u\n    if ancestor(v, u):\n        return v\n    for i in range(logN - 1, -1, -1):\n        if not ancestor(p[u][i], v):\n            u = p[u][i]\n    return p[u][0]\n\nfor i in range(2, N + 1):\n    e = int(data[index])\n    index += 1\n    G[e].append(i)\n    G[i].append(e)\n\ndfs()\n\noutput = []\nfor _ in range(Q):\n    a = int(data[index])\n    b = int(data[index + 1])\n    index += 2\n    output.append(str(lca(a, b)))\n\nprint(\"\\n\".join(output))",
        "public_test_path": "/id/public/1688",
        "hidden_test_path": "/id/hidden/1688",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "pathqueriesii2134",
        "topic": "Chương 1",
        "sub_topic": "Tree Algorithms",
        "name": "Path Queries II",
        "description": "A factory has n machines which can be used to make products. Your goal is to make a total of t products.\n\nFor each machine, you know the number of seconds it needs to make a single product. The machines can work simultaneously, and you can freely decide their schedule.\n\nWhat is the shortest time needed to make t products?\n\nInput\n\nThe first input line has two integers n and t : the number of machines and products.\n\nThe next line has n integers k_1,k_2,…,k_n : the time needed to make a product using each machine.\n\nOutput\n\nPrint one integer: the minimum time needed to make t products.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ t ≤ 10^9 1 ≤ k_i ≤ 10^9\n\nExample\n\nInput:\n\n\n3 7\n3 2 5\n\n\nOutput:\n\n\n8\n\n\nExplanation: Machine 1 makes two products, machine 2 makes four products and machine 3 makes one product.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Lazy:\n    def __init__(self):\n        self.a = 1\n        self.b = 0\n\n    def empty(self):\n        return self.a == 1 and self.b == 0\n\n\nclass Node:\n    idcounter = 0\n\n    def __init__(self, v):\n        Node.idcounter += 1\n        self.id = Node.idcounter\n        self.tag = Lazy()\n        self.rev = False\n        self.c = [None, None]\n        self.p = None\n        self.sz = 1\n        self.val = self.sum = self.mn = self.mx = v\n\n    def apply(self, other):\n        self.mn = self.mn * other.a + other.b\n        self.mx = self.mx * other.a + other.b\n        self.val = self.val * other.a + other.b\n        self.sum = self.sum * other.a + self.sz * other.b\n        self.tag = Lazy()\n        self.tag.a = self.tag.a * other.a\n        self.tag.b = self.tag.b * other.a + other.b\n\n    def push(self):\n        if self.rev:\n            self.c[0], self.c[1] = self.c[1], self.c[0]\n            if self.c[0]: self.c[0].rev ^= True\n            if self.c[1]: self.c[1].rev ^= True\n            self.rev = False\n        if not self.tag.empty():\n            if self.c[0]: self.c[0].apply(self.tag)\n            if self.c[1]: self.c[1].apply(self.tag)\n            self.tag = Lazy()\n\n    def pull(self):\n        self.sum = self.mn = self.mx = self.val\n        self.sz = 1\n        for i in range(2):\n            if self.c[i]:\n                self.mn = min(self.mn, self.c[i].mn)\n                self.mx = max(self.mx, self.c[i].mx)\n                self.sum += self.c[i].sum\n                self.sz += self.c[i].sz\n\n\nmaxN = int(2e5 + 1)\nLCT = [None] * maxN\nN, Q, root = 0, 0, 0\n\n\ndef not_root(t):\n    return t.p and (t.p.c[0] == t or t.p.c[1] == t)\n\n\ndef rotate(t):\n    p = t.p\n    b = (p.c[0] == t)\n    if (t.p := p.p) and not_root(p):\n        t.p.c[(t.p.c[1] == p)] = t\n    if (p.c[not b] := t.c[b]):\n        p.c[not b].p = p\n    t.c[b] = p\n    p.p = t\n    p.pull()\n\n\ndef splay(t):\n    while not_root(t):\n        p = t.p\n        p.push()\n        t.push()\n        rotate(t)\n    t.push()\n    t.pull()\n\n\ndef access(t):\n    last = None\n    for u in iter_nodes(t):\n        splay(u)\n        u.c[1] = last\n        last = u\n    splay(t)\n    return last\n\n\ndef evert(t):\n    access(t)\n    t.rev = True\n\n\ndef link(u, v):\n    evert(u)\n    u.p = v\n\n\ndef cut(u, v):\n    evert(u)\n    access(v)\n    if v.c[0]: v.c[0].p = None\n    v.c[0] = None\n    v.pull()\n\n\ndef path(u, v):\n    evert(u)\n    access(v)\n    return v\n\n\ndef LCA(u, v):\n    evert(LCT[root])\n    access(u)\n    return access(v)\n\n\ndef connected(u, v):\n    path(u, v)\n    while v.c[0]:\n        v = v.c[0]\n    return u == v\n\n\ndef iter_nodes(t):\n    while t:\n        yield t\n        t = t.p\n\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    Q = int(data[idx + 1])\n    idx += 2\n    \n    for i in range(1, N + 1):\n        x = int(data[idx])\n        LCT[i] = Node(x)\n        idx += 1\n    \n    for _ in range(N - 1):\n        x = int(data[idx])\n        y = int(data[idx + 1])\n        link(LCT[x], LCT[y])\n        idx += 2\n\n    root = 1\n    output = []\n    for _ in range(Q):\n        k = int(data[idx])\n        idx += 1\n        if k == 1:\n            x = int(data[idx])\n            y = int(data[idx + 1])\n            p = path(LCT[x], LCT[x])\n            p.apply(Lazy())\n            p.tag.b = y\n            idx += 2\n        elif k == 2:\n            x = int(data[idx])\n            y = int(data[idx + 1])\n            p = path(LCT[x], LCT[y])\n            output.append(str(p.mx))\n            idx += 2\n\n    print(\" \".join(output))",
        "public_test_path": "/id/public/2134",
        "hidden_test_path": "/id/hidden/2134",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "findingacentroid2079",
        "topic": "Chương 1",
        "sub_topic": "Tree Algorithms",
        "name": "Finding a Centroid",
        "description": "You have to process n tasks. Each task has a duration and a deadline, and you will process the tasks in some order one after another. Your reward for a task is d-f where d is its deadline and f is your finishing time. (The starting time is 0 , and you have to process all tasks even if a task would yield negative reward.)\n\nWhat is your maximum reward if you act optimally?\n\nInput\n\nThe first input line has an integer n : the number of tasks.\n\nAfter this, there are n lines that describe the tasks. Each line has two integers a and d : the duration and deadline of the task.\n\nOutput\n\nPrint one integer: the maximum reward.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ a,d ≤ 10^6\n\nExample\n\nInput:\n\n\n3\n6 10\n8 15\n5 12\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "maxN = int(2e5 + 5)\n\nN = int(input())\na, b = 0, 0\np = [0] * maxN\nsz = [0] * maxN\nG = [[] for _ in range(maxN)]\n\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    G[a].append(b)\n    G[b].append(a)\n\ndef dfs(u=1):\n    sz[u] = 1\n    for v in G[u]:\n        if v != p[u]:\n            p[v] = u\n            dfs(v)\n            sz[u] += sz[v]\n\ndfs()\n\nfor i in range(1, N + 1):\n    centroid = True\n\n    if p[i] != 0 and N - sz[i] > N / 2:\n        centroid = False\n\n    for v in G[i]:\n        if v != p[i] and sz[v] > N / 2:\n            centroid = False\n\n    if centroid:\n        print(i)\n        break",
        "public_test_path": "/id/public/2079",
        "hidden_test_path": "/id/hidden/2079",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "exponentiationii1712",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Exponentiation II",
        "description": "There are n books, and Kotivalo and Justiina are going to read them all. For each book, you know the time it takes to read it.\n\nThey both read each book from beginning to end, and they cannot read a book at the same time. What is the minimum total time required?\n\nInput\n\nThe first input line has an integer n : the number of books.\n\nThe second line has n integers t_1,t_2,…,t_n : the time required to read each book.\n\nOutput\n\nPrint one integer: the minimum total time.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ t_i ≤ 10^9\n\nExample\n\nInput:\n\n\n3\n2 8 3\n\n\nOutput:\n\n\n16",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = int(1e9 + 7)\n\ndef fastpow(a, b, mod):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = (res * a) % mod\n        a = (a * a) % mod\n        b >>= 1\n    return res\n\nN = int(input())\nfor _ in range(N):\n    A, B, C = map(int, input().split())\n    print(fastpow(A, fastpow(B, C, MOD - 1), MOD))",
        "public_test_path": "/id/public/1712",
        "hidden_test_path": "/id/hidden/1712",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "creatingstringsii1715",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Creating Strings II",
        "description": "You are given an array of n integers, and your task is to find three values (at distinct positions) whose sum is x .\n\nInput\n\nThe first input line has two integers n and x : the array size and the target sum.\n\nThe second line has n integers a_1,a_2,…,a_n : the array values.\n\nOutput\n\nPrint three integers: the positions of the values. If there are several solutions, you may print any of them. If there are no solutions, print IMPOSSIBLE .\n\nConstraints\n\n1 ≤ n ≤ 5000 1 ≤ x,a_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4 8\n2 7 5 1\n\n\nOutput:\n\n\n1 3 4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = int(1e9 + 7)\nmaxN = int(1e6 + 5)\n\nN = 0\nfreq = [0] * 26\nfact = [0] * maxN\ninv = [0] * maxN\n\ndef inverse(x):\n    res = 1\n    expo = MOD - 2\n    while expo > 0:\n        if expo & 1:\n            res = (res * x) % MOD\n        x = (x * x) % MOD\n        expo >>= 1\n    return res\n\ndef init():\n    global fact, inv\n    fact[0] = inv[0] = 1\n    for i in range(1, maxN):\n        fact[i] = i * fact[i - 1] % MOD\n        inv[i] = inverse(fact[i])\n\nS = input().strip()\nN = len(S)\ninit()\n\nfor i in range(N):\n    freq[ord(S[i]) - ord('a')] += 1\n\nans = fact[N]\nfor i in range(26):\n    ans = ans * inv[freq[i]] % MOD\n\nprint(ans)",
        "public_test_path": "/id/public/1715",
        "hidden_test_path": "/id/hidden/1715",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "bracketsequencesi2064",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Bracket Sequences I",
        "description": "You are given an array of n integers, and your task is to find four values (at distinct positions) whose sum is x .\n\nInput\n\nThe first input line has two integers n and x : the array size and the target sum.\n\nThe second line has n integers a_1,a_2,…,a_n : the array values.\n\nOutput\n\nPrint four integers: the positions of the values. If there are several solutions, you may print any of them. If there are no solutions, print IMPOSSIBLE .\n\nConstraints\n\n1 ≤ n ≤ 1000 1 ≤ x,a_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8 15\n3 2 5 8 1 3 2 3\n\n\nOutput:\n\n\n2 4 6 7",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = int(1e9 + 7)\n\ndef fastpow(a, b):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = (res * a) % MOD\n        a = (a * a) % MOD\n        b >>= 1\n    return res\n\ndef inverse(a):\n    return fastpow(a, MOD - 2)\n\nN = int(input())\nif N & 1:\n    print(0)\nelse:\n    numerator = 1\n    for i in range(1, N + 1):\n        numerator = (numerator * i) % MOD\n\n    denominator = 1\n    for i in range(1, N // 2 + 1):\n        denominator = (denominator * i) % MOD\n    denominator = (denominator * denominator) % MOD\n    denominator = (denominator * (N // 2 + 1)) % MOD\n\n    print((numerator * inverse(denominator)) % MOD)",
        "public_test_path": "/id/public/2064",
        "hidden_test_path": "/id/hidden/2064",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 17
    },
    {
        "problem_id": "bracketsequencesii2187",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Bracket Sequences II",
        "description": "Given an array of n integers, your task is to find for each array position the nearest position to its left having a smaller value.\n\nInput\n\nThe first input line has an integer n : the size of the array.\n\nThe second line has n integers x_1,x_2,…,x_n : the array values.\n\nOutput\n\nPrint n integers: for each array position the nearest position with a smaller value. If there is no such position, print 0 .\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8\n2 5 1 4 8 3 2 5\n\n\nOutput:\n\n\n0 1 0 3 4 3 3 7",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = int(1e9 + 7)\nmaxN = int(1e6 + 5)\n\nfact = [0] * maxN\ninv = [0] * maxN\n\ndef inverse(x):\n    res = 1\n    b = MOD - 2\n    while b:\n        if b & 1:\n            res = (res * x) % MOD\n        x = (x * x) % MOD\n        b >>= 1\n    return res\n\ndef choose(x, y):\n    return (fact[x] * inv[y] % MOD) * inv[x - y] % MOD\n\ndef init(N):\n    fact[0] = inv[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n        inv[i] = (inv[i - 1] * inverse(i)) % MOD\n\nN, S = input().split()\nN = int(N)\nM = len(S)\ninit(N)\n\nopen_count = 0\nclosed_count = 0\nfor i in range(M):\n    if S[i] == '(':\n        open_count += 1\n    elif S[i] == ')':\n        closed_count += 1\n\n    if closed_count > open_count:\n        print(0)\n        exit()\n\nif N % 2 != 0 or open_count > N // 2:\n    print(0)\n    exit()\n\ntot = choose(N - open_count - closed_count, N // 2 - open_count)\nbad = choose(N - open_count - closed_count, N // 2 - open_count - 1)\nprint((tot - bad) % MOD)",
        "public_test_path": "/id/public/2187",
        "hidden_test_path": "/id/hidden/2187",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "graphpathsi1723",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Graph Paths I",
        "description": "Given an array of n positive integers, your task is to count the number of subarrays having sum x .\n\nInput\n\nThe first input line has two integers n and x : the size of the array and the target sum x .\n\nThe next line has n integers a_1,a_2,…,a_n : the contents of the array.\n\nOutput\n\nPrint one integer: the required number of subarrays.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x,a_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5 7\n2 4 1 2 7\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\nMOD = int(1e9 + 7)\nmaxN = 100\n\nN, M, K = map(int, sys.stdin.readline().split())\nX = [[0] * maxN for _ in range(maxN)]\nY = [[0] * maxN for _ in range(maxN)]\n\nfor _ in range(M):\n    a, b = map(int, sys.stdin.readline().split())\n    X[a - 1][b - 1] += 1\n\nfor i in range(N):\n    Y[i][i] = 1\n\ndef mult(A, B):\n    C = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            for k in range(N):\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD\n    for i in range(N):\n        for j in range(N):\n            A[i][j] = C[i][j]\n\nwhile K:\n    if K & 1:\n        mult(Y, X)\n    mult(X, X)\n    K >>= 1\n\nprint(Y[0][N - 1])",
        "public_test_path": "/id/public/1723",
        "hidden_test_path": "/id/hidden/1723",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 14
    },
    {
        "problem_id": "graphpathsii1724",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Graph Paths II",
        "description": "Given an array of n integers, your task is to count the number of subarrays having sum x .\n\nInput\n\nThe first input line has two integers n and x : the size of the array and the target sum x .\n\nThe next line has n integers a_1,a_2,…,a_n : the contents of the array.\n\nOutput\n\nPrint one integer: the required number of subarrays.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 -10^9 ≤ x,a_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5 7\n2 -1 3 5 -2\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport numpy as np\n\nmaxN = 100\nINF = 10**19\n\nN, M, K = map(int, sys.stdin.readline().split())\nX = np.full((maxN, maxN), INF, dtype=np.uint64)\nY = np.full((maxN, maxN), INF, dtype=np.uint64)\n\nfor i in range(N):\n    Y[i][i] = 0\n\nfor _ in range(M):\n    a, b, c = map(int, sys.stdin.readline().split())\n    X[a-1][b-1] = min(X[a-1][b-1], c)\n\ndef combine(A, B):\n    C = np.full((maxN, maxN), INF, dtype=np.uint64)\n    for i in range(N):\n        for j in range(N):\n            for k in range(N):\n                if A[i][k] != INF and B[k][j] != INF:\n                    C[i][j] = min(C[i][j], A[i][k] + B[k][j])\n    for i in range(N):\n        for j in range(N):\n            A[i][j] = C[i][j]\n\nwhile K:\n    if K & 1:\n        combine(Y, X)\n    combine(X, X)\n    K >>= 1\n\nif Y[0][N-1] == INF:\n    print(\"-1\")\nelse:\n    print(Y[0][N-1])",
        "public_test_path": "/id/public/1724",
        "hidden_test_path": "/id/hidden/1724",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 15
    },
    {
        "problem_id": "nimgamei1730",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Nim Game I",
        "description": "Given an array of n integers, your task is to count the number of subarrays where the sum of values is divisible by n .\n\nInput\n\nThe first input line has an integer n : the size of the array.\n\nThe next line has n integers a_1,a_2,…,a_n : the contents of the array.\n\nOutput\n\nPrint one integer: the required number of subarrays.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 -10^9 ≤ a_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5\n3 1 2 7 4\n\n\nOutput:\n\n\n1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    xum = 0\n    for _ in range(N):\n        x = int(input())\n        xum ^= x\n    print(\"first\" if xum else \"second\")",
        "public_test_path": "/id/public/1730",
        "hidden_test_path": "/id/hidden/1730",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "nimgameii1098",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Nim Game II",
        "description": "Given an array of n integers, your task is to calculate the number of subarrays that have at most k distinct values.\n\nInput\n\nThe first input line has two integers n and k .\n\nThe next line has n integers x_1,x_2,…,x_n : the contents of the array.\n\nOutput\n\nPrint one integer: the number of subarrays.\n\nConstraints\n\n1 ≤ k ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5 2\n1 2 3 1 1\n\n\nOutput:\n\n\n10",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    xum = 0\n    for _ in range(N):\n        x = int(input())\n        xum ^= (x % 4)\n    print(\"first\" if xum else \"second\")",
        "public_test_path": "/id/public/1098",
        "hidden_test_path": "/id/hidden/1098",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "grundysgame2207",
        "topic": "Chương 1",
        "sub_topic": "Mathematics",
        "name": "Grundy's Game",
        "description": "You are given an array containing n positive integers.\n\nYour task is to divide the array into k subarrays so that the maximum sum in a subarray is as small as possible.\n\nInput\n\nThe first input line contains two integers n and k : the size of the array and the number of subarrays in the division.\n\nThe next line contains n integers x_1,x_2,…,x_n : the contents of the array.\n\nOutput\n\nPrint one integer: the maximum sum in a subarray in the optimal division.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ k ≤ n 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n5 3\n2 4 7 3 5\n\n\nOutput:\n\n\n8\n\n\nExplanation: An optimal division is [2,4],[7],[3,5] where the sums of the subarrays are 6,7,8 . The largest sum is the last sum 8 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "maxN = int(1e6) + 1\n\nlose = [0, 1, 2, 4, 7, 10, 20, 23, 26, 50, 53, 270, 273, 276, 282, 285, 288, 316, 334, 337, 340, 346, 359, 362, 365, 386, 389, 392, 566, 630, 633, 636, 639, 673, 676, 682, 685, 923, 926, 929, 932, 1222]\nb = [False] * maxN\n\ndef init():\n    for x in lose:\n        b[x] = True\n\ndef main():\n    init()\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        print(\"second\" if b[N] else \"first\")\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2207",
        "hidden_test_path": "/id/hidden/2207",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 3
    },
    {
        "problem_id": "minimalrotation1110",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "Minimal Rotation",
        "description": "In a movie festival, n movies will be shown. Syrjälä's movie club consists of k members, who will be all attending the festival.\n\nYou know the starting and ending time of each movie. What is the maximum total number of movies the club members can watch entirely if they act optimally?\n\nInput\n\nThe first input line has two integers n and k : the number of movies and club members.\n\nAfter this, there are n lines that describe the movies. Each line has two integers a and b : the starting and ending time of a movie.\n\nOutput\n\nPrint one integer: the maximum total number of movies.\n\nConstraints\n\n1 ≤ k ≤ n ≤ 2 · 10^5 1 ≤ a < b ≤ 10^9\n\nExample\n\nInput:\n\n\n5 2\n1 5\n8 10\n3 6\n2 5\n6 9\n\n\nOutput:\n\n\n4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "maxN = 2000005\n\nN = 0\nF = [-1] * maxN\nS = input().strip()\n\nN = len(S)\nS += S\n\nN = len(S)\nF = [-1] * N\n\nk = 0\nfor i in range(1, N):\n    c = S[i]\n    f = F[i - k - 1]\n    while f != -1 and c != S[k + f + 1]:\n        if c < S[k + f + 1]:\n            k = i - f - 1\n        f = F[f]\n\n    if c != S[k + f + 1]:\n        if c < S[k]:\n            k = i\n        F[i - k] = -1\n    else:\n        F[i - k] = f + 1\n\nfor i in range(N // 2):\n    print(S[i + k], end='')",
        "public_test_path": "/id/public/1110",
        "hidden_test_path": "/id/hidden/1110",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 23
    },
    {
        "problem_id": "distinctsubsequences1149",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "Distinct Subsequences",
        "description": "Given an array of n integers, your task is to find the maximum sum of values in a contiguous subarray with length between a and b .\n\nInput\n\nThe first input line has three integers n , a and b : the size of the array and the minimum and maximum subarray length.\n\nThe second line has n integers x_1,x_2,…,x_n : the array values.\n\nOutput\n\nPrint one integer: the maximum subarray sum.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ a ≤ b ≤ n -10^9 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8 1 2\n-1 3 -2 5 3 -5 2 2\n\n\nOutput:\n\n\n8",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = int(1e9 + 7)\n\nS = input().strip()\nN = len(S)\ndp = [0] * 26\ntot = 0\n\nfor i in range(N):\n    c = ord(S[i]) - ord('a')\n    dp[c] += 1\n    for j in range(26):\n        if j != c:\n            dp[c] = (dp[c] + dp[j]) % MOD\n\nfor i in range(26):\n    tot = (tot + dp[i]) % MOD\n\nprint(tot)",
        "public_test_path": "/id/public/1149",
        "hidden_test_path": "/id/hidden/1149",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "substringorderi2108",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "Substring Order I",
        "description": "Your task is to count the number of ways to construct sum n by throwing a dice one or more times. Each throw produces an outcome between 1 and 6 .\n\nFor example, if n=3 , there are 4 ways:\n\n1+1+1 1+2 2+1 3\n\nInput\n\nThe only input line has an integer n .\n\nOutput\n\nPrint the number of ways modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\n3\n\n\nOutput:\n\n\n4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\n\nclass Node:\n    def __init__(self):\n        self.dp = 0\n        self.len = 0\n        self.link = -1\n        self.nxt = {}\n\nmaxN = int(1e5 + 5)\nnode = [Node() for _ in range(2 * maxN)]\nans = []\nS = \"\"\nN = 0\nsz = 1\nlast = 0\nK = 0\n\ndef init():\n    global sz, last\n    node[0].len = 0\n    node[0].link = -1\n    sz = 1\n    last = 0\n\ndef extend(c):\n    global sz, last\n    cur = sz\n    sz += 1\n    node[cur].len = node[last].len + 1\n    p = last\n    while p != -1 and c not in node[p].nxt:\n        node[p].nxt[c] = cur\n        p = node[p].link\n    if p == -1:\n        node[cur].link = 0\n    else:\n        q = node[p].nxt[c]\n        if node[p].len + 1 == node[q].len:\n            node[cur].link = q\n        else:\n            clone = sz\n            sz += 1\n            node[clone].len = node[p].len + 1\n            node[clone].nxt = node[q].nxt.copy()\n            node[clone].link = node[q].link\n            while p != -1 and node[p].nxt.get(c) == q:\n                node[p].nxt[c] = clone\n                p = node[p].link\n            node[q].link = node[cur].link = clone\n    last = cur\n\ndef calc(u=0):\n    node[u].dp = 1\n    for c, v in node[u].nxt.items():\n        if node[v].dp == 0:\n            calc(v)\n        node[u].dp += node[v].dp\n\ndef dfs(u, k):\n    if k < 0:\n        return\n    for c, v in node[u].nxt.items():\n        if node[v].dp <= k:\n            k -= node[v].dp\n        else:\n            ans.append(c)\n            dfs(v, k - 1)\n            return\n\nif __name__ == \"__main__\":\n    S, K = input().split()\n    K = int(K)\n    N = len(S)\n\n    init()\n    for i in range(N):\n        extend(S[i])\n    calc()\n\n    dfs(0, K - 1)\n    print(''.join(ans))",
        "public_test_path": "/id/public/2108",
        "hidden_test_path": "/id/hidden/2108",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 11
    },
    {
        "problem_id": "substringorderii2109",
        "topic": "Chương 1",
        "sub_topic": "String Algorithms",
        "name": "Substring Order II",
        "description": "Consider a money system consisting of n coins. Each coin has a positive integer value. Your task is to produce a sum of money x using the available coins in such a way that the number of coins is minimal.\n\nFor example, if the coins are \\{1,5,7\\} and the desired sum is 11 , an optimal solution is 5+5+1 which requires 3 coins.\n\nInput\n\nThe first input line has two integers n and x : the number of coins and the desired sum of money.\n\nThe second line has n distinct integers c_1,c_2,…,c_n : the value of each coin.\n\nOutput\n\nPrint one integer: the minimum number of coins. If it is not possible to produce the desired sum, print -1 .\n\nConstraints\n\n1 ≤ n ≤ 100 1 ≤ x ≤ 10^6 1 ≤ c_i ≤ 10^6\n\nExample\n\nInput:\n\n\n3 11\n1 5 7\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\n\nclass Node:\n    def __init__(self):\n        self.dp = 0\n        self.len = 0\n        self.cnt = 0\n        self.link = -1\n        self.nxt = {}\n\nmaxN = int(1e5 + 5)\nnode = [Node() for _ in range(2 * maxN)]\nans = []\nS = \"\"\nN = 0\nsz = 1\nlast = 0\nK = 0\n\ndef init():\n    global sz, last\n    node[0].len = 0\n    node[0].link = -1\n    sz = 1\n    last = 0\n\ndef extend(c):\n    global sz, last\n    cur = sz\n    sz += 1\n    node[cur].cnt = 1\n    node[cur].len = node[last].len + 1\n    p = last\n    while p != -1 and c not in node[p].nxt:\n        node[p].nxt[c] = cur\n        p = node[p].link\n    if p == -1:\n        node[cur].link = 0\n    else:\n        q = node[p].nxt[c]\n        if node[p].len + 1 == node[q].len:\n            node[cur].link = q\n        else:\n            clone = sz\n            sz += 1\n            node[clone].len = node[p].len + 1\n            node[clone].nxt = node[q].nxt.copy()\n            node[clone].link = node[q].link\n            while p != -1 and node[p].nxt[c] == q:\n                node[p].nxt[c] = clone\n                p = node[p].link\n            node[q].link = node[cur].link = clone\n    last = cur\n\ndef update_cnts():\n    states_by_len = [[] for _ in range(sz)]\n    for i in range(sz):\n        states_by_len[node[i].len].append(i)\n    for i in range(sz - 1, -1, -1):\n        for u in states_by_len[i]:\n            if node[u].link != -1:\n                node[node[u].link].cnt += node[u].cnt\n\ndef calc(u=0):\n    node[u].dp = node[u].cnt\n    for c, v in node[u].nxt.items():\n        if node[v].dp == 0:\n            calc(v)\n        node[u].dp += node[v].dp\n\ndef dfs(u, k):\n    if k < 0:\n        return\n    for c, v in node[u].nxt.items():\n        if node[v].dp <= k:\n            k -= node[v].dp\n        else:\n            ans.append(c)\n            dfs(v, k - node[v].cnt)\n            return\n\nif __name__ == \"__main__\":\n    S, K = input().split()\n    K = int(K)\n    N = len(S)\n\n    init()\n    for i in range(N):\n        extend(S[i])\n    update_cnts()\n    calc()\n\n    dfs(0, K - 1)\n    print(''.join(ans))",
        "public_test_path": "/id/public/2109",
        "hidden_test_path": "/id/hidden/2109",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 9
    },
    {
        "problem_id": "maximummanhattandistances3410",
        "topic": "Chương 1",
        "sub_topic": "Geometry",
        "name": "Maximum Manhattan Distances",
        "description": "Consider a money system consisting of n coins. Each coin has a positive integer value. Your task is to calculate the number of distinct ways you can produce a money sum x using the available coins.\n\nFor example, if the coins are \\{2,3,5\\} and the desired sum is 9 , there are 8 ways:\n\n2+2+5 2+5+2 5+2+2 3+3+3 2+2+2+3 2+2+3+2 2+3+2+2 3+2+2+2\n\nInput\n\nThe first input line has two integers n and x : the number of coins and the desired sum of money.\n\nThe second line has n distinct integers c_1,c_2,…,c_n : the value of each coin.\n\nOutput\n\nPrint one integer: the number of ways modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 100 1 ≤ x ≤ 10^6 1 ≤ c_i ≤ 10^6\n\nExample\n\nInput:\n\n\n3 9\n2 3 5\n\n\nOutput:\n\n\n8",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\n\nINF = 0x3f3f3f3f3f3f3f3f\n\nN = int(sys.stdin.readline().strip())\n\nl1 = l4 = -INF\nl2 = l3 = INF\n\nfor _ in range(N):\n    x, y = map(int, sys.stdin.readline().strip().split())\n\n    l1 = max(l1, x + y)\n    l2 = min(l2, x + y)\n    l3 = min(l3, x - y)\n    l4 = max(l4, x - y)\n\n    print(max(l1 - l2, l4 - l3))",
        "public_test_path": "/id/public/3410",
        "hidden_test_path": "/id/hidden/3410",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 2
    },
    {
        "problem_id": "linesegmentstracei3427",
        "topic": "Chương 1",
        "sub_topic": "Geometry",
        "name": "Line Segments Trace I",
        "description": "Consider a money system consisting of n coins. Each coin has a positive integer value. Your task is to calculate the number of distinct ordered ways you can produce a money sum x using the available coins.\n\nFor example, if the coins are \\{2,3,5\\} and the desired sum is 9 , there are 3 ways:\n\n2+2+5 3+3+3 2+2+2+3\n\nInput\n\nThe first input line has two integers n and x : the number of coins and the desired sum of money.\n\nThe second line has n distinct integers c_1,c_2,…,c_n : the value of each coin.\n\nOutput\n\nPrint one integer: the number of ways modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 100 1 ≤ x ≤ 10^6 1 ≤ c_i ≤ 10^6\n\nExample\n\nInput:\n\n\n3 9\n2 3 5\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Line:\n    def __init__(self, a=0, b=float('-inf')):\n        self.a = a\n        self.b = b\n\n    def get(self, x):\n        return self.a * x + self.b\n\n\nclass Node:\n    def __init__(self):\n        self.line = Line()\n        self.lc = None\n        self.rc = None\n\n\nclass LiChaoTree:\n    def __init__(self, size):\n        self.root = None\n        self.size = size\n\n    def contained_insert(self, node, tl, tr, line):\n        if node is None:\n            node = Node()\n        if node.line.get(tl) < line.get(tl):\n            node.line, line = line, node.line\n        if node.line.get(tr) >= line.get(tr):\n            return\n        if tl == tr:\n            return\n\n        tm = (tl + tr) // 2\n        if node.line.get(tm) > line.get(tm):\n            self.contained_insert(node.rc, tm + 1, tr, line)\n        else:\n            node.line, line = line, node.line\n            self.contained_insert(node.lc, tl, tm, line)\n\n    def insert(self, node, tl, tr, l, r, line):\n        if tr < l or r < tl or tl > tr or l > r:\n            return\n        if node is None:\n            node = Node()\n        if l <= tl and tr <= r:\n            return self.contained_insert(node, tl, tr, line)\n\n        tm = (tl + tr) // 2\n        self.insert(node.lc, tl, tm, l, r, line)\n        self.insert(node.rc, tm + 1, tr, l, r, line)\n\n    def query(self, node, tl, tr, x):\n        if node is None:\n            return float('-inf')\n        if tl == tr:\n            return node.line.get(x)\n\n        res = node.line.get(x)\n        tm = (tl + tr) // 2\n        if x <= tm:\n            res = max(res, self.query(node.lc, tl, tm, x))\n        else:\n            res = max(res, self.query(node.rc, tm + 1, tr, x))\n\n        return res\n\n    def insert_line(self, l, r, line):\n        self.insert(self.root, 0, self.size - 1, l, r, line)\n\n    def query_x(self, x):\n        return self.query(self.root, 0, self.size - 1, x)\n\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    tree = LiChaoTree(M + 1)\n\n    for _ in range(N):\n        y1, y2 = map(int, input().split())\n        m = (y2 - y1) // M\n        tree.insert_line(0, M, Line(m, y1))\n\n    for x in range(M + 1):\n        res = tree.query_x(x)\n        print(-1 if res == float('-inf') else res, end=(' ' if x < M else '\\n'))",
        "public_test_path": "/id/public/3427",
        "hidden_test_path": "/id/hidden/3427",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "linesegmentstraceii3428",
        "topic": "Chương 1",
        "sub_topic": "Geometry",
        "name": "Line Segments Trace II",
        "description": "You are given an integer n . On each step, you may subtract one of the digits from the number.\n\nHow many steps are required to make the number equal to 0 ?\n\nInput\n\nThe only input line has an integer n .\n\nOutput\n\nPrint one integer: the minimum number of steps.\n\nConstraints\n\n1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\n27\n\n\nOutput:\n\n\n5\n\n\nExplanation: An optimal solution is 27 → 20 → 18 → 10 → 9 → 0 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Line:\n    def __init__(self, a=0, b=float('-inf')):\n        self.a = a\n        self.b = b\n\n    def get(self, x):\n        return self.a * x + self.b\n\n\nclass Node:\n    def __init__(self):\n        self.line = Line()\n        self.lc = None\n        self.rc = None\n\n\nclass LiChaoTree:\n    def __init__(self, size):\n        self.root = None\n        self.size = size\n\n    def contained_insert(self, node, tl, tr, line):\n        if node is None:\n            node = Node()\n        if node.line.get(tl) < line.get(tl):\n            node.line, line = line, node.line\n        if node.line.get(tr) >= line.get(tr):\n            return\n        if tl == tr:\n            return\n\n        tm = (tl + tr) // 2\n        if node.line.get(tm) > line.get(tm):\n            self.contained_insert(node.rc, tm + 1, tr, line)\n        else:\n            node.line, line = line, node.line\n            self.contained_insert(node.lc, tl, tm, line)\n\n    def insert(self, node, tl, tr, l, r, line):\n        if tr < l or r < tl or tl > tr or l > r:\n            return\n        if node is None:\n            node = Node()\n        if l <= tl and tr <= r:\n            return self.contained_insert(node, tl, tr, line)\n\n        tm = (tl + tr) // 2\n        self.insert(node.lc, tl, tm, l, r, line)\n        self.insert(node.rc, tm + 1, tr, l, r, line)\n\n    def query(self, node, tl, tr, x):\n        if node is None:\n            return float('-inf')\n        if tl == tr:\n            return node.line.get(x)\n\n        res = node.line.get(x)\n        tm = (tl + tr) // 2\n        if x <= tm:\n            res = max(res, self.query(node.lc, tl, tm, x))\n        else:\n            res = max(res, self.query(node.rc, tm + 1, tr, x))\n\n        return res\n\n    def insert_line(self, l, r, line):\n        self.insert(self.root, 0, self.size - 1, l, r, line)\n\n    def query_x(self, x):\n        return self.query(self.root, 0, self.size - 1, x)\n\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    tree = LiChaoTree(M + 1)\n\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        m = (y2 - y1) // (x2 - x1)\n        b = y1 - m * x1\n        tree.insert_line(x1, x2, Line(m, b))\n\n    for x in range(M + 1):\n        res = tree.query_x(x)\n        print(-1 if res == float('-inf') else res, end=(' ' if x < M else '\\n'))",
        "public_test_path": "/id/public/3428",
        "hidden_test_path": "/id/hidden/3428",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "linesandqueriesi3429",
        "topic": "Chương 1",
        "sub_topic": "Geometry",
        "name": "Lines and Queries I",
        "description": "Consider an n × n grid whose squares may have traps. It is not allowed to move to a square with a trap.\n\nYour task is to calculate the number of paths from the upper-left square to the lower-right square. You can only move right or down.\n\nInput\n\nThe first input line has an integer n : the size of the grid.\n\nAfter this, there are n lines that describe the grid. Each line has n characters: . denotes an empty cell, and * denotes a trap.\n\nOutput\n\nPrint the number of paths modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 1000\n\nExample\n\nInput:\n\n\n4\n....\n.*..\n...*\n*...\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Line:\n    def __init__(self, a=0, b=float('-inf')):\n        self.a = a\n        self.b = b\n\n    def get(self, x):\n        return self.a * x + self.b\n\n\nclass Node:\n    def __init__(self):\n        self.line = Line()\n        self.lc = None\n        self.rc = None\n\n\nclass LiChaoTree:\n    def __init__(self, size):\n        self.root = None\n        self.size = size\n\n    def contained_insert(self, node, tl, tr, line):\n        if node is None:\n            node = Node()\n        if node.line.get(tl) < line.get(tl):\n            node.line, line = line, node.line\n        if node.line.get(tr) >= line.get(tr):\n            return\n        if tl == tr:\n            return\n\n        tm = (tl + tr) // 2\n        if node.line.get(tm) > line.get(tm):\n            self.contained_insert(node.rc, tm + 1, tr, line)\n        else:\n            node.line, line = line, node.line\n            self.contained_insert(node.lc, tl, tm, line)\n\n    def insert(self, node, tl, tr, l, r, line):\n        if tr < l or r < tl or tl > tr or l > r:\n            return\n        if node is None:\n            node = Node()\n        if l <= tl and tr <= r:\n            return self.contained_insert(node, tl, tr, line)\n\n        tm = (tl + tr) // 2\n        self.insert(node.lc, tl, tm, l, r, line)\n        self.insert(node.rc, tm + 1, tr, l, r, line)\n\n    def query(self, node, tl, tr, x):\n        if node is None:\n            return float('-inf')\n        if tl == tr:\n            return node.line.get(x)\n\n        res = node.line.get(x)\n        tm = (tl + tr) // 2\n        if x <= tm:\n            res = max(res, self.query(node.lc, tl, tm, x))\n        else:\n            res = max(res, self.query(node.rc, tm + 1, tr, x))\n\n        return res\n\n    def insert_line(self, l, r, line):\n        self.insert(self.root, 0, self.size - 1, l, r, line)\n\n    def query_x(self, x):\n        return self.query(self.root, 0, self.size - 1, x)\n\n\nif __name__ == \"__main__\":\n    maxX = int(1e5) + 5\n    tree = LiChaoTree(maxX + 1)\n\n    T = int(input())\n    for _ in range(T):\n        type_query = int(input())\n        if type_query == 1:\n            a, b = map(int, input().split())\n            tree.insert_line(0, maxX, Line(a, b))\n        elif type_query == 2:\n            x = int(input())\n            res = tree.query_x(x)\n            if res == float('-inf'):\n                print(\"NO\")\n            else:\n                print(res)",
        "public_test_path": "/id/public/3429",
        "hidden_test_path": "/id/hidden/3429",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "linesandqueriesii3430",
        "topic": "Chương 1",
        "sub_topic": "Geometry",
        "name": "Lines and Queries II",
        "description": "You are in a book shop which sells n different books. You know the price and number of pages of each book.\n\nYou have decided that the total price of your purchases will be at most x . What is the maximum number of pages you can buy? You can buy each book at most once.\n\nInput\n\nThe first input line contains two integers n and x : the number of books and the maximum total price.\n\nThe next line contains n integers h_1,h_2,…,h_n : the price of each book.\n\nThe last line contains n integers s_1,s_2,…,s_n : the number of pages of each book.\n\nOutput\n\nPrint one integer: the maximum number of pages.\n\nConstraints\n\n1 ≤ n ≤ 1000 1 ≤ x ≤ 10^5 1 ≤ h_i, s_i ≤ 1000\n\nExample\n\nInput:\n\n\n4 10\n4 8 5 3\n5 12 8 1\n\n\nOutput:\n\n\n13\n\n\nExplanation: You can buy books 1 and 3. Their price is 4+5=9 and the number of pages is 5+8=13 .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Line:\n    def __init__(self, a=0, b=float('-inf')):\n        self.a = a\n        self.b = b\n\n    def get(self, x):\n        return self.a * x + self.b\n\n\nclass Node:\n    def __init__(self):\n        self.line = Line()\n        self.lc = None\n        self.rc = None\n\n\nclass LiChaoTree:\n    def __init__(self, size):\n        self.root = None\n        self.size = size\n\n    def contained_insert(self, node, tl, tr, line):\n        if node is None:\n            node = Node()\n        if node.line.get(tl) < line.get(tl):\n            node.line, line = line, node.line\n        if node.line.get(tr) >= line.get(tr):\n            return\n        if tl == tr:\n            return\n\n        tm = (tl + tr) // 2\n        if node.line.get(tm) > line.get(tm):\n            self.contained_insert(node.rc, tm + 1, tr, line)\n        else:\n            node.line, line = line, node.line\n            self.contained_insert(node.lc, tl, tm, line)\n\n    def insert(self, node, tl, tr, l, r, line):\n        if tr < l or r < tl or tl > tr or l > r:\n            return\n        if node is None:\n            node = Node()\n        if l <= tl and tr <= r:\n            return self.contained_insert(node, tl, tr, line)\n\n        tm = (tl + tr) // 2\n        self.insert(node.lc, tl, tm, l, r, line)\n        self.insert(node.rc, tm + 1, tr, l, r, line)\n\n    def query(self, node, tl, tr, x):\n        if node is None:\n            return float('-inf')\n        if tl == tr:\n            return node.line.get(x)\n\n        res = node.line.get(x)\n        tm = (tl + tr) // 2\n        if x <= tm:\n            res = max(res, self.query(node.lc, tl, tm, x))\n        else:\n            res = max(res, self.query(node.rc, tm + 1, tr, x))\n\n        return res\n\n    def insert_line(self, l, r, line):\n        self.insert(self.root, 0, self.size - 1, l, r, line)\n\n    def query_x(self, x):\n        return self.query(self.root, 0, self.size - 1, x)\n\n\nif __name__ == \"__main__\":\n    maxX = int(1e5 + 5)\n    tree = LiChaoTree(maxX)\n\n    T = int(input())\n    for _ in range(T):\n        type_query = int(input())\n        if type_query == 1:\n            a, b, l, r = map(int, input().split())\n            tree.insert_line(l, r, Line(a, b))\n        elif type_query == 2:\n            x = int(input())\n            res = tree.query_x(x)\n            if res == float('-inf'):\n                print(\"NO\")\n            else:\n                print(res)",
        "public_test_path": "/id/public/3430",
        "hidden_test_path": "/id/hidden/3430",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "cornersubgridcount2137",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Corner Subgrid Count",
        "description": "You know that an array has n integers between 1 and m , and the absolute difference between two adjacent values is at most 1 .\n\nGiven a description of the array where some values may be unknown, your task is to count the number of arrays that match the description.\n\nInput\n\nThe first input line has two integers n and m : the array size and the upper bound for each value.\n\nThe next line has n integers x_1,x_2,…,x_n : the contents of the array. Value 0 denotes an unknown value.\n\nOutput\n\nPrint one integer: the number of arrays modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 100 0 ≤ x_i ≤ m\n\nExample\n\nInput:\n\n\n3 5\n2 0 2\n\n\nOutput:\n\n\n3\n\n\nExplanation: The arrays [2,1,2] , [2,2,2] and [2,3,2] match the description.",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from sys import stdin, stdout\n\ndef f(X):\n    return X * (X - 1)\n\nN = int(stdin.readline().strip())\nB = [0] * N\n\nfor i in range(N):\n    B[i] = int(stdin.readline().strip(), 2)\n\nans = 0\n\nfor i in range(N):\n    for j in range(i + 1, N):\n        ans += f(bin(B[i] & B[j]).count('1'))\n\nstdout.write(str(ans >> 1) + '\\n')",
        "public_test_path": "/id/public/2137",
        "hidden_test_path": "/id/hidden/2137",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "euleriansubgraphs2078",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Eulerian Subgraphs",
        "description": "Your task is to build a tower whose width is 2 and height is n . You have an unlimited supply of blocks whose width and height are integers.\n\nFor example, here are some possible solutions for n=6 : Given n , how many different towers can you build? Mirrored and rotated towers are counted separately if they look different.\n\nInput\n\nThe first input line contains an integer t : the number of tests.\n\nAfter this, there are t lines, and each line contains an integer n : the height of the tower.\n\nOutput\n\nFor each test, print the number of towers modulo 10^9+7 .\n\nConstraints\n\n1 ≤ t ≤ 100 1 ≤ n ≤ 10^6\n\nExample\n\nInput:\n\n\n3\n2\n6\n1337\n\n\nOutput:\n\n\n8\n2864\n640403945",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "maxN = int(1e5 + 1)\nMOD = int(1e9 + 7)\n\nN, M = map(int, input().split())\nds = [-1] * (maxN)\nans = 1\n\ndef find(u):\n    if ds[u] < 0:\n        return u\n    ds[u] = find(ds[u])\n    return ds[u]\n\ndef merge(u, v):\n    u = find(u)\n    v = find(v)\n    if u == v:\n        return False\n    if ds[u] < ds[v]:\n        u, v = v, u\n    ds[v] += ds[u]\n    ds[u] = v\n    return True\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    if not merge(a, b):\n        ans = (2 * ans) % MOD\n\nprint(ans)",
        "public_test_path": "/id/public/2078",
        "hidden_test_path": "/id/hidden/2078",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "monstergamei2084",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Monster Game I",
        "description": "The edit distance between two strings is the minimum number of operations required to transform one string into the other.\n\nThe allowed operations are:\n\nAdd one character to the string. Remove one character from the string. Replace one character in the string.\n\nFor example, the edit distance between LOVE and MOVIE is 2, because you can first replace L with M, and then add I.\n\nYour task is to calculate the edit distance between two strings.\n\nInput\n\nThe first input line has a string that contains n characters between A–Z.\n\nThe second input line has a string that contains m characters between A–Z.\n\nOutput\n\nPrint one integer: the edit distance between the strings.\n\nConstraints\n\n1 ≤ n,m ≤ 5000\n\nExample\n\nInput:\n\n\nLOVE\nMOVIE\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Line:\n    def __init__(self, m, b):\n        self.m = m\n        self.b = b\n\n    def __call__(self, x):\n        return self.m * x + self.b\n\nSIZE = 4000000\nINF = 0x3f3f3f3f3f3f3f3f\n\nseg = [Line(0, INF) for _ in range(SIZE)]\nlo = [0] * SIZE\nhi = [0] * SIZE\n\ndef build(i, l, r):\n    lo[i] = l\n    hi[i] = r\n    if l == r:\n        return\n    m = (l + r) // 2\n    build(2 * i, l, m)\n    build(2 * i + 1, m + 1, r)\n\ndef insert(i, L):\n    l = lo[i]\n    r = hi[i]\n    if l == r:\n        if L(l) < seg[i](l):\n            seg[i] = L\n        return\n\n    m = (l + r) // 2\n    if seg[i].m < L.m:\n        seg[i], L = L, seg[i]\n    if seg[i](m) > L(m):\n        seg[i], L = L, seg[i]\n        insert(2 * i, L)\n    else:\n        insert(2 * i + 1, L)\n\ndef query(i, x):\n    l = lo[i]\n    r = hi[i]\n    if l == r:\n        return seg[i](x)\n\n    m = (l + r) // 2\n    if x < m:\n        return min(seg[i](x), query(2 * i, x))\n    else:\n        return min(seg[i](x), query(2 * i + 1, x))\n\nN, X = map(int, input().split())\ns = list(map(int, input().split()))\nf = list(map(int, input().split()))\n\nbuild(1, 1, 1000000)\ninsert(1, Line(X, 0))\nfor i in range(N - 1):\n    best = query(1, s[i])\n    insert(1, Line(f[i], best))\n\nprint(query(1, s[N - 1]))",
        "public_test_path": "/id/public/2084",
        "hidden_test_path": "/id/hidden/2084",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 5
    },
    {
        "problem_id": "monstergameii2085",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Monster Game II",
        "description": "Given two arrays of integers, find their longest common subsequence.\n\nA subsequence is a sequence of array elements from left to right that can contain gaps. A common subsequence is a subsequence that appears in both arrays.\n\nInput\n\nThe first line has two integers n and m : the sizes of the arrays.\n\nThe second line has n integers a_1,a_2,…,a_n : the contents of the first array.\n\nThe third line has m integers b_1,b_2,…,b_m : the contents of the second array.\n\nOutput\n\nFirst print the length of the longest common subsequence.\n\nAfter that, print an example of such a sequence. If there are several solutions, you can print any of them.\n\nConstraints\n\n1 ≤ n,m ≤ 1000 1 ≤ a_i, b_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8 6\n3 1 3 2 7 4 8 2\n6 5 1 2 3 4\n\n\nOutput:\n\n\n3\n1 2 4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Line:\n    def __init__(self, m, b):\n        self.m = m\n        self.b = b\n\n    def __call__(self, x):\n        return self.m * x + self.b\n\nSIZE = 4000000\nmaxN = 200001\nINF = 0x3f3f3f3f3f3f3f3f\n\nseg = [Line(0, INF) for _ in range(SIZE)]\nlo = [0] * SIZE\nhi = [0] * SIZE\ns = [0] * maxN\nf = [0] * maxN\n\ndef build(i, l, r):\n    lo[i] = l\n    hi[i] = r\n    seg[i] = Line(0, INF)\n    if l == r:\n        return\n    m = (l + r) // 2\n    build(2 * i, l, m)\n    build(2 * i + 1, m + 1, r)\n\ndef insert(i, L):\n    l = lo[i]\n    r = hi[i]\n    if l == r:\n        if L(l) < seg[i](l):\n            seg[i] = L\n        return\n\n    m = (l + r) // 2\n    if seg[i].m < L.m:\n        seg[i], L = L, seg[i]\n    if seg[i](m) > L(m):\n        seg[i], L = L, seg[i]\n        insert(2 * i, L)\n    else:\n        insert(2 * i + 1, L)\n\ndef query(i, x):\n    l = lo[i]\n    r = hi[i]\n    if l == r:\n        return seg[i](x)\n\n    m = (l + r) // 2\n    if x < m:\n        return min(seg[i](x), query(2 * i, x))\n    else:\n        return min(seg[i](x), query(2 * i + 1, x))\n\nN, X = map(int, input().split())\nfor i in range(N):\n    s[i] = int(input())\nfor i in range(N):\n    f[i] = int(input())\n\nbuild(1, 1, 1000000)\ninsert(1, Line(X, 0))\nfor i in range(N - 1):\n    best = query(1, s[i])\n    insert(1, Line(f[i], best))\nprint(query(1, s[N - 1]))",
        "public_test_path": "/id/public/2085",
        "hidden_test_path": "/id/hidden/2085",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 9
    },
    {
        "problem_id": "newroadsqueries2101",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "New Roads Queries",
        "description": "Given an a × b rectangle, your task is to cut it into squares. On each move you can select a rectangle and cut it into two rectangles in such a way that all side lengths remain integers. What is the minimum possible number of moves?\n\nInput\n\nThe only input line has two integers a and b .\n\nOutput\n\nPrint one integer: the minimum number of moves.\n\nConstraints\n\n1 ≤ a,b ≤ 500\n\nExample\n\nInput:\n\n\n3 5\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "class Node:\n    idcounter = 0\n\n    def __init__(self, v):\n        self.rev = False\n        self.c = [None, None]\n        self.p = None\n        self.val = v\n        self.mx = v\n        Node.idcounter += 1\n        self.id = Node.idcounter\n\n    def push(self):\n        if self.rev:\n            self.c[0], self.c[1] = self.c[1], self.c[0]\n            if self.c[0]: self.c[0].rev ^= True\n            if self.c[1]: self.c[1].rev ^= True\n            self.rev = False\n\n    def pull(self):\n        self.mx = self.val\n        for child in self.c:\n            if child:\n                self.mx = max(self.mx, child.mx)\n\nmaxN = int(4e5 + 1)\nLCT = [None] * maxN\n\ndef not_root(t):\n    return t.p and (t.p.c[0] == t or t.p.c[1] == t)\n\ndef rotate(t):\n    p = t.p\n    b = (p.c[0] == t)\n    if (t.p := p.p) and not_root(p):\n        t.p.c[1 if t.p.c[1] == p else 0] = t\n    if (p.c[not b] := t.c[b]):\n        p.c[not b].p = p\n    t.c[b] = p\n    p.p = t\n    p.pull()\n\ndef splay(t):\n    while not_root(t):\n        p = t.p\n        p.push()\n        t.push()\n        rotate(t)\n    t.push()\n    t.pull()\n\ndef access(t):\n    last = None\n    for u in iter_nodes(t):\n        splay(u)\n        u.c[1] = last\n        last = u\n    splay(t)\n    return last\n\ndef evert(t):\n    access(t)\n    t.rev = True\n\ndef link(u, v):\n    evert(u)\n    u.p = v\n\ndef cut(u, v):\n    evert(u)\n    access(v)\n    if v.c[0]: v.c[0].p = None\n    v.c[0] = None\n    v.pull()\n\ndef path(u, v):\n    evert(u)\n    access(v)\n    return v\n\ndef LCA(u, v):\n    evert(LCT[root])\n    access(u)\n    return access(v)\n\ndef connected(u, v):\n    p = path(u, v)\n    while p.c[0]:\n        p = p.c[0]\n    return u == p\n\ndef iter_nodes(t):\n    while t:\n        yield t\n        t = t.p\n\nN, M, Q = map(int, input().split())\nfor i in range(1, N + 1):\n    LCT[i] = Node(0)\nfor i in range(1, M + 1):\n    x, y = map(int, input().split())\n    LCT[N + i] = Node(i)\n    if not connected(LCT[x], LCT[y]):\n        link(LCT[x], LCT[N + i])\n        link(LCT[y], LCT[N + i])\n\nroot = 1\nfor _ in range(Q):\n    x, y = map(int, input().split())\n    if connected(LCT[x], LCT[y]):\n        p = path(LCT[x], LCT[y])\n        print(p.mx)\n    else:\n        print(-1)",
        "public_test_path": "/id/public/2101",
        "hidden_test_path": "/id/hidden/2101",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "distinctroutesii2130",
        "topic": "Chương 1",
        "sub_topic": "Advanced Techniques",
        "name": "Distinct Routes II",
        "description": "You are given an n × n grid whose each square contains a letter.\n\nYou should move from the upper-left square to the lower-right square. You can only move right or down.\n\nWhat is the lexicographically minimal string you can construct?\n\nInput\n\nThe first line has an integer n : the size of the grid.\n\nAfter this, there are n lines that describe the grid. Each line has n letters between A and Z .\n\nOutput\n\nPrint the lexicographically minimal string.\n\nConstraints\n\n1 ≤ n ≤ 3000\n\nExample\n\nInput:\n\n\n4\nAACA\nBABC\nABDA\nAACA\n\n\nOutput:\n\n\nAAABACA",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import deque\n\nmaxN = 501\nmaxM = 1001\nINF = float('inf')\n\nN, M, K = map(int, input().split())\np = [0] * maxN\nd = [INF] * maxN\ninq = [False] * maxN\nvis = [False] * maxM\npath = []\nG = [[] for _ in range(maxN)]\n\nclass Edge:\n    def __init__(self, u, v, r, c):\n        self.u = u\n        self.v = v\n        self.r = r\n        self.c = c\n\nedges = [None] * maxM\nredges = [None] * maxM\n\ndef bellman_ford():\n    global d, p, inq\n    inq[1] = False\n    d[1] = 0\n    inq[1] = True\n    Q = deque([1])\n    \n    while Q:\n        u = Q.popleft()\n        inq[u] = False\n\n        for i in G[u]:\n            e = redges[-i] if i < 0 else edges[i]\n            if e.r > 0 and d[e.v] > d[u] + e.c:\n                d[e.v] = d[u] + e.c\n                p[e.v] = i\n                if not inq[e.v]:\n                    inq[e.v] = True\n                    Q.append(e.v)\n\ndef minimum_cost_flow():\n    flow = 0\n    cost = 0\n    while flow < K:\n        bellman_ford()\n        if d[N] == INF:\n            break\n\n        aug = K - flow\n        u = N\n        while u != 1:\n            e = redges[-p[u]] if p[u] < 0 else edges[p[u]]\n            aug = min(aug, e.r)\n            u = e.u\n\n        flow += aug\n        cost += aug * d[N]\n        u = N\n        while u != 1:\n            if p[u] < 0:\n                redges[-p[u]].r -= aug\n                edges[-p[u]].r += aug\n            else:\n                redges[p[u]].r += aug\n                edges[p[u]].r -= aug\n            u = redges[-p[u]].u if p[u] < 0 else edges[p[u]].u\n\n    return -1 if flow < K else cost\n\ndef dfs(u=1):\n    path.append(u)\n    if u == N:\n        return\n    for i in G[u]:\n        if i > 0 and edges[i].r == 0 and not vis[i]:\n            vis[i] = True\n            dfs(edges[i].v)\n            return\n\nfor i in range(1, M + 1):\n    u, v = map(int, input().split())\n    G[u].append(i)\n    G[v].append(-i)\n    edges[i] = Edge(u, v, 1, 1)\n    redges[i] = Edge(v, u, 0, -1)\n\nminCoins = minimum_cost_flow()\nif minCoins == -1:\n    print(\"-1\")\nelse:\n    print(minCoins)\n    for _ in range(K):\n        path.clear()\n        dfs()\n        sz = len(path)\n        print(sz)\n        print(\" \".join(map(str, path)))",
        "public_test_path": "/id/public/2130",
        "hidden_test_path": "/id/hidden/2130",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "slidingwindowdistinctvalues3222",
        "topic": "Chương 1",
        "sub_topic": "Sliding Window Problems",
        "name": "Sliding Window Distinct Values",
        "description": "You have n coins with certain values. Your task is to find all money sums you can create using these coins.\n\nInput\n\nThe first input line has an integer n : the number of coins.\n\nThe next line has n integers x_1,x_2,…,x_n : the values of the coins.\n\nOutput\n\nFirst print an integer k : the number of distinct money sums. After this, print all possible sums in increasing order.\n\nConstraints\n\n1 ≤ n ≤ 100 1 ≤ x_i ≤ 1000\n\nExample\n\nInput:\n\n\n4\n4 2 5 2\n\n\nOutput:\n\n\n9\n2 4 5 6 7 8 9 11 13",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nx = list(map(int, data[2:N+2]))\n\nfreq = defaultdict(int)\ndistinct = 0\n\nfor i in range(K):\n    if freq[x[i]] == 0:\n        distinct += 1\n    freq[x[i]] += 1\n\nprint(distinct, end=' ' if N != K else '\\n')\n\nfor i in range(K, N):\n    if freq[x[i - K]] == 1:\n        distinct -= 1\n    freq[x[i - K]] -= 1\n\n    if freq[x[i]] == 0:\n        distinct += 1\n    freq[x[i]] += 1\n\n    print(distinct, end=' ' if i != N - 1 else '\\n')",
        "public_test_path": "/id/public/3222",
        "hidden_test_path": "/id/hidden/3222",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 4
    },
    {
        "problem_id": "slidingwindowmedian1076",
        "topic": "Chương 1",
        "sub_topic": "Sliding Window Problems",
        "name": "Sliding Window Median",
        "description": "There is a list of n numbers and two players who move alternately. On each move, a player removes either the first or last number from the list, and their score increases by that number. Both players try to maximize their scores.\n\nWhat is the maximum possible score for the first player when both players play optimally?\n\nInput\n\nThe first input line contains an integer n : the size of the list.\n\nThe next line has n integers x_1,x_2,…,x_n : the contents of the list.\n\nOutput\n\nPrint the maximum possible score for the first player.\n\nConstraints\n\n1 ≤ n ≤ 5000 -10^9 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4\n4 5 1 3\n\n\nOutput:\n\n\n8",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from sortedcontainers import SortedList\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nx = list(map(int, data[2:N+2]))\n\nT = SortedList()\n\nfor i in range(K):\n    T.add((x[i], i))\n\nprint(T[(K-1)//2][0], end=' ' if N == K else '\\n')\n\nfor i in range(K, N):\n    T.add((x[i], i))\n    T.remove((x[i-K], i-K))\n    print(T[(K-1)//2][0], end=' ' if i < N-1 else '\\n')",
        "public_test_path": "/id/public/1076",
        "hidden_test_path": "/id/hidden/1076",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 40
    },
    {
        "problem_id": "slidingwindowcost1077",
        "topic": "Chương 1",
        "sub_topic": "Sliding Window Problems",
        "name": "Sliding Window Cost",
        "description": "Your task is to count the number of ways numbers 1,2,…,n can be divided into two sets of equal sum.\n\nFor example, if n=7 , there are four solutions:\n\n\\{1,3,4,6\\} and \\{2,5,7\\} \\{1,2,5,6\\} and \\{3,4,7\\} \\{1,2,4,7\\} and \\{3,5,6\\} \\{1,6,7\\} and \\{2,3,4,5\\}\n\nInput\n\nThe only input line contains an integer n .\n\nOutput\n\nPrint the answer modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 500\n\nExample\n\nInput:\n\n\n7\n\n\nOutput:\n\n\n4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nfrom sortedcontainers import SortedList\n\nmaxN = int(2e5 + 1)\n\nN, K = map(int, sys.stdin.readline().split())\nx = [0] * maxN\nlosum, hisum = 0, 0\nlo = SortedList()\nhi = SortedList()\n\ndef cost():\n    median = lo[-1]\n    locost = (median * len(lo)) - losum\n    hicost = hisum - (median * len(hi))\n    return locost + hicost\n\ndef lowToHigh():\n    global losum, hisum\n    val = lo[-1]\n    lo.remove(val)\n    hi.add(val)\n    losum -= val\n    hisum += val\n\ndef highToLow():\n    global losum, hisum\n    val = hi[0]\n    lo.add(val)\n    hi.remove(val)\n    losum += val\n    hisum -= val\n\ndef adjust():\n    tot = len(lo) + len(hi)\n    if len(lo) < (tot + 1) // 2:\n        highToLow()\n    elif len(lo) > (tot + 1) // 2:\n        lowToHigh()\n\ndef erase(val):\n    global losum, hisum\n    median = lo[-1]\n    if val > median:\n        hi.remove(val)\n        hisum -= val\n    else:\n        lo.remove(val)\n        losum -= val\n    adjust()\n\ndef insert(val):\n    global losum, hisum\n    if len(lo) == 0:\n        lo.add(val)\n        losum += val\n        return\n\n    median = lo[-1]\n    if val > median:\n        hi.add(val)\n        hisum += val\n    else:\n        lo.add(val)\n        losum += val\n    adjust()\n\nfor i in range(K):\n    x[i] = int(sys.stdin.readline().strip())\n    insert(x[i])\n\nprint(cost(), end=' ' if K == N else '\\n')\nfor i in range(K, N):\n    x[i] = int(sys.stdin.readline().strip())\n    insert(x[i])\n    erase(x[i - K])\n    print(cost(), end=' ' if i < N - 1 else '\\n')",
        "public_test_path": "/id/public/1077",
        "hidden_test_path": "/id/hidden/1077",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 34
    },
    {
        "problem_id": "maximumxorsubset3191",
        "topic": "Chương 1",
        "sub_topic": "Bitwise Operations",
        "name": "Maximum Xor Subset",
        "description": "There are n mountains in a row, each with a specific height. You begin your hang gliding route from some mountain.\n\nYou can glide from mountain a to mountain b if mountain a is taller than mountain b and all mountains between a and b .\n\nWhat is the maximum number of mountains you can visit on your route?\n\nInput\n\nThe first line has an integer n : the number of mountains.\n\nThe next line has n integers h_1, h_2,…, h_n : the heights of the mountains.\n\nOutput:\n\nPrint one integer: the maximum number of mountains.\n\nConstraints\n\n1≤ n ≤ 2 · 10^5 1≤ h_i ≤ 10^9\n\nExample\n\nInput:\n\n\n10\n20 15 17 35 25 40 12 19 13 12\n\n\nOutput:\n\n\n5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "logX = 32\n\nN = int(input())\nbasis = [0] * logX\n\ndef insert_vector(mask):\n    for i in range(logX - 1, -1, -1):\n        if (mask & (1 << i)) == 0:\n            continue\n        if basis[i] == 0:\n            basis[i] = mask\n            return\n        mask ^= basis[i]\n\nfor _ in range(N):\n    x = int(input())\n    insert_vector(x)\n\nans = 0\nfor i in range(logX - 1, -1, -1):\n    if basis[i] == 0:\n        continue\n    if (ans & (1 << i)) != 0:\n        continue\n    ans ^= basis[i]\n\nprint(ans)",
        "public_test_path": "/id/public/3191",
        "hidden_test_path": "/id/hidden/3191",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 9
    },
    {
        "problem_id": "numberofsubsetxors3211",
        "topic": "Chương 1",
        "sub_topic": "Bitwise Operations",
        "name": "Number of Subset Xors",
        "description": "You are given an array containing n integers. Your task is to determine the longest increasing subsequence in the array, i.e., the longest subsequence where every element is larger than the previous one.\n\nA subsequence is a sequence that can be derived from the array by deleting some elements without changing the order of the remaining elements.\n\nInput\n\nThe first line contains an integer n : the size of the array.\n\nAfter this there are n integers x_1,x_2,…,x_n : the contents of the array.\n\nOutput\n\nPrint the length of the longest increasing subsequence.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n8\n7 3 5 3 6 2 9 8\n\n\nOutput:\n\n\n4",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "logX = 32\n\nN = int(input())\nbasis = [0] * logX\n\ndef insert_vector(mask):\n    for i in range(logX - 1, -1, -1):\n        if (mask & (1 << i)) == 0:\n            continue\n        if basis[i] == 0:\n            basis[i] = mask\n            return True\n        mask ^= basis[i]\n    return False\n\nans = 1\nfor _ in range(N):\n    x = int(input())\n    if insert_vector(x):\n        ans *= 2\n\nprint(ans)",
        "public_test_path": "/id/public/3211",
        "hidden_test_path": "/id/hidden/3211",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "xorpyramidpeak2419",
        "topic": "Chương 1",
        "sub_topic": "Bitwise Operations",
        "name": "Xor Pyramid Peak",
        "description": "There are n projects you can attend. For each project, you know its starting and ending days and the amount of money you would get as reward. You can only attend one project during a day.\n\nWhat is the maximum amount of money you can earn?\n\nInput\n\nThe first input line contains an integer n : the number of projects.\n\nAfter this, there are n lines. Each such line has three integers a_i , b_i , and p_i : the starting day, the ending day, and the reward.\n\nOutput\n\nPrint one integer: the maximum amount of money you can earn.\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ a_i ≤ b_i ≤ 10^9 1 ≤ p_i ≤ 10^9\n\nExample\n\nInput:\n\n\n4\n2 4 4\n3 6 6\n6 8 2\n5 7 3\n\n\nOutput:\n\n\n7",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "def two_divisibility(x):\n    res = 0\n    while x:\n        x >>= 1\n        res += x\n    return res\n\nN = int(input())\nD = two_divisibility(N - 1)\nxum = 0\n\nfor i in range(N):\n    a = int(input())\n    d1 = two_divisibility(i)\n    d2 = two_divisibility(N - i - 1)\n    if D - d1 - d2 == 0:\n        xum ^= a\n\nprint(xum)",
        "public_test_path": "/id/public/2419",
        "hidden_test_path": "/id/hidden/2419",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "xorpyramiddiagonal3194",
        "topic": "Chương 1",
        "sub_topic": "Bitwise Operations",
        "name": "Xor Pyramid Diagonal",
        "description": "There are n people who want to get to the top of a building which has only one elevator. You know the weight of each person and the maximum allowed weight in the elevator. What is the minimum number of elevator rides?\n\nInput\n\nThe first input line has two integers n and x : the number of people and the maximum allowed weight in the elevator.\n\nThe second line has n integers w_1,w_2,…,w_n : the weight of each person.\n\nOutput\n\nPrint one integer: the minimum number of rides.\n\nConstraints\n\n1 ≤ n ≤ 20 1 ≤ x ≤ 10^9 1 ≤ w_i ≤ x\n\nExample\n\nInput:\n\n\n4 10\n4 8 6 1\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "N = int(input())\na = list(map(int, input().split()))\n\nfor i in range(N):\n    ans = a[0]\n    subset = i\n    while subset > 0:\n        ans ^= a[subset]\n        subset = (subset - 1) & i\n    print(ans, end=\" \" if i < N - 1 else \"\\n\")",
        "public_test_path": "/id/public/3194",
        "hidden_test_path": "/id/hidden/3194",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "coursescheduleii1757",
        "topic": "Chương 1",
        "sub_topic": "Advanced Graph Problems",
        "name": "Course Schedule II",
        "description": "Your task is to count the number of ways you can fill an n × m grid using 1 × 2 and 2 × 1 tiles.\n\nInput\n\nThe only input line has two integers n and m .\n\nOutput\n\nPrint one integer: the number of ways modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 10 1 ≤ m ≤ 1000\n\nExample\n\nInput:\n\n\n4 7\n\n\nOutput:\n\n\n781",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\nN, M = int(data[0]), int(data[1])\nG = [[] for _ in range(N + 1)]\nin_degree = [0] * (N + 1)\nans = [0] * (N + 1)\n\nindex = 2\nfor _ in range(M):\n    a, b = int(data[index]), int(data[index + 1])\n    G[b].append(a)\n    in_degree[a] += 1\n    index += 2\n\nQ = []\nfor i in range(1, N + 1):\n    if in_degree[i] == 0:\n        heapq.heappush(Q, -i)\n\nidx = N\nwhile Q:\n    u = -heapq.heappop(Q)\n    ans[idx] = u\n    idx -= 1\n    for v in G[u]:\n        in_degree[v] -= 1\n        if in_degree[v] == 0:\n            heapq.heappush(Q, -v)\n\nprint(' '.join(map(str, ans[1:])))",
        "public_test_path": "/id/public/1757",
        "hidden_test_path": "/id/hidden/1757",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "transferspeedssum3111",
        "topic": "Chương 1",
        "sub_topic": "Advanced Graph Problems",
        "name": "Transfer Speeds Sum",
        "description": "Your task is to count the number of integers between a and b where no two adjacent digits are the same.\n\nInput\n\nThe only input line has two integers a and b .\n\nOutput\n\nPrint one integer: the answer to the problem.\n\nConstraints\n\n0 ≤ a ≤ b ≤ 10^{18}\n\nExample\n\nInput:\n\n\n123 321\n\n\nOutput:\n\n\n171",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from sys import stdin, stdout\nfrom collections import defaultdict\n\nmaxN = 200001\n\nN = int(stdin.readline().strip())\nds = [-1] * maxN\nans = 0\nedges = []\n\ndef find(u):\n    if ds[u] < 0:\n        return u\n    ds[u] = find(ds[u])\n    return ds[u]\n\ndef merge(u, v):\n    u = find(u)\n    v = find(v)\n    if u == v:\n        return False\n    if ds[u] < ds[v]:\n        u, v = v, u\n    ds[v] += ds[u]\n    ds[u] = v\n    return True\n\nfor _ in range(N - 1):\n    a, b, x = map(int, stdin.readline().strip().split())\n    edges.append((a, b, x))\n\nedges.sort(key=lambda e: e[2], reverse=True)\n\nfor a, b, x in edges:\n    a = find(a)\n    b = find(b)\n    sza = -ds[a]\n    szb = -ds[b]\n\n    ans += x * sza * szb\n    merge(a, b)\n\nstdout.write(f\"{ans}\\n\")",
        "public_test_path": "/id/public/3111",
        "hidden_test_path": "/id/hidden/3111",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    },
    {
        "problem_id": "treeisomorphismi1700",
        "topic": "Chương 1",
        "sub_topic": "Advanced Graph Problems",
        "name": "Tree Isomorphism I",
        "description": "Given an array of n integers, your task is to calculate the number of increasing subsequences it contains. If two subsequences have the same values but in different positions in the array, they are counted separately.\n\nInput\n\nThe first input line has an integer n : the size of the array.\n\nThe second line has n integers x_1,x_2,…,x_n : the contents of the array.\n\nOutput\n\nPrint one integer: the number of increasing subsequences modulo 10^9+7 .\n\nConstraints\n\n1 ≤ n ≤ 2 · 10^5 1 ≤ x_i ≤ 10^9\n\nExample\n\nInput:\n\n\n3\n2 1 3\n\n\nOutput:\n\n\n5\n\n\nExplanation: The increasing subsequences are [2] , [1] , [3] , [2,3] and [1,3] .",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\n\nmaxN = int(1e5) + 1\n\nN = 0\ntreeID = 0\nname = [[0] * maxN for _ in range(2)]\nG = [[[] for _ in range(maxN)] for _ in range(2)]\nmp = {}\n\ndef reset():\n    global G, N\n    for t in range(2):\n        for i in range(1, N + 1):\n            G[t][i].clear()\n\ndef dfs(t, u, p):\n    childNames = []\n    for v in G[t][u]:\n        if v != p:\n            dfs(t, v, u)\n            childNames.append(name[t][v])\n    childNames.sort()\n    if tuple(childNames) not in mp:\n        global treeID\n        treeID += 1\n        mp[tuple(childNames)] = treeID\n    name[t][u] = mp[tuple(childNames)]\n\ndef solve_case():\n    global N, treeID, mp\n    N = int(input())\n    reset()\n    for t in range(2):\n        for _ in range(N - 1):\n            a, b = map(int, input().split())\n            G[t][a].append(b)\n            G[t][b].append(a)\n        dfs(t, 1, -1)\n    print(\"YES\" if name[0][1] == name[1][1] else \"NO\")\n\nT = int(input())\nfor _ in range(T):\n    solve_case()",
        "public_test_path": "/id/public/1700",
        "hidden_test_path": "/id/hidden/1700",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 19
    },
    {
        "problem_id": "treeisomorphismii1701",
        "topic": "Chương 1",
        "sub_topic": "Advanced Graph Problems",
        "name": "Tree Isomorphism II",
        "description": "You are given a map of a building, and your task is to count the number of its rooms. The size of the map is n × m squares, and each square is either floor or wall. You can walk left, right, up, and down through the floor squares.\n\nInput\n\nThe first input line has two integers n and m : the height and width of the map.\n\nThen there are n lines of m characters describing the map. Each character is either . (floor) or # (wall).\n\nOutput\n\nPrint one integer: the number of rooms.\n\nConstraints\n\n1 ≤ n,m ≤ 1000\n\nExample\n\nInput:\n\n\n5 8\n########\n#..#...#\n####.#.#\n#..#...#\n########\n\n\nOutput:\n\n\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\n\nmaxN = int(1e5 + 1)\n\nN = 0\ntreeID = 0\nsz = [[0] * maxN for _ in range(2)]\nname = [[0] * maxN for _ in range(2)]\ncentroids = [[] for _ in range(2)]\nG = [[[] for _ in range(maxN)] for _ in range(2)]\nmp = {}\n\ndef reset():\n    global mp, treeID, centroids, sz, name, G\n    mp.clear()\n    treeID = 0\n    for t in range(2):\n        centroids[t].clear()\n        for i in range(1, N + 1):\n            sz[t][i] = name[t][i] = 0\n            G[t][i].clear()\n\ndef dfs1(t, u, p):\n    global N\n    sz[t][u] = 1\n    is_centroid = True\n    for v in G[t][u]:\n        if v != p:\n            dfs1(t, v, u)\n            sz[t][u] += sz[t][v]\n            if sz[t][v] > N // 2:\n                is_centroid = False\n    if N - sz[t][u] > N // 2:\n        is_centroid = False\n    if is_centroid:\n        centroids[t].append(u)\n\ndef dfs2(t, u, p):\n    childNames = []\n    for v in G[t][u]:\n        if v != p:\n            dfs2(t, v, u)\n            childNames.append(name[t][v])\n    childNames.sort()\n    if tuple(childNames) not in mp:\n        mp[tuple(childNames)] = treeID + 1\n        global treeID\n        treeID += 1\n    name[t][u] = mp[tuple(childNames)]\n\ndef solve_case():\n    global N\n    N = int(input())\n    reset()\n\n    for t in range(2):\n        for _ in range(N - 1):\n            a, b = map(int, input().split())\n            G[t][a].append(b)\n            G[t][b].append(a)\n        dfs1(t, 1, -1)\n\n    for root1 in centroids[0]:\n        for root2 in centroids[1]:\n            dfs2(0, root1, -1)\n            dfs2(1, root2, -1)\n            if name[0][root1] == name[1][root2]:\n                print(\"YES\")\n                return\n    print(\"NO\")\n\nT = int(input())\nfor _ in range(T):\n    solve_case()",
        "public_test_path": "/id/public/1701",
        "hidden_test_path": "/id/hidden/1701",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 16
    },
    {
        "problem_id": "gridpathsii1078",
        "topic": "Chương 1",
        "sub_topic": "Counting Problems",
        "name": "Grid Paths II",
        "description": "You are given a map of a labyrinth, and your task is to find a path from start to end. You can walk left, right, up and down.\n\nInput\n\nThe first input line has two integers n and m : the height and width of the map.\n\nThen there are n lines of m characters describing the labyrinth. Each character is . (floor), # (wall), A (start), or B (end). There is exactly one A and one B in the input.\n\nOutput\n\nFirst print \"YES\", if there is a path, and \"NO\" otherwise.\n\nIf there is a path, print the length of the shortest such path and its description as a string consisting of characters L (left), R (right), U (up), and D (down). You can print any valid solution.\n\nConstraints\n\n1 ≤ n,m ≤ 1000\n\nExample\n\nInput:\n\n\n5 8\n########\n#.A#...#\n#.##.#B#\n#......#\n########\n\n\nOutput:\n\n\nYES\n9\nLDDRRRRRU",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = int(1e9 + 7)\nmaxN = int(2e6 + 1)\nmaxM = 1002\n\nN, M = 0, 0\nfact = [0] * maxN\ninv = [0] * maxN\ndp = [0] * maxM\np = [(0, 0)] * maxM\n\ndef inverse(a):\n    res = 1\n    b = MOD - 2\n    while b > 0:\n        if b & 1:\n            res = (res * a) % MOD\n        a = (a * a) % MOD\n        b >>= 1\n    return res\n\ndef init():\n    global fact, inv\n    fact[0] = inv[0] = 1\n    for i in range(1, maxN):\n        fact[i] = i * fact[i - 1] % MOD\n        inv[i] = inverse(fact[i])\n\ndef choose(n, k):\n    return fact[n] * inv[n - k] % MOD * inv[k] % MOD\n\ndef main():\n    global N, M, p, dp\n    init()\n    N, M = map(int, input().split())\n    for i in range(M):\n        x, y = map(int, input().split())\n        p[i] = (x, y)\n    p[M] = (N, N)\n    p = sorted(p[:M + 1], key=lambda a: (a[0], a[1]))\n\n    for i in range(M + 1):\n        dp[i] = choose(p[i][0] + p[i][1] - 2, p[i][0] - 1)\n        subtract = 0\n        for j in range(i):\n            if p[i][0] >= p[j][0] and p[i][1] >= p[j][1]:\n                dx = p[i][0] - p[j][0]\n                dy = p[i][1] - p[j][1]\n                subtract += dp[j] * choose(dx + dy, dx)\n                subtract %= MOD\n        dp[i] = (dp[i] - subtract + MOD) % MOD\n\n    print(dp[M])\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/1078",
        "hidden_test_path": "/id/hidden/1078",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "countingpermutations1075",
        "topic": "Chương 1",
        "sub_topic": "Counting Problems",
        "name": "Counting Permutations",
        "description": "Byteland has n cities, and m roads between them. The goal is to construct new roads so that there is a route between any two cities.\n\nYour task is to find out the minimum number of roads required, and also determine which roads should be built.\n\nInput\n\nThe first input line has two integers n and m : the number of cities and roads. The cities are numbered 1,2,…,n .\n\nAfter that, there are m lines describing the roads. Each line has two integers a and b : there is a road between those cities.\n\nA road always connects two different cities, and there is at most one road between any two cities.\n\nOutput\n\nFirst print an integer k : the number of required roads.\n\nThen, print k lines that describe the new roads. You can print any valid solution.\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n4 2\n1 2\n3 4\n\n\nOutput:\n\n\n1\n2 3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "maxN = 1000\nMOD = int(1e9 + 7)\n\ndp = [0] * (maxN + 1)\n\ndef init():\n    dp[0] = dp[1] = 1\n    dp[2] = dp[3] = 0\n    for i in range(4, maxN + 1):\n        a = (i + 1) * dp[i - 1] % MOD\n        b = (i - 2) * dp[i - 2] % MOD\n        c = (i - 5) * dp[i - 3] % MOD\n        d = (i - 3) * dp[i - 4] % MOD\n\n        dp[i] = (a - b - c + d) % MOD\n        while dp[i] < 0:\n            dp[i] += MOD\n\ninit()\nN = int(input())\nprint(dp[N])",
        "public_test_path": "/id/public/1075",
        "hidden_test_path": "/id/hidden/1075",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 23
    },
    {
        "problem_id": "shortestsubsequence1087",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems I",
        "name": "Shortest Subsequence",
        "description": "Syrjälä's network has n computers and m connections. Your task is to find out if Uolevi can send a message to Maija, and if it is possible, what is the minimum number of computers on such a route.\n\nInput\n\nThe first input line has two integers n and m : the number of computers and connections. The computers are numbered 1,2,…,n . Uolevi's computer is 1 and Maija's computer is n .\n\nThen, there are m lines describing the connections. Each line has two integers a and b : there is a connection between those computers.\n\nEvery connection is between two different computers, and there is at most one connection between any two computers.\n\nOutput\n\nIf it is possible to send a message, first print k : the minimum number of computers on a valid route. After this, print an example of such a route. You can print any valid solution.\n\nIf there are no routes, print \"IMPOSSIBLE\".\n\nConstraints\n\n2 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 5\n1 2\n1 3\n1 4\n2 3\n5 4\n\n\nOutput:\n\n\n3\n1 4 5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "maxN = int(1e6 + 5)\n\nN = 0\ncnt = 0\nS = \"\"\nch = ['A', 'C', 'G', 'T']\nhas = [False] * 4\nsegs = []\nmp = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\ndef init():\n    global mp\n    mp['A'] = 0\n    mp['C'] = 1\n    mp['G'] = 2\n    mp['T'] = 3\n\ninit()\nS = input().strip()\n\nN = len(S)\nfor i in range(N):\n    c = mp[S[i]]\n    if not has[c]:\n        has[c] = True\n        cnt += 1\n        if cnt == 4:\n            has = [False] * 4\n            segs.append(i)\n            cnt = 0\n\nfor i in segs:\n    print(S[i], end='')\nfor i in range(4):\n    if not has[i]:\n        print(ch[i])\n        break",
        "public_test_path": "/id/public/1087",
        "hidden_test_path": "/id/hidden/1087",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 5
    },
    {
        "problem_id": "bubblesortroundsi3151",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems I",
        "name": "Bubble Sort Rounds I",
        "description": "There are n pupils in Uolevi's class, and m friendships between them. Your task is to divide the pupils into two teams in such a way that no two pupils in a team are friends. You can freely choose the sizes of the teams.\n\nInput\n\nThe first input line has two integers n and m : the number of pupils and friendships. The pupils are numbered 1,2,…,n .\n\nThen, there are m lines describing the friendships. Each line has two integers a and b : pupils a and b are friends.\n\nEvery friendship is between two different pupils. You can assume that there is at most one friendship between any two pupils.\n\nOutput\n\nPrint an example of how to build the teams. For each pupil, print \"1\" or \"2\" depending on to which team the pupil will be assigned. You can print any valid team.\n\nIf there are no solutions, print \"IMPOSSIBLE\".\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 3\n1 2\n1 3\n4 5\n\n\nOutput:\n\n\n1 2 2 1 2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "N = int(input())\nx = list(map(int, input().split()))\nsorted_pairs = sorted(enumerate(x), key=lambda pair: pair[1], reverse=True)\n\nworst_dist = 0\nfor i in range(N):\n    targ = N - i - 1\n    start = sorted_pairs[i][0]\n    worst_dist = max(worst_dist, start - targ)\n\nprint(worst_dist)",
        "public_test_path": "/id/public/3151",
        "hidden_test_path": "/id/hidden/3151",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "countinglcmarrays3169",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems I",
        "name": "Counting LCM Arrays",
        "description": "Byteland has n cities and m roads between them. Your task is to design a round trip that begins in a city, goes through two or more other cities, and finally returns to the starting city. Every intermediate city on the route has to be distinct.\n\nInput\n\nThe first input line has two integers n and m : the number of cities and roads. The cities are numbered 1,2,…,n .\n\nThen, there are m lines describing the roads. Each line has two integers a and b : there is a road between those cities.\n\nEvery road is between two different cities, and there is at most one road between any two cities.\n\nOutput\n\nFirst print an integer k : the number of cities on the route. Then print k cities in the order they will be visited. You can print any valid solution.\n\nIf there are no solutions, print \"IMPOSSIBLE\".\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 6\n1 3\n1 2\n5 3\n1 5\n2 4\n4 5\n\n\nOutput:\n\n\n4\n3 5 1 3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "MOD = int(1e9 + 7)\n\nclass Matrix2x2:\n    def __init__(self, a, b, c, d):\n        self.a = a\n        self.b = b\n        self.c = c\n        self.d = d\n\n    def __mul__(self, other):\n        return Matrix2x2(\n            (self.a * other.a + self.b * other.c) % MOD,\n            (self.a * other.b + self.b * other.d) % MOD,\n            (self.c * other.a + self.d * other.c) % MOD,\n            (self.c * other.b + self.d * other.d) % MOD\n        )\n\ndef fast_pow(base, exp):\n    result = Matrix2x2(1, 0, 0, 1)\n    while exp > 0:\n        if exp % 2 == 1:\n            result = result * base\n        base = base * base\n        exp //= 2\n    return result\n\ndef prime_factor(k):\n    factors = []\n    for i in range(2, int(k**0.5) + 1):\n        count = 0\n        while k % i == 0:\n            k //= i\n            count += 1\n        if count > 0:\n            factors.append((i, count))\n    if k > 1:\n        factors.append((k, 1))\n    return factors\n\ndef solve(n, k):\n    factors = prime_factor(k)\n    ans = 1\n    for p, e in factors:\n        base = Matrix2x2(1, 1, e, 0)\n        result = fast_pow(base, n + 1)\n        ans = (ans * result.a) % MOD\n    return ans\n\nif __name__ == \"__main__\":\n    T = int(input())\n    for _ in range(T):\n        n, k = map(int, input().split())\n        print(solve(n, k))",
        "public_test_path": "/id/public/3169",
        "hidden_test_path": "/id/hidden/3169",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 7
    },
    {
        "problem_id": "squaresubsets3193",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems I",
        "name": "Square Subsets",
        "description": "You and some monsters are in a labyrinth. When taking a step to some direction in the labyrinth, each monster may simultaneously take one as well. Your goal is to reach one of the boundary squares without ever sharing a square with a monster.\n\nYour task is to find out if your goal is possible, and if it is, print a path that you can follow. Your plan has to work in any situation; even if the monsters know your path beforehand.\n\nInput\n\nThe first input line has two integers n and m : the height and width of the map.\n\nAfter this there are n lines of m characters describing the map. Each character is . (floor), # (wall), A (start), or M (monster). There is exactly one A in the input.\n\nOutput\n\nFirst print \"YES\" if your goal is possible, and \"NO\" otherwise.\n\nIf your goal is possible, also print an example of a valid path (the length of the path and its description using characters D , U , L , and R ). You can print any path, as long as its length is at most n · m steps.\n\nConstraints\n\n1 ≤ n,m ≤ 1000\n\nExample\n\nInput:\n\n\n5 8\n########\n#M..A..#\n#.#.M#.#\n#M#..#..\n#.######\n\n\nOutput:\n\n\nYES\n5\nRRDDR",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from bitarray import bitarray\n\nmaxX = 5005\nSIZE = 700\nMOD = int(1e9 + 7)\n\nN = 0\nans = 0\np = [True] * maxX\nprimes = []\nbasis = [bitarray(SIZE) for _ in range(SIZE)]\n\ndef generate_primes():\n    for i in range(2, maxX):\n        if p[i]:\n            primes.append(i)\n            for j in range(2 * i, maxX, i):\n                p[j] = False\n\ndef prime_factor(x):\n    factors = bitarray(SIZE)\n    factors.setall(0)\n    for i in range(len(primes)):\n        if primes[i] > x:\n            break\n        power = 0\n        while x % primes[i] == 0:\n            x //= primes[i]\n            power += 1\n        factors[i] = (power % 2 == 1)\n    return factors\n\ndef insert_vector(mask):\n    for i in range(SIZE - 1, -1, -1):\n        if mask[i] == 0:\n            continue\n        if not basis[i].any():\n            basis[i] = mask\n            return True\n        mask ^= basis[i]\n    return False\n\nif __name__ == \"__main__\":\n    N = int(input())\n    generate_primes()\n\n    ans = 1\n    for _ in range(N):\n        x = int(input())\n        factors = prime_factor(x)\n        if not insert_vector(factors):\n            ans = (ans * 2) % MOD\n    print(ans)",
        "public_test_path": "/id/public/3193",
        "hidden_test_path": "/id/hidden/3193",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "maximumbuildingi1147",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems I",
        "name": "Maximum Building I",
        "description": "There are n cities and m flight connections between them. Your task is to determine the length of the shortest route from Syrjälä to every city.\n\nInput\n\nThe first input line has two integers n and m : the number of cities and flight connections. The cities are numbered 1,2,…,n , and city 1 is Syrjälä.\n\nAfter that, there are m lines describing the flight connections. Each line has three integers a , b and c : a flight begins at city a , ends at city b , and its length is c . Each flight is a one-way flight.\n\nYou can assume that it is possible to travel from Syrjälä to all other cities.\n\nOutput\n\nPrint n integers: the shortest route lengths from Syrjälä to cities 1,2,…,n .\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n 1 ≤ c ≤ 10^9\n\nExample\n\nInput:\n\n\n3 4\n1 2 6\n1 3 2\n3 2 3\n1 3 4\n\n\nOutput:\n\n\n0 5 2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "N, M = map(int, input().split())\nS = [input().strip() for _ in range(N)]\n\nmaxN = 1002\nh = [0] * maxN\nl = [0] * maxN\nr = [0] * maxN\nbest = 0\n\nh[0] = h[M + 1] = -1\n\nfor i in range(1, N + 1):\n    for j in range(1, M + 1):\n        h[j] = 0 if S[i - 1][j - 1] == '*' else h[j] + 1\n\n    for j in range(1, M + 1):\n        smaller = j - 1\n        while h[smaller] >= h[j]:\n            smaller = l[smaller]\n        l[j] = smaller\n\n    for j in range(M, 0, -1):\n        smaller = j + 1\n        while h[smaller] >= h[j]:\n            smaller = r[smaller]\n        r[j] = smaller\n\n    for j in range(1, M + 1):\n        base = r[j] - l[j] - 1\n        best = max(best, base * h[j])\n\nprint(best)",
        "public_test_path": "/id/public/1147",
        "hidden_test_path": "/id/hidden/1147",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "increasingarrayii2132",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems II",
        "name": "Increasing Array II",
        "description": "There are n cities and m roads between them. Your task is to process q queries where you have to determine the length of the shortest route between two given cities.\n\nInput\n\nThe first input line has three integers n , m and q : the number of cities, roads, and queries.\n\nThen, there are m lines describing the roads. Each line has three integers a , b and c : there is a road between cities a and b whose length is c . All roads are two-way roads.\n\nFinally, there are q lines describing the queries. Each line has two integers a and b : determine the length of the shortest route between cities a and b .\n\nOutput\n\nPrint the length of the shortest route for each query. If there is no route, print -1 instead.\n\nConstraints\n\n1 ≤ n ≤ 500 1 ≤ m ≤ n^2 1 ≤ q ≤ 10^5 1 ≤ a,b ≤ n 1 ≤ c ≤ 10^9\n\nExample\n\nInput:\n\n\n4 3 5\n1 2 5\n1 3 9\n2 3 3\n1 2\n2 1\n1 3\n1 4\n3 2\n\n\nOutput:\n\n\n5\n5\n8\n-1\n3",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import heapq\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nans = 0\nQ = []\n\nfor i in range(1, N + 1):\n    x = int(data[i])\n    heapq.heappush(Q, -x)\n    ans += -Q[0] - x\n    heapq.heappop(Q)\n    heapq.heappush(Q, -x)\n\nprint(ans)",
        "public_test_path": "/id/public/2132",
        "hidden_test_path": "/id/hidden/2132",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "schoolexcursion1706",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems II",
        "name": "School Excursion",
        "description": "You play a game consisting of n rooms and m tunnels. Your initial score is 0 , and each tunnel increases your score by x where x may be both positive or negative. You may go through a tunnel several times.\n\nYour task is to walk from room 1 to room n . What is the maximum score you can get?\n\nInput\n\nThe first input line has two integers n and m : the number of rooms and tunnels. The rooms are numbered 1,2,…,n .\n\nThen, there are m lines describing the tunnels. Each line has three integers a , b and x : the tunnel starts at room a , ends at room b , and it increases your score by x . All tunnels are one-way tunnels.\n\nYou can assume that it is possible to get from room 1 to room n .\n\nOutput\n\nPrint one integer: the maximum score you can get. However, if you can get an arbitrarily large score, print -1 .\n\nConstraints\n\n1 ≤ n ≤ 2500 1 ≤ m ≤ 5000 1 ≤ a,b ≤ n -10^9 ≤ x ≤ 10^9\n\nExample\n\nInput:\n\n\n4 5\n1 2 3\n2 4 -1\n1 3 -2\n3 4 7\n1 4 4\n\n\nOutput:\n\n\n5",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import defaultdict\n\nmaxN = int(1e5) + 1\n\nN, M = map(int, input().split())\nds = [-1] * (maxN)\nsizes = set()\ndp = [0] * (maxN)\ndp[0] = 1\n\ndef find(u):\n    if ds[u] < 0:\n        return u\n    ds[u] = find(ds[u])\n    return ds[u]\n\ndef merge(u, v):\n    u = find(u)\n    v = find(v)\n    if u == v:\n        return False\n    if ds[u] < ds[v]:\n        u, v = v, u\n    ds[v] += ds[u]\n    ds[u] = v\n    return True\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    merge(a, b)\n\nfor i in range(1, N + 1):\n    if find(i) == i:\n        sizes.add(-ds[i])\n\nfor sz in sizes:\n    dp = [dp[j] or dp[j - sz] for j in range(maxN)]\n\nfor i in range(1, N + 1):\n    print(1 if dp[i] else 0, end='')\nprint()",
        "public_test_path": "/id/public/1706",
        "hidden_test_path": "/id/hidden/1706",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 13
    },
    {
        "problem_id": "gridpuzzlei2432",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems II",
        "name": "Grid Puzzle I",
        "description": "Your task is to find a minimum-price flight route from Syrjälä to Metsälä. You have one discount coupon, using which you can halve the price of any single flight during the route. However, you can only use the coupon once.\n\nWhen you use the discount coupon for a flight whose price is x , its price becomes ⌊ x/2 ⌋ (it is rounded down to an integer).\n\nInput\n\nThe first input line has two integers n and m : the number of cities and flight connections. The cities are numbered 1,2,…,n . City 1 is Syrjälä, and city n is Metsälä.\n\nAfter this there are m lines describing the flights. Each line has three integers a , b , and c : a flight begins at city a , ends at city b , and its price is c . Each flight is unidirectional.\n\nYou can assume that it is always possible to get from Syrjälä to Metsälä.\n\nOutput\n\nPrint one integer: the price of the cheapest route from Syrjälä to Metsälä.\n\nConstraints\n\n2 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n 1 ≤ c ≤ 10^9\n\nExample\n\nInput:\n\n\n3 4\n1 2 3\n2 3 1\n1 3 7\n2 1 5\n\n\nOutput:\n\n\n2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import deque\n\nmaxN = 105\nmaxM = 2605\nINF = float('inf')\n\nN = 0\nrowTot = 0\ncolTot = 0\nedgeID = 0\np = [-1] * (2 * maxN + 2)\ncap = [[0] * (2 * maxN + 2) for _ in range(2 * maxN + 2)]\nvis = [False] * maxM\npath = []\nF = [[] for _ in range(maxN)]\nG = [[] for _ in range(maxN)]\n\ndef bfs(s=0, t=2 * N + 1):\n    global p\n    p = [-1] * (2 * N + 2)\n    p[s] = -2\n\n    Q = deque()\n    Q.append((s, INF))\n    while Q:\n        u, f = Q.popleft()\n\n        for v in F[u]:\n            if p[v] == -1 and cap[u][v]:\n                p[v] = u\n                aug = min(f, cap[u][v])\n                if v == t:\n                    return aug\n                Q.append((v, aug))\n\n    return 0\n\ndef dfs(u=0):\n    path.append(u)\n    if u == N:\n        return\n    for e in G[u]:\n        v, id = e\n        if cap[u][v] == 0 and not vis[id]:\n            vis[id] = True\n            dfs(v)\n            return\n\ndef maxflow(s=0, t=2 * N + 1):\n    flow = 0\n    while True:\n        aug = bfs()\n        if aug == 0:\n            break\n        flow += aug\n        u = t\n        while u != s:\n            v = p[u]\n            cap[v][u] -= aug\n            cap[u][v] += aug\n            u = v\n    return flow\n\nif __name__ == \"__main__\":\n    N = int(input())\n    for i in range(1, N + 1):\n        c = int(input())\n        G[0].append((i, edgeID + 1))\n        F[0].append(i)\n        F[i].append(0)\n        cap[0][i] += c\n        rowTot += c\n        edgeID += 1\n\n    for i in range(N + 1, 2 * N + 1):\n        c = int(input())\n        G[i].append((2 * N + 1, edgeID + 1))\n        F[i].append(2 * N + 1)\n        F[2 * N + 1].append(i)\n        cap[i][2 * N + 1] += c\n        colTot += c\n        edgeID += 1\n\n    for i in range(1, N + 1):\n        for j in range(N + 1, 2 * N + 1):\n            G[i].append((j, edgeID + 1))\n            F[i].append(j)\n            F[j].append(i)\n            cap[i][j] += 1\n            edgeID += 1\n\n    K = maxflow()\n    if rowTot != colTot or K != rowTot:\n        print(\"-1\")\n    else:\n        for i in range(1, N + 1):\n            for j in range(1, N + 1):\n                print('.' if cap[i][j + N] else 'X', end='')\n            print()",
        "public_test_path": "/id/public/2432",
        "hidden_test_path": "/id/hidden/2432",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 12
    },
    {
        "problem_id": "gridpuzzleii2131",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems II",
        "name": "Grid Puzzle II",
        "description": "You are given a directed graph, and your task is to find out if it contains a negative cycle, and also give an example of such a cycle.\n\nInput\n\nThe first input line has two integers n and m : the number of nodes and edges. The nodes are numbered 1,2,…,n .\n\nAfter this, the input has m lines describing the edges. Each line has three integers a , b , and c : there is an edge from node a to node b whose length is c .\n\nOutput\n\nIf the graph contains a negative cycle, print first \"YES\", and then the nodes in the cycle in their correct order. If there are several negative cycles, you can print any of them. If there are no negative cycles, print \"NO\".\n\nConstraints\n\n1 ≤ n ≤ 2500 1 ≤ m ≤ 5000 1 ≤ a,b ≤ n -10^9 ≤ c ≤ 10^9\n\nExample\n\nInput:\n\n\n4 5\n1 2 1\n2 4 1\n3 1 1\n4 1 -3\n4 3 -2\n\n\nOutput:\n\n\nYES\n1 2 4 1",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "from collections import deque\n\nmaxN = 105\nmaxM = 2605\nINF = float('inf')\n\nN = 0\nK = 0\nrowtot = 0\ncoltot = 0\nedgecnt = 0\np = [0] * maxN\nd = [0] * maxN\ninq = [False] * maxN\nvis = [False] * maxM\npath = []\nG = [[] for _ in range(maxN)]\n\nclass Edge:\n    def __init__(self, u, v, r, c):\n        self.u = u\n        self.v = v\n        self.r = r\n        self.c = c\n\nedges = [None] * maxM\nredges = [None] * maxM\n\ndef read_input():\n    global N, rowtot, coltot, edgecnt\n    N = int(input())\n    for v in range(1, N + 1):\n        cap = int(input())\n        global rowtot, edgecnt\n        rowtot += cap\n        edgecnt += 1\n        G[0].append(edgecnt)\n        G[v].append(-edgecnt)\n        edges[edgecnt] = Edge(0, v, cap, 0)\n        redges[edgecnt] = Edge(v, 0, 0, 0)\n    \n    for u in range(N + 1, 2 * N + 1):\n        cap = int(input())\n        global coltot\n        coltot += cap\n        edgecnt += 1\n        G[u].append(edgecnt)\n        G[2 * N + 1].append(-edgecnt)\n        edges[edgecnt] = Edge(u, 2 * N + 1, cap, 0)\n        redges[edgecnt] = Edge(2 * N + 1, u, 0, 0)\n    \n    for u in range(1, N + 1):\n        for v in range(N + 1, 2 * N + 1):\n            cost = int(input())\n            edgecnt += 1\n            G[u].append(edgecnt)\n            G[v].append(-edgecnt)\n            edges[edgecnt] = Edge(u, v, 1, -cost)\n            redges[edgecnt] = Edge(v, u, 0, cost)\n\ndef bellman_ford(s=0):\n    global inq, d, p\n    inq = [False] * (2 * N + 2)\n    d = [INF] * (2 * N + 2)\n    p = [0] * (2 * N + 2)\n\n    Q = deque()\n    Q.append(s)\n    d[s] = 0\n    inq[s] = True\n    while Q:\n        u = Q.popleft()\n        inq[u] = False\n\n        for i in G[u]:\n            e = redges[-i] if i < 0 else edges[i]\n            if e.r > 0 and d[e.v] > d[u] + e.c:\n                d[e.v] = d[u] + e.c\n                p[e.v] = i\n                if not inq[e.v]:\n                    inq[e.v] = True\n                    Q.append(e.v)\n\ndef minimum_cost_flow(s=0, t=2 * N + 1):\n    flow = 0\n    cost = 0\n    while flow < K:\n        bellman_ford(s)\n        if d[t] == INF:\n            break\n\n        aug = K - flow\n        u = t\n        while u != s:\n            e = redges[-p[u]] if p[u] < 0 else edges[p[u]]\n            aug = min(aug, e.r)\n            u = e.u\n\n        flow += aug\n        cost += aug * d[t]\n        u = t\n        while u != s:\n            if p[u] < 0:\n                redges[-p[u]].r -= aug\n                edges[-p[u]].r += aug\n            else:\n                redges[p[u]].r += aug\n                edges[p[u]].r -= aug\n            u = redges[-p[u]].u if p[u] < 0 else edges[p[u]].u\n    return INF if flow < K else cost\n\ndef main():\n    global K\n    read_input()\n\n    K = rowtot\n    max_reward = -minimum_cost_flow()\n    if rowtot != coltot or max_reward == -INF:\n        print(\"-1\")\n        return\n\n    print(max_reward)\n    for e in edges:\n        if e and e.u != 0 and e.v != 2 * N + 1:\n            print('X' if e.r == 0 else '.', end='')\n            if e.v == 2 * N:\n                print()\n\nif __name__ == \"__main__\":\n    main()",
        "public_test_path": "/id/public/2131",
        "hidden_test_path": "/id/hidden/2131",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 8
    },
    {
        "problem_id": "bookshopii1159",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems II",
        "name": "Book Shop II",
        "description": "Your task is to find the k shortest flight routes from Syrjälä to Metsälä. A route can visit the same city several times.\n\nNote that there can be several routes with the same price and each of them should be considered (see the example).\n\nInput\n\nThe first input line has three integers n , m , and k : the number of cities, the number of flights, and the parameter k . The cities are numbered 1,2,…,n . City 1 is Syrjälä, and city n is Metsälä.\n\nAfter this, the input has m lines describing the flights. Each line has three integers a , b , and c : a flight begins at city a , ends at city b , and its price is c . All flights are one-way flights.\n\nYou may assume that there are at least k distinct routes from Syrjälä to Metsälä.\n\nOutput\n\nPrint k integers: the prices of the k cheapest routes sorted according to their prices.\n\nConstraints\n\n2 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n 1 ≤ c ≤ 10^9 1 ≤ k ≤ 10\n\nExample\n\nInput:\n\n\n4 6 3\n1 2 1\n1 3 3\n2 3 2\n2 4 6\n3 2 8\n3 4 1\n\n\nOutput:\n\n\n4 4 7\n\n\nExplanation: The cheapest routes are 1 → 3 → 4 (price 4 ), 1 → 2 → 3 → 4 (price 4 ) and 1 → 2 → 4 (price 7 ).",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "N, X = map(int, input().split())\nh = list(map(int, input().split()))\ns = list(map(int, input().split()))\nk = list(map(int, input().split()))\n\ndp = [-1] * (X + 1)\ndp[0] = 0\n\nfor i in range(N):\n    b = 1\n    while k[i] > 0:\n        amnt = min(b, k[i])\n        k[i] -= amnt\n        price = amnt * h[i]\n        pages = amnt * s[i]\n        for j in range(X, price - 1, -1):\n            if dp[j - price] != -1:\n                dp[j] = max(dp[j], dp[j - price] + pages)\n        b += 1\n\nfor i in range(1, X + 1):\n    dp[i] = max(dp[i], dp[i - 1])\n\nprint(dp[X])",
        "public_test_path": "/id/public/1159",
        "hidden_test_path": "/id/hidden/1159",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 10
    },
    {
        "problem_id": "mexgridqueries1157",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems II",
        "name": "Mex Grid Queries",
        "description": "Byteland has n cities and m flight connections. Your task is to design a round trip that begins in a city, goes through one or more other cities, and finally returns to the starting city. Every intermediate city on the route has to be distinct.\n\nInput\n\nThe first input line has two integers n and m : the number of cities and flights. The cities are numbered 1,2,…,n .\n\nThen, there are m lines describing the flights. Each line has two integers a and b : there is a flight connection from city a to city b . All connections are one-way flights from a city to another city.\n\nOutput\n\nFirst print an integer k : the number of cities on the route. Then print k cities in the order they will be visited. You can print any valid solution.\n\nIf there are no solutions, print \"IMPOSSIBLE\".\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n4 5\n1 3\n2 1\n2 4\n3 2\n3 4\n\n\nOutput:\n\n\n4\n2 1 3 2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "x, y = map(int, input().split())\nprint((x - 1) ^ (y - 1))",
        "public_test_path": "/id/public/1157",
        "hidden_test_path": "/id/hidden/1157",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 20
    },
    {
        "problem_id": "stickdivisions1161",
        "topic": "Chương 1",
        "sub_topic": "Additional Problems II",
        "name": "Stick Divisions",
        "description": "You have to complete n courses. There are m requirements of the form \"course a has to be completed before course b \". Your task is to find an order in which you can complete the courses.\n\nInput\n\nThe first input line has two integers n and m : the number of courses and requirements. The courses are numbered 1,2,…,n .\n\nAfter this, there are m lines describing the requirements. Each line has two integers a and b : course a has to be completed before course b .\n\nOutput\n\nPrint an order in which you can complete the courses. You can print any valid order that includes all the courses.\n\nIf there are no solutions, print \"IMPOSSIBLE\".\n\nConstraints\n\n1 ≤ n ≤ 10^5 1 ≤ m ≤ 2 · 10^5 1 ≤ a,b ≤ n\n\nExample\n\nInput:\n\n\n5 3\n1 2\n3 1\n4 5\n\n\nOutput:\n\n\n3 4 1 5 2",
        "difficulty": 2,
        "code_template": "def main():\n    # code here\n    pass\n\nif __name__ == \"__main__\":\n    main()",
        "guidelines": "",
        "solution": "import heapq\n\nN, x = map(int, input().split())\nsticks = []\n\nfor _ in range(N):\n    d = int(input())\n    heapq.heappush(sticks, d)\n\nsum = 0\nwhile len(sticks) > 1:\n    a = heapq.heappop(sticks)\n    b = heapq.heappop(sticks)\n    heapq.heappush(sticks, a + b)\n    sum += a + b\n\nprint(sum)",
        "public_test_path": "/id/public/1161",
        "hidden_test_path": "/id/hidden/1161",
        "steps": [],
        "clos": [],
        "time_limit_ms": 1000,
        "memory_limit_mb": 512,
        "isDone": false,
        "number_of_tests": 6
    }
]